/*! For license information please see bundle.js.LICENSE.txt */
(() => {
  "use strict";
  var e = { amdO: {} };
  e.g = (function () {
    if ("object" == typeof globalThis) return globalThis;
    try {
      return this || new Function("return this")();
    } catch (e) {
      if ("object" == typeof window) return window;
    }
  })();
  const t = "160",
    r = 0,
    n = 1,
    i = 2,
    o = 100,
    s = 101,
    a = 102,
    l = 200,
    c = 201,
    u = 202,
    h = 203,
    d = 204,
    p = 205,
    f = 206,
    m = 207,
    g = 208,
    _ = 209,
    v = 210,
    y = 211,
    b = 212,
    x = 213,
    w = 214,
    S = "attached",
    E = 301,
    M = 302,
    T = 306,
    A = 1e3,
    R = 1001,
    P = 1002,
    C = 1003,
    I = 1004,
    L = 1005,
    O = 1006,
    N = 1007,
    U = 1008,
    D = 1009,
    k = 1012,
    B = 1014,
    F = 1015,
    H = 1016,
    z = 1020,
    V = 1023,
    j = 1026,
    W = 1027,
    G = 33776,
    X = 33777,
    q = 33778,
    Y = 33779,
    K = 36492,
    $ = 2300,
    Q = 2301,
    J = 2302,
    Z = 3001,
    ee = "",
    te = "srgb",
    re = "srgb-linear",
    ne = "display-p3",
    ie = "display-p3-linear",
    oe = "linear",
    se = "srgb",
    ae = "rec709",
    le = "p3",
    ce = 7680,
    ue = 512,
    he = 513,
    de = 514,
    pe = 515,
    fe = 516,
    me = 517,
    ge = 518,
    _e = 519,
    ve = 35044,
    ye = "300 es",
    be = 1035,
    xe = 2e3,
    we = 2001;
  class Se {
    addEventListener(e, t) {
      void 0 === this._listeners && (this._listeners = {});
      const r = this._listeners;
      void 0 === r[e] && (r[e] = []), -1 === r[e].indexOf(t) && r[e].push(t);
    }
    hasEventListener(e, t) {
      if (void 0 === this._listeners) return !1;
      const r = this._listeners;
      return void 0 !== r[e] && -1 !== r[e].indexOf(t);
    }
    removeEventListener(e, t) {
      if (void 0 === this._listeners) return;
      const r = this._listeners[e];
      if (void 0 !== r) {
        const e = r.indexOf(t);
        -1 !== e && r.splice(e, 1);
      }
    }
    dispatchEvent(e) {
      if (void 0 === this._listeners) return;
      const t = this._listeners[e.type];
      if (void 0 !== t) {
        e.target = this;
        const r = t.slice(0);
        for (let t = 0, n = r.length; t < n; t++) r[t].call(this, e);
        e.target = null;
      }
    }
  }
  const Ee = [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "0a",
    "0b",
    "0c",
    "0d",
    "0e",
    "0f",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "1a",
    "1b",
    "1c",
    "1d",
    "1e",
    "1f",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "2a",
    "2b",
    "2c",
    "2d",
    "2e",
    "2f",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "3a",
    "3b",
    "3c",
    "3d",
    "3e",
    "3f",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "4a",
    "4b",
    "4c",
    "4d",
    "4e",
    "4f",
    "50",
    "51",
    "52",
    "53",
    "54",
    "55",
    "56",
    "57",
    "58",
    "59",
    "5a",
    "5b",
    "5c",
    "5d",
    "5e",
    "5f",
    "60",
    "61",
    "62",
    "63",
    "64",
    "65",
    "66",
    "67",
    "68",
    "69",
    "6a",
    "6b",
    "6c",
    "6d",
    "6e",
    "6f",
    "70",
    "71",
    "72",
    "73",
    "74",
    "75",
    "76",
    "77",
    "78",
    "79",
    "7a",
    "7b",
    "7c",
    "7d",
    "7e",
    "7f",
    "80",
    "81",
    "82",
    "83",
    "84",
    "85",
    "86",
    "87",
    "88",
    "89",
    "8a",
    "8b",
    "8c",
    "8d",
    "8e",
    "8f",
    "90",
    "91",
    "92",
    "93",
    "94",
    "95",
    "96",
    "97",
    "98",
    "99",
    "9a",
    "9b",
    "9c",
    "9d",
    "9e",
    "9f",
    "a0",
    "a1",
    "a2",
    "a3",
    "a4",
    "a5",
    "a6",
    "a7",
    "a8",
    "a9",
    "aa",
    "ab",
    "ac",
    "ad",
    "ae",
    "af",
    "b0",
    "b1",
    "b2",
    "b3",
    "b4",
    "b5",
    "b6",
    "b7",
    "b8",
    "b9",
    "ba",
    "bb",
    "bc",
    "bd",
    "be",
    "bf",
    "c0",
    "c1",
    "c2",
    "c3",
    "c4",
    "c5",
    "c6",
    "c7",
    "c8",
    "c9",
    "ca",
    "cb",
    "cc",
    "cd",
    "ce",
    "cf",
    "d0",
    "d1",
    "d2",
    "d3",
    "d4",
    "d5",
    "d6",
    "d7",
    "d8",
    "d9",
    "da",
    "db",
    "dc",
    "dd",
    "de",
    "df",
    "e0",
    "e1",
    "e2",
    "e3",
    "e4",
    "e5",
    "e6",
    "e7",
    "e8",
    "e9",
    "ea",
    "eb",
    "ec",
    "ed",
    "ee",
    "ef",
    "f0",
    "f1",
    "f2",
    "f3",
    "f4",
    "f5",
    "f6",
    "f7",
    "f8",
    "f9",
    "fa",
    "fb",
    "fc",
    "fd",
    "fe",
    "ff",
  ];
  const Me = Math.PI / 180,
    Te = 180 / Math.PI;
  function Ae() {
    const e = (4294967295 * Math.random()) | 0,
      t = (4294967295 * Math.random()) | 0,
      r = (4294967295 * Math.random()) | 0,
      n = (4294967295 * Math.random()) | 0;
    return (
      Ee[255 & e] +
      Ee[(e >> 8) & 255] +
      Ee[(e >> 16) & 255] +
      Ee[(e >> 24) & 255] +
      "-" +
      Ee[255 & t] +
      Ee[(t >> 8) & 255] +
      "-" +
      Ee[((t >> 16) & 15) | 64] +
      Ee[(t >> 24) & 255] +
      "-" +
      Ee[(63 & r) | 128] +
      Ee[(r >> 8) & 255] +
      "-" +
      Ee[(r >> 16) & 255] +
      Ee[(r >> 24) & 255] +
      Ee[255 & n] +
      Ee[(n >> 8) & 255] +
      Ee[(n >> 16) & 255] +
      Ee[(n >> 24) & 255]
    ).toLowerCase();
  }
  function Re(e, t, r) {
    return Math.max(t, Math.min(r, e));
  }
  function Pe(e, t) {
    return ((e % t) + t) % t;
  }
  function Ce(e, t, r) {
    return (1 - r) * e + r * t;
  }
  function Ie(e) {
    return !(e & (e - 1)) && 0 !== e;
  }
  function Le(e) {
    return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
  }
  function Oe(e, t) {
    switch (t.constructor) {
      case Float32Array:
        return e;
      case Uint32Array:
        return e / 4294967295;
      case Uint16Array:
        return e / 65535;
      case Uint8Array:
        return e / 255;
      case Int32Array:
        return Math.max(e / 2147483647, -1);
      case Int16Array:
        return Math.max(e / 32767, -1);
      case Int8Array:
        return Math.max(e / 127, -1);
      default:
        throw new Error("Invalid component type.");
    }
  }
  function Ne(e, t) {
    switch (t.constructor) {
      case Float32Array:
        return e;
      case Uint32Array:
        return Math.round(4294967295 * e);
      case Uint16Array:
        return Math.round(65535 * e);
      case Uint8Array:
        return Math.round(255 * e);
      case Int32Array:
        return Math.round(2147483647 * e);
      case Int16Array:
        return Math.round(32767 * e);
      case Int8Array:
        return Math.round(127 * e);
      default:
        throw new Error("Invalid component type.");
    }
  }
  const Ue = function (e) {
    return e * Te;
  };
  class De {
    constructor(e = 0, t = 0) {
      (De.prototype.isVector2 = !0), (this.x = e), (this.y = t);
    }
    get width() {
      return this.x;
    }
    set width(e) {
      this.x = e;
    }
    get height() {
      return this.y;
    }
    set height(e) {
      this.y = e;
    }
    set(e, t) {
      return (this.x = e), (this.y = t), this;
    }
    setScalar(e) {
      return (this.x = e), (this.y = e), this;
    }
    setX(e) {
      return (this.x = e), this;
    }
    setY(e) {
      return (this.y = e), this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y);
    }
    copy(e) {
      return (this.x = e.x), (this.y = e.y), this;
    }
    add(e) {
      return (this.x += e.x), (this.y += e.y), this;
    }
    addScalar(e) {
      return (this.x += e), (this.y += e), this;
    }
    addVectors(e, t) {
      return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
    }
    addScaledVector(e, t) {
      return (this.x += e.x * t), (this.y += e.y * t), this;
    }
    sub(e) {
      return (this.x -= e.x), (this.y -= e.y), this;
    }
    subScalar(e) {
      return (this.x -= e), (this.y -= e), this;
    }
    subVectors(e, t) {
      return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
    }
    multiply(e) {
      return (this.x *= e.x), (this.y *= e.y), this;
    }
    multiplyScalar(e) {
      return (this.x *= e), (this.y *= e), this;
    }
    divide(e) {
      return (this.x /= e.x), (this.y /= e.y), this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    applyMatrix3(e) {
      const t = this.x,
        r = this.y,
        n = e.elements;
      return (
        (this.x = n[0] * t + n[3] * r + n[6]),
        (this.y = n[1] * t + n[4] * r + n[7]),
        this
      );
    }
    min(e) {
      return (
        (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
      );
    }
    max(e) {
      return (
        (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
      );
    }
    clamp(e, t) {
      return (
        (this.x = Math.max(e.x, Math.min(t.x, this.x))),
        (this.y = Math.max(e.y, Math.min(t.y, this.y))),
        this
      );
    }
    clampScalar(e, t) {
      return (
        (this.x = Math.max(e, Math.min(t, this.x))),
        (this.y = Math.max(e, Math.min(t, this.y))),
        this
      );
    }
    clampLength(e, t) {
      const r = this.length();
      return this.divideScalar(r || 1).multiplyScalar(
        Math.max(e, Math.min(t, r))
      );
    }
    floor() {
      return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
    }
    ceil() {
      return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
    }
    round() {
      return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
    }
    roundToZero() {
      return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
    }
    negate() {
      return (this.x = -this.x), (this.y = -this.y), this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y;
    }
    cross(e) {
      return this.x * e.y - this.y * e.x;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI;
    }
    angleTo(e) {
      const t = Math.sqrt(this.lengthSq() * e.lengthSq());
      if (0 === t) return Math.PI / 2;
      const r = this.dot(e) / t;
      return Math.acos(Re(r, -1, 1));
    }
    distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
      const t = this.x - e.x,
        r = this.y - e.y;
      return t * t + r * r;
    }
    manhattanDistanceTo(e) {
      return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return (
        (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
      );
    }
    lerpVectors(e, t, r) {
      return (
        (this.x = e.x + (t.x - e.x) * r), (this.y = e.y + (t.y - e.y) * r), this
      );
    }
    equals(e) {
      return e.x === this.x && e.y === this.y;
    }
    fromArray(e, t = 0) {
      return (this.x = e[t]), (this.y = e[t + 1]), this;
    }
    toArray(e = [], t = 0) {
      return (e[t] = this.x), (e[t + 1] = this.y), e;
    }
    fromBufferAttribute(e, t) {
      return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
    }
    rotateAround(e, t) {
      const r = Math.cos(t),
        n = Math.sin(t),
        i = this.x - e.x,
        o = this.y - e.y;
      return (
        (this.x = i * r - o * n + e.x), (this.y = i * n + o * r + e.y), this
      );
    }
    random() {
      return (this.x = Math.random()), (this.y = Math.random()), this;
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y;
    }
  }
  class ke {
    constructor(e, t, r, n, i, o, s, a, l) {
      (ke.prototype.isMatrix3 = !0),
        (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
        void 0 !== e && this.set(e, t, r, n, i, o, s, a, l);
    }
    set(e, t, r, n, i, o, s, a, l) {
      const c = this.elements;
      return (
        (c[0] = e),
        (c[1] = n),
        (c[2] = s),
        (c[3] = t),
        (c[4] = i),
        (c[5] = a),
        (c[6] = r),
        (c[7] = o),
        (c[8] = l),
        this
      );
    }
    identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
    }
    copy(e) {
      const t = this.elements,
        r = e.elements;
      return (
        (t[0] = r[0]),
        (t[1] = r[1]),
        (t[2] = r[2]),
        (t[3] = r[3]),
        (t[4] = r[4]),
        (t[5] = r[5]),
        (t[6] = r[6]),
        (t[7] = r[7]),
        (t[8] = r[8]),
        this
      );
    }
    extractBasis(e, t, r) {
      return (
        e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        r.setFromMatrix3Column(this, 2),
        this
      );
    }
    setFromMatrix4(e) {
      const t = e.elements;
      return (
        this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
      );
    }
    multiply(e) {
      return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
      return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
      const r = e.elements,
        n = t.elements,
        i = this.elements,
        o = r[0],
        s = r[3],
        a = r[6],
        l = r[1],
        c = r[4],
        u = r[7],
        h = r[2],
        d = r[5],
        p = r[8],
        f = n[0],
        m = n[3],
        g = n[6],
        _ = n[1],
        v = n[4],
        y = n[7],
        b = n[2],
        x = n[5],
        w = n[8];
      return (
        (i[0] = o * f + s * _ + a * b),
        (i[3] = o * m + s * v + a * x),
        (i[6] = o * g + s * y + a * w),
        (i[1] = l * f + c * _ + u * b),
        (i[4] = l * m + c * v + u * x),
        (i[7] = l * g + c * y + u * w),
        (i[2] = h * f + d * _ + p * b),
        (i[5] = h * m + d * v + p * x),
        (i[8] = h * g + d * y + p * w),
        this
      );
    }
    multiplyScalar(e) {
      const t = this.elements;
      return (
        (t[0] *= e),
        (t[3] *= e),
        (t[6] *= e),
        (t[1] *= e),
        (t[4] *= e),
        (t[7] *= e),
        (t[2] *= e),
        (t[5] *= e),
        (t[8] *= e),
        this
      );
    }
    determinant() {
      const e = this.elements,
        t = e[0],
        r = e[1],
        n = e[2],
        i = e[3],
        o = e[4],
        s = e[5],
        a = e[6],
        l = e[7],
        c = e[8];
      return (
        t * o * c - t * s * l - r * i * c + r * s * a + n * i * l - n * o * a
      );
    }
    invert() {
      const e = this.elements,
        t = e[0],
        r = e[1],
        n = e[2],
        i = e[3],
        o = e[4],
        s = e[5],
        a = e[6],
        l = e[7],
        c = e[8],
        u = c * o - s * l,
        h = s * a - c * i,
        d = l * i - o * a,
        p = t * u + r * h + n * d;
      if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const f = 1 / p;
      return (
        (e[0] = u * f),
        (e[1] = (n * l - c * r) * f),
        (e[2] = (s * r - n * o) * f),
        (e[3] = h * f),
        (e[4] = (c * t - n * a) * f),
        (e[5] = (n * i - s * t) * f),
        (e[6] = d * f),
        (e[7] = (r * a - l * t) * f),
        (e[8] = (o * t - r * i) * f),
        this
      );
    }
    transpose() {
      let e;
      const t = this.elements;
      return (
        (e = t[1]),
        (t[1] = t[3]),
        (t[3] = e),
        (e = t[2]),
        (t[2] = t[6]),
        (t[6] = e),
        (e = t[5]),
        (t[5] = t[7]),
        (t[7] = e),
        this
      );
    }
    getNormalMatrix(e) {
      return this.setFromMatrix4(e).invert().transpose();
    }
    transposeIntoArray(e) {
      const t = this.elements;
      return (
        (e[0] = t[0]),
        (e[1] = t[3]),
        (e[2] = t[6]),
        (e[3] = t[1]),
        (e[4] = t[4]),
        (e[5] = t[7]),
        (e[6] = t[2]),
        (e[7] = t[5]),
        (e[8] = t[8]),
        this
      );
    }
    setUvTransform(e, t, r, n, i, o, s) {
      const a = Math.cos(i),
        l = Math.sin(i);
      return (
        this.set(
          r * a,
          r * l,
          -r * (a * o + l * s) + o + e,
          -n * l,
          n * a,
          -n * (-l * o + a * s) + s + t,
          0,
          0,
          1
        ),
        this
      );
    }
    scale(e, t) {
      return this.premultiply(Be.makeScale(e, t)), this;
    }
    rotate(e) {
      return this.premultiply(Be.makeRotation(-e)), this;
    }
    translate(e, t) {
      return this.premultiply(Be.makeTranslation(e, t)), this;
    }
    makeTranslation(e, t) {
      return (
        e.isVector2
          ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
          : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
      );
    }
    makeRotation(e) {
      const t = Math.cos(e),
        r = Math.sin(e);
      return this.set(t, -r, 0, r, t, 0, 0, 0, 1), this;
    }
    makeScale(e, t) {
      return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
    }
    equals(e) {
      const t = this.elements,
        r = e.elements;
      for (let e = 0; e < 9; e++) if (t[e] !== r[e]) return !1;
      return !0;
    }
    fromArray(e, t = 0) {
      for (let r = 0; r < 9; r++) this.elements[r] = e[r + t];
      return this;
    }
    toArray(e = [], t = 0) {
      const r = this.elements;
      return (
        (e[t] = r[0]),
        (e[t + 1] = r[1]),
        (e[t + 2] = r[2]),
        (e[t + 3] = r[3]),
        (e[t + 4] = r[4]),
        (e[t + 5] = r[5]),
        (e[t + 6] = r[6]),
        (e[t + 7] = r[7]),
        (e[t + 8] = r[8]),
        e
      );
    }
    clone() {
      return new this.constructor().fromArray(this.elements);
    }
  }
  const Be = new ke();
  function Fe(e) {
    for (let t = e.length - 1; t >= 0; --t) if (e[t] >= 65535) return !0;
    return !1;
  }
  function He(e) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", e);
  }
  function ze() {
    const e = He("canvas");
    return (e.style.display = "block"), e;
  }
  Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array;
  const Ve = {};
  function je(e) {
    e in Ve || ((Ve[e] = !0), console.warn(e));
  }
  const We = new ke().set(
      0.8224621,
      0.177538,
      0,
      0.0331941,
      0.9668058,
      0,
      0.0170827,
      0.0723974,
      0.9105199
    ),
    Ge = new ke().set(
      1.2249401,
      -0.2249404,
      0,
      -0.0420569,
      1.0420571,
      0,
      -0.0196376,
      -0.0786361,
      1.0982735
    ),
    Xe = {
      [re]: {
        transfer: oe,
        primaries: ae,
        toReference: (e) => e,
        fromReference: (e) => e,
      },
      [te]: {
        transfer: se,
        primaries: ae,
        toReference: (e) => e.convertSRGBToLinear(),
        fromReference: (e) => e.convertLinearToSRGB(),
      },
      [ie]: {
        transfer: oe,
        primaries: le,
        toReference: (e) => e.applyMatrix3(Ge),
        fromReference: (e) => e.applyMatrix3(We),
      },
      [ne]: {
        transfer: se,
        primaries: le,
        toReference: (e) => e.convertSRGBToLinear().applyMatrix3(Ge),
        fromReference: (e) => e.applyMatrix3(We).convertLinearToSRGB(),
      },
    },
    qe = new Set([re, ie]),
    Ye = {
      enabled: !0,
      _workingColorSpace: re,
      get workingColorSpace() {
        return this._workingColorSpace;
      },
      set workingColorSpace(e) {
        if (!qe.has(e))
          throw new Error(`Unsupported working color space, "${e}".`);
        this._workingColorSpace = e;
      },
      convert: function (e, t, r) {
        if (!1 === this.enabled || t === r || !t || !r) return e;
        const n = Xe[t].toReference;
        return (0, Xe[r].fromReference)(n(e));
      },
      fromWorkingColorSpace: function (e, t) {
        return this.convert(e, this._workingColorSpace, t);
      },
      toWorkingColorSpace: function (e, t) {
        return this.convert(e, t, this._workingColorSpace);
      },
      getPrimaries: function (e) {
        return Xe[e].primaries;
      },
      getTransfer: function (e) {
        return e === ee ? oe : Xe[e].transfer;
      },
    };
  function Ke(e) {
    return e < 0.04045
      ? 0.0773993808 * e
      : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
  }
  function $e(e) {
    return e < 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
  }
  let Qe;
  class Je {
    static getDataURL(e) {
      if (/^data:/i.test(e.src)) return e.src;
      if ("undefined" == typeof HTMLCanvasElement) return e.src;
      let t;
      if (e instanceof HTMLCanvasElement) t = e;
      else {
        void 0 === Qe && (Qe = He("canvas")),
          (Qe.width = e.width),
          (Qe.height = e.height);
        const r = Qe.getContext("2d");
        e instanceof ImageData
          ? r.putImageData(e, 0, 0)
          : r.drawImage(e, 0, 0, e.width, e.height),
          (t = Qe);
      }
      return t.width > 2048 || t.height > 2048
        ? (console.warn(
            "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
            e
          ),
          t.toDataURL("image/jpeg", 0.6))
        : t.toDataURL("image/png");
    }
    static sRGBToLinear(e) {
      if (
        ("undefined" != typeof HTMLImageElement &&
          e instanceof HTMLImageElement) ||
        ("undefined" != typeof HTMLCanvasElement &&
          e instanceof HTMLCanvasElement) ||
        ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
      ) {
        const t = He("canvas");
        (t.width = e.width), (t.height = e.height);
        const r = t.getContext("2d");
        r.drawImage(e, 0, 0, e.width, e.height);
        const n = r.getImageData(0, 0, e.width, e.height),
          i = n.data;
        for (let e = 0; e < i.length; e++) i[e] = 255 * Ke(i[e] / 255);
        return r.putImageData(n, 0, 0), t;
      }
      if (e.data) {
        const t = e.data.slice(0);
        for (let e = 0; e < t.length; e++)
          t instanceof Uint8Array || t instanceof Uint8ClampedArray
            ? (t[e] = Math.floor(255 * Ke(t[e] / 255)))
            : (t[e] = Ke(t[e]));
        return { data: t, width: e.width, height: e.height };
      }
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
    }
  }
  let Ze = 0;
  class et {
    constructor(e = null) {
      (this.isSource = !0),
        Object.defineProperty(this, "id", { value: Ze++ }),
        (this.uuid = Ae()),
        (this.data = e),
        (this.version = 0);
    }
    set needsUpdate(e) {
      !0 === e && this.version++;
    }
    toJSON(e) {
      const t = void 0 === e || "string" == typeof e;
      if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
      const r = { uuid: this.uuid, url: "" },
        n = this.data;
      if (null !== n) {
        let e;
        if (Array.isArray(n)) {
          e = [];
          for (let t = 0, r = n.length; t < r; t++)
            n[t].isDataTexture ? e.push(tt(n[t].image)) : e.push(tt(n[t]));
        } else e = tt(n);
        r.url = e;
      }
      return t || (e.images[this.uuid] = r), r;
    }
  }
  function tt(e) {
    return ("undefined" != typeof HTMLImageElement &&
      e instanceof HTMLImageElement) ||
      ("undefined" != typeof HTMLCanvasElement &&
        e instanceof HTMLCanvasElement) ||
      ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
      ? Je.getDataURL(e)
      : e.data
      ? {
          data: Array.from(e.data),
          width: e.width,
          height: e.height,
          type: e.data.constructor.name,
        }
      : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
  }
  let rt = 0;
  class nt extends Se {
    constructor(
      e = nt.DEFAULT_IMAGE,
      t = nt.DEFAULT_MAPPING,
      r = 1001,
      n = 1001,
      i = 1006,
      o = 1008,
      s = 1023,
      a = 1009,
      l = nt.DEFAULT_ANISOTROPY,
      c = ""
    ) {
      super(),
        (this.isTexture = !0),
        Object.defineProperty(this, "id", { value: rt++ }),
        (this.uuid = Ae()),
        (this.name = ""),
        (this.source = new et(e)),
        (this.mipmaps = []),
        (this.mapping = t),
        (this.channel = 0),
        (this.wrapS = r),
        (this.wrapT = n),
        (this.magFilter = i),
        (this.minFilter = o),
        (this.anisotropy = l),
        (this.format = s),
        (this.internalFormat = null),
        (this.type = a),
        (this.offset = new De(0, 0)),
        (this.repeat = new De(1, 1)),
        (this.center = new De(0, 0)),
        (this.rotation = 0),
        (this.matrixAutoUpdate = !0),
        (this.matrix = new ke()),
        (this.generateMipmaps = !0),
        (this.premultiplyAlpha = !1),
        (this.flipY = !0),
        (this.unpackAlignment = 4),
        "string" == typeof c
          ? (this.colorSpace = c)
          : (je(
              "THREE.Texture: Property .encoding has been replaced by .colorSpace."
            ),
            (this.colorSpace = c === Z ? te : ee)),
        (this.userData = {}),
        (this.version = 0),
        (this.onUpdate = null),
        (this.isRenderTargetTexture = !1),
        (this.needsPMREMUpdate = !1);
    }
    get image() {
      return this.source.data;
    }
    set image(e = null) {
      this.source.data = e;
    }
    updateMatrix() {
      this.matrix.setUvTransform(
        this.offset.x,
        this.offset.y,
        this.repeat.x,
        this.repeat.y,
        this.rotation,
        this.center.x,
        this.center.y
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return (
        (this.name = e.name),
        (this.source = e.source),
        (this.mipmaps = e.mipmaps.slice(0)),
        (this.mapping = e.mapping),
        (this.channel = e.channel),
        (this.wrapS = e.wrapS),
        (this.wrapT = e.wrapT),
        (this.magFilter = e.magFilter),
        (this.minFilter = e.minFilter),
        (this.anisotropy = e.anisotropy),
        (this.format = e.format),
        (this.internalFormat = e.internalFormat),
        (this.type = e.type),
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        (this.rotation = e.rotation),
        (this.matrixAutoUpdate = e.matrixAutoUpdate),
        this.matrix.copy(e.matrix),
        (this.generateMipmaps = e.generateMipmaps),
        (this.premultiplyAlpha = e.premultiplyAlpha),
        (this.flipY = e.flipY),
        (this.unpackAlignment = e.unpackAlignment),
        (this.colorSpace = e.colorSpace),
        (this.userData = JSON.parse(JSON.stringify(e.userData))),
        (this.needsUpdate = !0),
        this
      );
    }
    toJSON(e) {
      const t = void 0 === e || "string" == typeof e;
      if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
      const r = {
        metadata: {
          version: 4.6,
          type: "Texture",
          generator: "Texture.toJSON",
        },
        uuid: this.uuid,
        name: this.name,
        image: this.source.toJSON(e).uuid,
        mapping: this.mapping,
        channel: this.channel,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        internalFormat: this.internalFormat,
        type: this.type,
        colorSpace: this.colorSpace,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        generateMipmaps: this.generateMipmaps,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment,
      };
      return (
        Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        t || (e.textures[this.uuid] = r),
        r
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    transformUv(e) {
      if (300 !== this.mapping) return e;
      if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
        switch (this.wrapS) {
          case A:
            e.x = e.x - Math.floor(e.x);
            break;
          case R:
            e.x = e.x < 0 ? 0 : 1;
            break;
          case P:
            1 === Math.abs(Math.floor(e.x) % 2)
              ? (e.x = Math.ceil(e.x) - e.x)
              : (e.x = e.x - Math.floor(e.x));
        }
      if (e.y < 0 || e.y > 1)
        switch (this.wrapT) {
          case A:
            e.y = e.y - Math.floor(e.y);
            break;
          case R:
            e.y = e.y < 0 ? 0 : 1;
            break;
          case P:
            1 === Math.abs(Math.floor(e.y) % 2)
              ? (e.y = Math.ceil(e.y) - e.y)
              : (e.y = e.y - Math.floor(e.y));
        }
      return this.flipY && (e.y = 1 - e.y), e;
    }
    set needsUpdate(e) {
      !0 === e && (this.version++, (this.source.needsUpdate = !0));
    }
    get encoding() {
      return (
        je(
          "THREE.Texture: Property .encoding has been replaced by .colorSpace."
        ),
        this.colorSpace === te ? Z : 3e3
      );
    }
    set encoding(e) {
      je("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
        (this.colorSpace = e === Z ? te : ee);
    }
  }
  (nt.DEFAULT_IMAGE = null),
    (nt.DEFAULT_MAPPING = 300),
    (nt.DEFAULT_ANISOTROPY = 1);
  class it {
    constructor(e = 0, t = 0, r = 0, n = 1) {
      (it.prototype.isVector4 = !0),
        (this.x = e),
        (this.y = t),
        (this.z = r),
        (this.w = n);
    }
    get width() {
      return this.z;
    }
    set width(e) {
      this.z = e;
    }
    get height() {
      return this.w;
    }
    set height(e) {
      this.w = e;
    }
    set(e, t, r, n) {
      return (this.x = e), (this.y = t), (this.z = r), (this.w = n), this;
    }
    setScalar(e) {
      return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
    }
    setX(e) {
      return (this.x = e), this;
    }
    setY(e) {
      return (this.y = e), this;
    }
    setZ(e) {
      return (this.z = e), this;
    }
    setW(e) {
      return (this.w = e), this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        case 2:
          this.z = t;
          break;
        case 3:
          this.w = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    }
    copy(e) {
      return (
        (this.x = e.x),
        (this.y = e.y),
        (this.z = e.z),
        (this.w = void 0 !== e.w ? e.w : 1),
        this
      );
    }
    add(e) {
      return (
        (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
      );
    }
    addScalar(e) {
      return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
    }
    addVectors(e, t) {
      return (
        (this.x = e.x + t.x),
        (this.y = e.y + t.y),
        (this.z = e.z + t.z),
        (this.w = e.w + t.w),
        this
      );
    }
    addScaledVector(e, t) {
      return (
        (this.x += e.x * t),
        (this.y += e.y * t),
        (this.z += e.z * t),
        (this.w += e.w * t),
        this
      );
    }
    sub(e) {
      return (
        (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
      );
    }
    subScalar(e) {
      return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
    }
    subVectors(e, t) {
      return (
        (this.x = e.x - t.x),
        (this.y = e.y - t.y),
        (this.z = e.z - t.z),
        (this.w = e.w - t.w),
        this
      );
    }
    multiply(e) {
      return (
        (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
      );
    }
    multiplyScalar(e) {
      return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
    }
    applyMatrix4(e) {
      const t = this.x,
        r = this.y,
        n = this.z,
        i = this.w,
        o = e.elements;
      return (
        (this.x = o[0] * t + o[4] * r + o[8] * n + o[12] * i),
        (this.y = o[1] * t + o[5] * r + o[9] * n + o[13] * i),
        (this.z = o[2] * t + o[6] * r + o[10] * n + o[14] * i),
        (this.w = o[3] * t + o[7] * r + o[11] * n + o[15] * i),
        this
      );
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    setAxisAngleFromQuaternion(e) {
      this.w = 2 * Math.acos(e.w);
      const t = Math.sqrt(1 - e.w * e.w);
      return (
        t < 1e-4
          ? ((this.x = 1), (this.y = 0), (this.z = 0))
          : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
        this
      );
    }
    setAxisAngleFromRotationMatrix(e) {
      let t, r, n, i;
      const o = 0.01,
        s = 0.1,
        a = e.elements,
        l = a[0],
        c = a[4],
        u = a[8],
        h = a[1],
        d = a[5],
        p = a[9],
        f = a[2],
        m = a[6],
        g = a[10];
      if (Math.abs(c - h) < o && Math.abs(u - f) < o && Math.abs(p - m) < o) {
        if (
          Math.abs(c + h) < s &&
          Math.abs(u + f) < s &&
          Math.abs(p + m) < s &&
          Math.abs(l + d + g - 3) < s
        )
          return this.set(1, 0, 0, 0), this;
        t = Math.PI;
        const e = (l + 1) / 2,
          a = (d + 1) / 2,
          _ = (g + 1) / 2,
          v = (c + h) / 4,
          y = (u + f) / 4,
          b = (p + m) / 4;
        return (
          e > a && e > _
            ? e < o
              ? ((r = 0), (n = 0.707106781), (i = 0.707106781))
              : ((r = Math.sqrt(e)), (n = v / r), (i = y / r))
            : a > _
            ? a < o
              ? ((r = 0.707106781), (n = 0), (i = 0.707106781))
              : ((n = Math.sqrt(a)), (r = v / n), (i = b / n))
            : _ < o
            ? ((r = 0.707106781), (n = 0.707106781), (i = 0))
            : ((i = Math.sqrt(_)), (r = y / i), (n = b / i)),
          this.set(r, n, i, t),
          this
        );
      }
      let _ = Math.sqrt(
        (m - p) * (m - p) + (u - f) * (u - f) + (h - c) * (h - c)
      );
      return (
        Math.abs(_) < 0.001 && (_ = 1),
        (this.x = (m - p) / _),
        (this.y = (u - f) / _),
        (this.z = (h - c) / _),
        (this.w = Math.acos((l + d + g - 1) / 2)),
        this
      );
    }
    min(e) {
      return (
        (this.x = Math.min(this.x, e.x)),
        (this.y = Math.min(this.y, e.y)),
        (this.z = Math.min(this.z, e.z)),
        (this.w = Math.min(this.w, e.w)),
        this
      );
    }
    max(e) {
      return (
        (this.x = Math.max(this.x, e.x)),
        (this.y = Math.max(this.y, e.y)),
        (this.z = Math.max(this.z, e.z)),
        (this.w = Math.max(this.w, e.w)),
        this
      );
    }
    clamp(e, t) {
      return (
        (this.x = Math.max(e.x, Math.min(t.x, this.x))),
        (this.y = Math.max(e.y, Math.min(t.y, this.y))),
        (this.z = Math.max(e.z, Math.min(t.z, this.z))),
        (this.w = Math.max(e.w, Math.min(t.w, this.w))),
        this
      );
    }
    clampScalar(e, t) {
      return (
        (this.x = Math.max(e, Math.min(t, this.x))),
        (this.y = Math.max(e, Math.min(t, this.y))),
        (this.z = Math.max(e, Math.min(t, this.z))),
        (this.w = Math.max(e, Math.min(t, this.w))),
        this
      );
    }
    clampLength(e, t) {
      const r = this.length();
      return this.divideScalar(r || 1).multiplyScalar(
        Math.max(e, Math.min(t, r))
      );
    }
    floor() {
      return (
        (this.x = Math.floor(this.x)),
        (this.y = Math.floor(this.y)),
        (this.z = Math.floor(this.z)),
        (this.w = Math.floor(this.w)),
        this
      );
    }
    ceil() {
      return (
        (this.x = Math.ceil(this.x)),
        (this.y = Math.ceil(this.y)),
        (this.z = Math.ceil(this.z)),
        (this.w = Math.ceil(this.w)),
        this
      );
    }
    round() {
      return (
        (this.x = Math.round(this.x)),
        (this.y = Math.round(this.y)),
        (this.z = Math.round(this.z)),
        (this.w = Math.round(this.w)),
        this
      );
    }
    roundToZero() {
      return (
        (this.x = Math.trunc(this.x)),
        (this.y = Math.trunc(this.y)),
        (this.z = Math.trunc(this.z)),
        (this.w = Math.trunc(this.w)),
        this
      );
    }
    negate() {
      return (
        (this.x = -this.x),
        (this.y = -this.y),
        (this.z = -this.z),
        (this.w = -this.w),
        this
      );
    }
    dot(e) {
      return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
    }
    lengthSq() {
      return (
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    }
    length() {
      return Math.sqrt(
        this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
      );
    }
    manhattanLength() {
      return (
        Math.abs(this.x) +
        Math.abs(this.y) +
        Math.abs(this.z) +
        Math.abs(this.w)
      );
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return (
        (this.x += (e.x - this.x) * t),
        (this.y += (e.y - this.y) * t),
        (this.z += (e.z - this.z) * t),
        (this.w += (e.w - this.w) * t),
        this
      );
    }
    lerpVectors(e, t, r) {
      return (
        (this.x = e.x + (t.x - e.x) * r),
        (this.y = e.y + (t.y - e.y) * r),
        (this.z = e.z + (t.z - e.z) * r),
        (this.w = e.w + (t.w - e.w) * r),
        this
      );
    }
    equals(e) {
      return (
        e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
      );
    }
    fromArray(e, t = 0) {
      return (
        (this.x = e[t]),
        (this.y = e[t + 1]),
        (this.z = e[t + 2]),
        (this.w = e[t + 3]),
        this
      );
    }
    toArray(e = [], t = 0) {
      return (
        (e[t] = this.x),
        (e[t + 1] = this.y),
        (e[t + 2] = this.z),
        (e[t + 3] = this.w),
        e
      );
    }
    fromBufferAttribute(e, t) {
      return (
        (this.x = e.getX(t)),
        (this.y = e.getY(t)),
        (this.z = e.getZ(t)),
        (this.w = e.getW(t)),
        this
      );
    }
    random() {
      return (
        (this.x = Math.random()),
        (this.y = Math.random()),
        (this.z = Math.random()),
        (this.w = Math.random()),
        this
      );
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z, yield this.w;
    }
  }
  class ot extends Se {
    constructor(e = 1, t = 1, r = {}) {
      super(),
        (this.isRenderTarget = !0),
        (this.width = e),
        (this.height = t),
        (this.depth = 1),
        (this.scissor = new it(0, 0, e, t)),
        (this.scissorTest = !1),
        (this.viewport = new it(0, 0, e, t));
      const n = { width: e, height: t, depth: 1 };
      void 0 !== r.encoding &&
        (je(
          "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
        ),
        (r.colorSpace = r.encoding === Z ? te : ee)),
        (r = Object.assign(
          {
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: O,
            depthBuffer: !0,
            stencilBuffer: !1,
            depthTexture: null,
            samples: 0,
          },
          r
        )),
        (this.texture = new nt(
          n,
          r.mapping,
          r.wrapS,
          r.wrapT,
          r.magFilter,
          r.minFilter,
          r.format,
          r.type,
          r.anisotropy,
          r.colorSpace
        )),
        (this.texture.isRenderTargetTexture = !0),
        (this.texture.flipY = !1),
        (this.texture.generateMipmaps = r.generateMipmaps),
        (this.texture.internalFormat = r.internalFormat),
        (this.depthBuffer = r.depthBuffer),
        (this.stencilBuffer = r.stencilBuffer),
        (this.depthTexture = r.depthTexture),
        (this.samples = r.samples);
    }
    setSize(e, t, r = 1) {
      (this.width === e && this.height === t && this.depth === r) ||
        ((this.width = e),
        (this.height = t),
        (this.depth = r),
        (this.texture.image.width = e),
        (this.texture.image.height = t),
        (this.texture.image.depth = r),
        this.dispose()),
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      (this.width = e.width),
        (this.height = e.height),
        (this.depth = e.depth),
        this.scissor.copy(e.scissor),
        (this.scissorTest = e.scissorTest),
        this.viewport.copy(e.viewport),
        (this.texture = e.texture.clone()),
        (this.texture.isRenderTargetTexture = !0);
      const t = Object.assign({}, e.texture.image);
      return (
        (this.texture.source = new et(t)),
        (this.depthBuffer = e.depthBuffer),
        (this.stencilBuffer = e.stencilBuffer),
        null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()),
        (this.samples = e.samples),
        this
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  class st extends ot {
    constructor(e = 1, t = 1, r = {}) {
      super(e, t, r), (this.isWebGLRenderTarget = !0);
    }
  }
  class at extends nt {
    constructor(e = null, t = 1, r = 1, n = 1) {
      super(null),
        (this.isDataArrayTexture = !0),
        (this.image = { data: e, width: t, height: r, depth: n }),
        (this.magFilter = C),
        (this.minFilter = C),
        (this.wrapR = R),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
  }
  class lt extends nt {
    constructor(e = null, t = 1, r = 1, n = 1) {
      super(null),
        (this.isData3DTexture = !0),
        (this.image = { data: e, width: t, height: r, depth: n }),
        (this.magFilter = C),
        (this.minFilter = C),
        (this.wrapR = R),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
  }
  class ct {
    constructor(e = 0, t = 0, r = 0, n = 1) {
      (this.isQuaternion = !0),
        (this._x = e),
        (this._y = t),
        (this._z = r),
        (this._w = n);
    }
    static slerpFlat(e, t, r, n, i, o, s) {
      let a = r[n + 0],
        l = r[n + 1],
        c = r[n + 2],
        u = r[n + 3];
      const h = i[o + 0],
        d = i[o + 1],
        p = i[o + 2],
        f = i[o + 3];
      if (0 === s)
        return (
          (e[t + 0] = a), (e[t + 1] = l), (e[t + 2] = c), void (e[t + 3] = u)
        );
      if (1 === s)
        return (
          (e[t + 0] = h), (e[t + 1] = d), (e[t + 2] = p), void (e[t + 3] = f)
        );
      if (u !== f || a !== h || l !== d || c !== p) {
        let e = 1 - s;
        const t = a * h + l * d + c * p + u * f,
          r = t >= 0 ? 1 : -1,
          n = 1 - t * t;
        if (n > Number.EPSILON) {
          const i = Math.sqrt(n),
            o = Math.atan2(i, t * r);
          (e = Math.sin(e * o) / i), (s = Math.sin(s * o) / i);
        }
        const i = s * r;
        if (
          ((a = a * e + h * i),
          (l = l * e + d * i),
          (c = c * e + p * i),
          (u = u * e + f * i),
          e === 1 - s)
        ) {
          const e = 1 / Math.sqrt(a * a + l * l + c * c + u * u);
          (a *= e), (l *= e), (c *= e), (u *= e);
        }
      }
      (e[t] = a), (e[t + 1] = l), (e[t + 2] = c), (e[t + 3] = u);
    }
    static multiplyQuaternionsFlat(e, t, r, n, i, o) {
      const s = r[n],
        a = r[n + 1],
        l = r[n + 2],
        c = r[n + 3],
        u = i[o],
        h = i[o + 1],
        d = i[o + 2],
        p = i[o + 3];
      return (
        (e[t] = s * p + c * u + a * d - l * h),
        (e[t + 1] = a * p + c * h + l * u - s * d),
        (e[t + 2] = l * p + c * d + s * h - a * u),
        (e[t + 3] = c * p - s * u - a * h - l * d),
        e
      );
    }
    get x() {
      return this._x;
    }
    set x(e) {
      (this._x = e), this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e) {
      (this._y = e), this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e) {
      (this._z = e), this._onChangeCallback();
    }
    get w() {
      return this._w;
    }
    set w(e) {
      (this._w = e), this._onChangeCallback();
    }
    set(e, t, r, n) {
      return (
        (this._x = e),
        (this._y = t),
        (this._z = r),
        (this._w = n),
        this._onChangeCallback(),
        this
      );
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    }
    copy(e) {
      return (
        (this._x = e.x),
        (this._y = e.y),
        (this._z = e.z),
        (this._w = e.w),
        this._onChangeCallback(),
        this
      );
    }
    setFromEuler(e, t = !0) {
      const r = e._x,
        n = e._y,
        i = e._z,
        o = e._order,
        s = Math.cos,
        a = Math.sin,
        l = s(r / 2),
        c = s(n / 2),
        u = s(i / 2),
        h = a(r / 2),
        d = a(n / 2),
        p = a(i / 2);
      switch (o) {
        case "XYZ":
          (this._x = h * c * u + l * d * p),
            (this._y = l * d * u - h * c * p),
            (this._z = l * c * p + h * d * u),
            (this._w = l * c * u - h * d * p);
          break;
        case "YXZ":
          (this._x = h * c * u + l * d * p),
            (this._y = l * d * u - h * c * p),
            (this._z = l * c * p - h * d * u),
            (this._w = l * c * u + h * d * p);
          break;
        case "ZXY":
          (this._x = h * c * u - l * d * p),
            (this._y = l * d * u + h * c * p),
            (this._z = l * c * p + h * d * u),
            (this._w = l * c * u - h * d * p);
          break;
        case "ZYX":
          (this._x = h * c * u - l * d * p),
            (this._y = l * d * u + h * c * p),
            (this._z = l * c * p - h * d * u),
            (this._w = l * c * u + h * d * p);
          break;
        case "YZX":
          (this._x = h * c * u + l * d * p),
            (this._y = l * d * u + h * c * p),
            (this._z = l * c * p - h * d * u),
            (this._w = l * c * u - h * d * p);
          break;
        case "XZY":
          (this._x = h * c * u - l * d * p),
            (this._y = l * d * u - h * c * p),
            (this._z = l * c * p + h * d * u),
            (this._w = l * c * u + h * d * p);
          break;
        default:
          console.warn(
            "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
              o
          );
      }
      return !0 === t && this._onChangeCallback(), this;
    }
    setFromAxisAngle(e, t) {
      const r = t / 2,
        n = Math.sin(r);
      return (
        (this._x = e.x * n),
        (this._y = e.y * n),
        (this._z = e.z * n),
        (this._w = Math.cos(r)),
        this._onChangeCallback(),
        this
      );
    }
    setFromRotationMatrix(e) {
      const t = e.elements,
        r = t[0],
        n = t[4],
        i = t[8],
        o = t[1],
        s = t[5],
        a = t[9],
        l = t[2],
        c = t[6],
        u = t[10],
        h = r + s + u;
      if (h > 0) {
        const e = 0.5 / Math.sqrt(h + 1);
        (this._w = 0.25 / e),
          (this._x = (c - a) * e),
          (this._y = (i - l) * e),
          (this._z = (o - n) * e);
      } else if (r > s && r > u) {
        const e = 2 * Math.sqrt(1 + r - s - u);
        (this._w = (c - a) / e),
          (this._x = 0.25 * e),
          (this._y = (n + o) / e),
          (this._z = (i + l) / e);
      } else if (s > u) {
        const e = 2 * Math.sqrt(1 + s - r - u);
        (this._w = (i - l) / e),
          (this._x = (n + o) / e),
          (this._y = 0.25 * e),
          (this._z = (a + c) / e);
      } else {
        const e = 2 * Math.sqrt(1 + u - r - s);
        (this._w = (o - n) / e),
          (this._x = (i + l) / e),
          (this._y = (a + c) / e),
          (this._z = 0.25 * e);
      }
      return this._onChangeCallback(), this;
    }
    setFromUnitVectors(e, t) {
      let r = e.dot(t) + 1;
      return (
        r < Number.EPSILON
          ? ((r = 0),
            Math.abs(e.x) > Math.abs(e.z)
              ? ((this._x = -e.y),
                (this._y = e.x),
                (this._z = 0),
                (this._w = r))
              : ((this._x = 0),
                (this._y = -e.z),
                (this._z = e.y),
                (this._w = r)))
          : ((this._x = e.y * t.z - e.z * t.y),
            (this._y = e.z * t.x - e.x * t.z),
            (this._z = e.x * t.y - e.y * t.x),
            (this._w = r)),
        this.normalize()
      );
    }
    angleTo(e) {
      return 2 * Math.acos(Math.abs(Re(this.dot(e), -1, 1)));
    }
    rotateTowards(e, t) {
      const r = this.angleTo(e);
      if (0 === r) return this;
      const n = Math.min(1, t / r);
      return this.slerp(e, n), this;
    }
    identity() {
      return this.set(0, 0, 0, 1);
    }
    invert() {
      return this.conjugate();
    }
    conjugate() {
      return (
        (this._x *= -1),
        (this._y *= -1),
        (this._z *= -1),
        this._onChangeCallback(),
        this
      );
    }
    dot(e) {
      return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
    }
    lengthSq() {
      return (
        this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
      );
    }
    length() {
      return Math.sqrt(
        this._x * this._x +
          this._y * this._y +
          this._z * this._z +
          this._w * this._w
      );
    }
    normalize() {
      let e = this.length();
      return (
        0 === e
          ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
          : ((e = 1 / e),
            (this._x = this._x * e),
            (this._y = this._y * e),
            (this._z = this._z * e),
            (this._w = this._w * e)),
        this._onChangeCallback(),
        this
      );
    }
    multiply(e) {
      return this.multiplyQuaternions(this, e);
    }
    premultiply(e) {
      return this.multiplyQuaternions(e, this);
    }
    multiplyQuaternions(e, t) {
      const r = e._x,
        n = e._y,
        i = e._z,
        o = e._w,
        s = t._x,
        a = t._y,
        l = t._z,
        c = t._w;
      return (
        (this._x = r * c + o * s + n * l - i * a),
        (this._y = n * c + o * a + i * s - r * l),
        (this._z = i * c + o * l + r * a - n * s),
        (this._w = o * c - r * s - n * a - i * l),
        this._onChangeCallback(),
        this
      );
    }
    slerp(e, t) {
      if (0 === t) return this;
      if (1 === t) return this.copy(e);
      const r = this._x,
        n = this._y,
        i = this._z,
        o = this._w;
      let s = o * e._w + r * e._x + n * e._y + i * e._z;
      if (
        (s < 0
          ? ((this._w = -e._w),
            (this._x = -e._x),
            (this._y = -e._y),
            (this._z = -e._z),
            (s = -s))
          : this.copy(e),
        s >= 1)
      )
        return (this._w = o), (this._x = r), (this._y = n), (this._z = i), this;
      const a = 1 - s * s;
      if (a <= Number.EPSILON) {
        const e = 1 - t;
        return (
          (this._w = e * o + t * this._w),
          (this._x = e * r + t * this._x),
          (this._y = e * n + t * this._y),
          (this._z = e * i + t * this._z),
          this.normalize(),
          this
        );
      }
      const l = Math.sqrt(a),
        c = Math.atan2(l, s),
        u = Math.sin((1 - t) * c) / l,
        h = Math.sin(t * c) / l;
      return (
        (this._w = o * u + this._w * h),
        (this._x = r * u + this._x * h),
        (this._y = n * u + this._y * h),
        (this._z = i * u + this._z * h),
        this._onChangeCallback(),
        this
      );
    }
    slerpQuaternions(e, t, r) {
      return this.copy(e).slerp(t, r);
    }
    random() {
      const e = Math.random(),
        t = Math.sqrt(1 - e),
        r = Math.sqrt(e),
        n = 2 * Math.PI * Math.random(),
        i = 2 * Math.PI * Math.random();
      return this.set(
        t * Math.cos(n),
        r * Math.sin(i),
        r * Math.cos(i),
        t * Math.sin(n)
      );
    }
    equals(e) {
      return (
        e._x === this._x &&
        e._y === this._y &&
        e._z === this._z &&
        e._w === this._w
      );
    }
    fromArray(e, t = 0) {
      return (
        (this._x = e[t]),
        (this._y = e[t + 1]),
        (this._z = e[t + 2]),
        (this._w = e[t + 3]),
        this._onChangeCallback(),
        this
      );
    }
    toArray(e = [], t = 0) {
      return (
        (e[t] = this._x),
        (e[t + 1] = this._y),
        (e[t + 2] = this._z),
        (e[t + 3] = this._w),
        e
      );
    }
    fromBufferAttribute(e, t) {
      return (
        (this._x = e.getX(t)),
        (this._y = e.getY(t)),
        (this._z = e.getZ(t)),
        (this._w = e.getW(t)),
        this._onChangeCallback(),
        this
      );
    }
    toJSON() {
      return this.toArray();
    }
    _onChange(e) {
      return (this._onChangeCallback = e), this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._w;
    }
  }
  class ut {
    constructor(e = 0, t = 0, r = 0) {
      (ut.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = r);
    }
    set(e, t, r) {
      return (
        void 0 === r && (r = this.z),
        (this.x = e),
        (this.y = t),
        (this.z = r),
        this
      );
    }
    setScalar(e) {
      return (this.x = e), (this.y = e), (this.z = e), this;
    }
    setX(e) {
      return (this.x = e), this;
    }
    setY(e) {
      return (this.y = e), this;
    }
    setZ(e) {
      return (this.z = e), this;
    }
    setComponent(e, t) {
      switch (e) {
        case 0:
          this.x = t;
          break;
        case 1:
          this.y = t;
          break;
        case 2:
          this.z = t;
          break;
        default:
          throw new Error("index is out of range: " + e);
      }
      return this;
    }
    getComponent(e) {
      switch (e) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + e);
      }
    }
    clone() {
      return new this.constructor(this.x, this.y, this.z);
    }
    copy(e) {
      return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
    }
    add(e) {
      return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
    }
    addScalar(e) {
      return (this.x += e), (this.y += e), (this.z += e), this;
    }
    addVectors(e, t) {
      return (
        (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
      );
    }
    addScaledVector(e, t) {
      return (
        (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
      );
    }
    sub(e) {
      return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
    }
    subScalar(e) {
      return (this.x -= e), (this.y -= e), (this.z -= e), this;
    }
    subVectors(e, t) {
      return (
        (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
      );
    }
    multiply(e) {
      return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
    }
    multiplyScalar(e) {
      return (this.x *= e), (this.y *= e), (this.z *= e), this;
    }
    multiplyVectors(e, t) {
      return (
        (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
      );
    }
    applyEuler(e) {
      return this.applyQuaternion(dt.setFromEuler(e));
    }
    applyAxisAngle(e, t) {
      return this.applyQuaternion(dt.setFromAxisAngle(e, t));
    }
    applyMatrix3(e) {
      const t = this.x,
        r = this.y,
        n = this.z,
        i = e.elements;
      return (
        (this.x = i[0] * t + i[3] * r + i[6] * n),
        (this.y = i[1] * t + i[4] * r + i[7] * n),
        (this.z = i[2] * t + i[5] * r + i[8] * n),
        this
      );
    }
    applyNormalMatrix(e) {
      return this.applyMatrix3(e).normalize();
    }
    applyMatrix4(e) {
      const t = this.x,
        r = this.y,
        n = this.z,
        i = e.elements,
        o = 1 / (i[3] * t + i[7] * r + i[11] * n + i[15]);
      return (
        (this.x = (i[0] * t + i[4] * r + i[8] * n + i[12]) * o),
        (this.y = (i[1] * t + i[5] * r + i[9] * n + i[13]) * o),
        (this.z = (i[2] * t + i[6] * r + i[10] * n + i[14]) * o),
        this
      );
    }
    applyQuaternion(e) {
      const t = this.x,
        r = this.y,
        n = this.z,
        i = e.x,
        o = e.y,
        s = e.z,
        a = e.w,
        l = 2 * (o * n - s * r),
        c = 2 * (s * t - i * n),
        u = 2 * (i * r - o * t);
      return (
        (this.x = t + a * l + o * u - s * c),
        (this.y = r + a * c + s * l - i * u),
        (this.z = n + a * u + i * c - o * l),
        this
      );
    }
    project(e) {
      return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
        e.projectionMatrix
      );
    }
    unproject(e) {
      return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
        e.matrixWorld
      );
    }
    transformDirection(e) {
      const t = this.x,
        r = this.y,
        n = this.z,
        i = e.elements;
      return (
        (this.x = i[0] * t + i[4] * r + i[8] * n),
        (this.y = i[1] * t + i[5] * r + i[9] * n),
        (this.z = i[2] * t + i[6] * r + i[10] * n),
        this.normalize()
      );
    }
    divide(e) {
      return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
    }
    divideScalar(e) {
      return this.multiplyScalar(1 / e);
    }
    min(e) {
      return (
        (this.x = Math.min(this.x, e.x)),
        (this.y = Math.min(this.y, e.y)),
        (this.z = Math.min(this.z, e.z)),
        this
      );
    }
    max(e) {
      return (
        (this.x = Math.max(this.x, e.x)),
        (this.y = Math.max(this.y, e.y)),
        (this.z = Math.max(this.z, e.z)),
        this
      );
    }
    clamp(e, t) {
      return (
        (this.x = Math.max(e.x, Math.min(t.x, this.x))),
        (this.y = Math.max(e.y, Math.min(t.y, this.y))),
        (this.z = Math.max(e.z, Math.min(t.z, this.z))),
        this
      );
    }
    clampScalar(e, t) {
      return (
        (this.x = Math.max(e, Math.min(t, this.x))),
        (this.y = Math.max(e, Math.min(t, this.y))),
        (this.z = Math.max(e, Math.min(t, this.z))),
        this
      );
    }
    clampLength(e, t) {
      const r = this.length();
      return this.divideScalar(r || 1).multiplyScalar(
        Math.max(e, Math.min(t, r))
      );
    }
    floor() {
      return (
        (this.x = Math.floor(this.x)),
        (this.y = Math.floor(this.y)),
        (this.z = Math.floor(this.z)),
        this
      );
    }
    ceil() {
      return (
        (this.x = Math.ceil(this.x)),
        (this.y = Math.ceil(this.y)),
        (this.z = Math.ceil(this.z)),
        this
      );
    }
    round() {
      return (
        (this.x = Math.round(this.x)),
        (this.y = Math.round(this.y)),
        (this.z = Math.round(this.z)),
        this
      );
    }
    roundToZero() {
      return (
        (this.x = Math.trunc(this.x)),
        (this.y = Math.trunc(this.y)),
        (this.z = Math.trunc(this.z)),
        this
      );
    }
    negate() {
      return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
    }
    dot(e) {
      return this.x * e.x + this.y * e.y + this.z * e.z;
    }
    lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    }
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }
    manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    }
    normalize() {
      return this.divideScalar(this.length() || 1);
    }
    setLength(e) {
      return this.normalize().multiplyScalar(e);
    }
    lerp(e, t) {
      return (
        (this.x += (e.x - this.x) * t),
        (this.y += (e.y - this.y) * t),
        (this.z += (e.z - this.z) * t),
        this
      );
    }
    lerpVectors(e, t, r) {
      return (
        (this.x = e.x + (t.x - e.x) * r),
        (this.y = e.y + (t.y - e.y) * r),
        (this.z = e.z + (t.z - e.z) * r),
        this
      );
    }
    cross(e) {
      return this.crossVectors(this, e);
    }
    crossVectors(e, t) {
      const r = e.x,
        n = e.y,
        i = e.z,
        o = t.x,
        s = t.y,
        a = t.z;
      return (
        (this.x = n * a - i * s),
        (this.y = i * o - r * a),
        (this.z = r * s - n * o),
        this
      );
    }
    projectOnVector(e) {
      const t = e.lengthSq();
      if (0 === t) return this.set(0, 0, 0);
      const r = e.dot(this) / t;
      return this.copy(e).multiplyScalar(r);
    }
    projectOnPlane(e) {
      return ht.copy(this).projectOnVector(e), this.sub(ht);
    }
    reflect(e) {
      return this.sub(ht.copy(e).multiplyScalar(2 * this.dot(e)));
    }
    angleTo(e) {
      const t = Math.sqrt(this.lengthSq() * e.lengthSq());
      if (0 === t) return Math.PI / 2;
      const r = this.dot(e) / t;
      return Math.acos(Re(r, -1, 1));
    }
    distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e));
    }
    distanceToSquared(e) {
      const t = this.x - e.x,
        r = this.y - e.y,
        n = this.z - e.z;
      return t * t + r * r + n * n;
    }
    manhattanDistanceTo(e) {
      return (
        Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
      );
    }
    setFromSpherical(e) {
      return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
    }
    setFromSphericalCoords(e, t, r) {
      const n = Math.sin(t) * e;
      return (
        (this.x = n * Math.sin(r)),
        (this.y = Math.cos(t) * e),
        (this.z = n * Math.cos(r)),
        this
      );
    }
    setFromCylindrical(e) {
      return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
    }
    setFromCylindricalCoords(e, t, r) {
      return (
        (this.x = e * Math.sin(t)),
        (this.y = r),
        (this.z = e * Math.cos(t)),
        this
      );
    }
    setFromMatrixPosition(e) {
      const t = e.elements;
      return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
    }
    setFromMatrixScale(e) {
      const t = this.setFromMatrixColumn(e, 0).length(),
        r = this.setFromMatrixColumn(e, 1).length(),
        n = this.setFromMatrixColumn(e, 2).length();
      return (this.x = t), (this.y = r), (this.z = n), this;
    }
    setFromMatrixColumn(e, t) {
      return this.fromArray(e.elements, 4 * t);
    }
    setFromMatrix3Column(e, t) {
      return this.fromArray(e.elements, 3 * t);
    }
    setFromEuler(e) {
      return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
    }
    setFromColor(e) {
      return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
    }
    equals(e) {
      return e.x === this.x && e.y === this.y && e.z === this.z;
    }
    fromArray(e, t = 0) {
      return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
    }
    toArray(e = [], t = 0) {
      return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
    }
    fromBufferAttribute(e, t) {
      return (
        (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
      );
    }
    random() {
      return (
        (this.x = Math.random()),
        (this.y = Math.random()),
        (this.z = Math.random()),
        this
      );
    }
    randomDirection() {
      const e = 2 * (Math.random() - 0.5),
        t = Math.random() * Math.PI * 2,
        r = Math.sqrt(1 - e ** 2);
      return (
        (this.x = r * Math.cos(t)),
        (this.y = r * Math.sin(t)),
        (this.z = e),
        this
      );
    }
    *[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z;
    }
  }
  const ht = new ut(),
    dt = new ct();
  class pt {
    constructor(
      e = new ut(1 / 0, 1 / 0, 1 / 0),
      t = new ut(-1 / 0, -1 / 0, -1 / 0)
    ) {
      (this.isBox3 = !0), (this.min = e), (this.max = t);
    }
    set(e, t) {
      return this.min.copy(e), this.max.copy(t), this;
    }
    setFromArray(e) {
      this.makeEmpty();
      for (let t = 0, r = e.length; t < r; t += 3)
        this.expandByPoint(mt.fromArray(e, t));
      return this;
    }
    setFromBufferAttribute(e) {
      this.makeEmpty();
      for (let t = 0, r = e.count; t < r; t++)
        this.expandByPoint(mt.fromBufferAttribute(e, t));
      return this;
    }
    setFromPoints(e) {
      this.makeEmpty();
      for (let t = 0, r = e.length; t < r; t++) this.expandByPoint(e[t]);
      return this;
    }
    setFromCenterAndSize(e, t) {
      const r = mt.copy(t).multiplyScalar(0.5);
      return this.min.copy(e).sub(r), this.max.copy(e).add(r), this;
    }
    setFromObject(e, t = !1) {
      return this.makeEmpty(), this.expandByObject(e, t);
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.min.copy(e.min), this.max.copy(e.max), this;
    }
    makeEmpty() {
      return (
        (this.min.x = this.min.y = this.min.z = 1 / 0),
        (this.max.x = this.max.y = this.max.z = -1 / 0),
        this
      );
    }
    isEmpty() {
      return (
        this.max.x < this.min.x ||
        this.max.y < this.min.y ||
        this.max.z < this.min.z
      );
    }
    getCenter(e) {
      return this.isEmpty()
        ? e.set(0, 0, 0)
        : e.addVectors(this.min, this.max).multiplyScalar(0.5);
    }
    getSize(e) {
      return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
    }
    expandByPoint(e) {
      return this.min.min(e), this.max.max(e), this;
    }
    expandByVector(e) {
      return this.min.sub(e), this.max.add(e), this;
    }
    expandByScalar(e) {
      return this.min.addScalar(-e), this.max.addScalar(e), this;
    }
    expandByObject(e, t = !1) {
      e.updateWorldMatrix(!1, !1);
      const r = e.geometry;
      if (void 0 !== r) {
        const n = r.getAttribute("position");
        if (!0 === t && void 0 !== n && !0 !== e.isInstancedMesh)
          for (let t = 0, r = n.count; t < r; t++)
            !0 === e.isMesh
              ? e.getVertexPosition(t, mt)
              : mt.fromBufferAttribute(n, t),
              mt.applyMatrix4(e.matrixWorld),
              this.expandByPoint(mt);
        else
          void 0 !== e.boundingBox
            ? (null === e.boundingBox && e.computeBoundingBox(),
              gt.copy(e.boundingBox))
            : (null === r.boundingBox && r.computeBoundingBox(),
              gt.copy(r.boundingBox)),
            gt.applyMatrix4(e.matrixWorld),
            this.union(gt);
      }
      const n = e.children;
      for (let e = 0, r = n.length; e < r; e++) this.expandByObject(n[e], t);
      return this;
    }
    containsPoint(e) {
      return !(
        e.x < this.min.x ||
        e.x > this.max.x ||
        e.y < this.min.y ||
        e.y > this.max.y ||
        e.z < this.min.z ||
        e.z > this.max.z
      );
    }
    containsBox(e) {
      return (
        this.min.x <= e.min.x &&
        e.max.x <= this.max.x &&
        this.min.y <= e.min.y &&
        e.max.y <= this.max.y &&
        this.min.z <= e.min.z &&
        e.max.z <= this.max.z
      );
    }
    getParameter(e, t) {
      return t.set(
        (e.x - this.min.x) / (this.max.x - this.min.x),
        (e.y - this.min.y) / (this.max.y - this.min.y),
        (e.z - this.min.z) / (this.max.z - this.min.z)
      );
    }
    intersectsBox(e) {
      return !(
        e.max.x < this.min.x ||
        e.min.x > this.max.x ||
        e.max.y < this.min.y ||
        e.min.y > this.max.y ||
        e.max.z < this.min.z ||
        e.min.z > this.max.z
      );
    }
    intersectsSphere(e) {
      return (
        this.clampPoint(e.center, mt),
        mt.distanceToSquared(e.center) <= e.radius * e.radius
      );
    }
    intersectsPlane(e) {
      let t, r;
      return (
        e.normal.x > 0
          ? ((t = e.normal.x * this.min.x), (r = e.normal.x * this.max.x))
          : ((t = e.normal.x * this.max.x), (r = e.normal.x * this.min.x)),
        e.normal.y > 0
          ? ((t += e.normal.y * this.min.y), (r += e.normal.y * this.max.y))
          : ((t += e.normal.y * this.max.y), (r += e.normal.y * this.min.y)),
        e.normal.z > 0
          ? ((t += e.normal.z * this.min.z), (r += e.normal.z * this.max.z))
          : ((t += e.normal.z * this.max.z), (r += e.normal.z * this.min.z)),
        t <= -e.constant && r >= -e.constant
      );
    }
    intersectsTriangle(e) {
      if (this.isEmpty()) return !1;
      this.getCenter(St),
        Et.subVectors(this.max, St),
        _t.subVectors(e.a, St),
        vt.subVectors(e.b, St),
        yt.subVectors(e.c, St),
        bt.subVectors(vt, _t),
        xt.subVectors(yt, vt),
        wt.subVectors(_t, yt);
      let t = [
        0,
        -bt.z,
        bt.y,
        0,
        -xt.z,
        xt.y,
        0,
        -wt.z,
        wt.y,
        bt.z,
        0,
        -bt.x,
        xt.z,
        0,
        -xt.x,
        wt.z,
        0,
        -wt.x,
        -bt.y,
        bt.x,
        0,
        -xt.y,
        xt.x,
        0,
        -wt.y,
        wt.x,
        0,
      ];
      return (
        !!At(t, _t, vt, yt, Et) &&
        ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
        !!At(t, _t, vt, yt, Et) &&
          (Mt.crossVectors(bt, xt),
          (t = [Mt.x, Mt.y, Mt.z]),
          At(t, _t, vt, yt, Et)))
      );
    }
    clampPoint(e, t) {
      return t.copy(e).clamp(this.min, this.max);
    }
    distanceToPoint(e) {
      return this.clampPoint(e, mt).distanceTo(e);
    }
    getBoundingSphere(e) {
      return (
        this.isEmpty()
          ? e.makeEmpty()
          : (this.getCenter(e.center),
            (e.radius = 0.5 * this.getSize(mt).length())),
        e
      );
    }
    intersect(e) {
      return (
        this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
      );
    }
    union(e) {
      return this.min.min(e.min), this.max.max(e.max), this;
    }
    applyMatrix4(e) {
      return (
        this.isEmpty() ||
          (ft[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
          ft[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
          ft[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
          ft[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
          ft[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
          ft[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
          ft[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
          ft[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
          this.setFromPoints(ft)),
        this
      );
    }
    translate(e) {
      return this.min.add(e), this.max.add(e), this;
    }
    equals(e) {
      return e.min.equals(this.min) && e.max.equals(this.max);
    }
  }
  const ft = [
      new ut(),
      new ut(),
      new ut(),
      new ut(),
      new ut(),
      new ut(),
      new ut(),
      new ut(),
    ],
    mt = new ut(),
    gt = new pt(),
    _t = new ut(),
    vt = new ut(),
    yt = new ut(),
    bt = new ut(),
    xt = new ut(),
    wt = new ut(),
    St = new ut(),
    Et = new ut(),
    Mt = new ut(),
    Tt = new ut();
  function At(e, t, r, n, i) {
    for (let o = 0, s = e.length - 3; o <= s; o += 3) {
      Tt.fromArray(e, o);
      const s =
          i.x * Math.abs(Tt.x) + i.y * Math.abs(Tt.y) + i.z * Math.abs(Tt.z),
        a = t.dot(Tt),
        l = r.dot(Tt),
        c = n.dot(Tt);
      if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > s) return !1;
    }
    return !0;
  }
  const Rt = new pt(),
    Pt = new ut(),
    Ct = new ut();
  class It {
    constructor(e = new ut(), t = -1) {
      (this.isSphere = !0), (this.center = e), (this.radius = t);
    }
    set(e, t) {
      return this.center.copy(e), (this.radius = t), this;
    }
    setFromPoints(e, t) {
      const r = this.center;
      void 0 !== t ? r.copy(t) : Rt.setFromPoints(e).getCenter(r);
      let n = 0;
      for (let t = 0, i = e.length; t < i; t++)
        n = Math.max(n, r.distanceToSquared(e[t]));
      return (this.radius = Math.sqrt(n)), this;
    }
    copy(e) {
      return this.center.copy(e.center), (this.radius = e.radius), this;
    }
    isEmpty() {
      return this.radius < 0;
    }
    makeEmpty() {
      return this.center.set(0, 0, 0), (this.radius = -1), this;
    }
    containsPoint(e) {
      return e.distanceToSquared(this.center) <= this.radius * this.radius;
    }
    distanceToPoint(e) {
      return e.distanceTo(this.center) - this.radius;
    }
    intersectsSphere(e) {
      const t = this.radius + e.radius;
      return e.center.distanceToSquared(this.center) <= t * t;
    }
    intersectsBox(e) {
      return e.intersectsSphere(this);
    }
    intersectsPlane(e) {
      return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
    }
    clampPoint(e, t) {
      const r = this.center.distanceToSquared(e);
      return (
        t.copy(e),
        r > this.radius * this.radius &&
          (t.sub(this.center).normalize(),
          t.multiplyScalar(this.radius).add(this.center)),
        t
      );
    }
    getBoundingBox(e) {
      return this.isEmpty()
        ? (e.makeEmpty(), e)
        : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
    }
    applyMatrix4(e) {
      return (
        this.center.applyMatrix4(e),
        (this.radius = this.radius * e.getMaxScaleOnAxis()),
        this
      );
    }
    translate(e) {
      return this.center.add(e), this;
    }
    expandByPoint(e) {
      if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
      Pt.subVectors(e, this.center);
      const t = Pt.lengthSq();
      if (t > this.radius * this.radius) {
        const e = Math.sqrt(t),
          r = 0.5 * (e - this.radius);
        this.center.addScaledVector(Pt, r / e), (this.radius += r);
      }
      return this;
    }
    union(e) {
      return e.isEmpty()
        ? this
        : this.isEmpty()
        ? (this.copy(e), this)
        : (!0 === this.center.equals(e.center)
            ? (this.radius = Math.max(this.radius, e.radius))
            : (Ct.subVectors(e.center, this.center).setLength(e.radius),
              this.expandByPoint(Pt.copy(e.center).add(Ct)),
              this.expandByPoint(Pt.copy(e.center).sub(Ct))),
          this);
    }
    equals(e) {
      return e.center.equals(this.center) && e.radius === this.radius;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const Lt = new ut(),
    Ot = new ut(),
    Nt = new ut(),
    Ut = new ut(),
    Dt = new ut(),
    kt = new ut(),
    Bt = new ut();
  class Ft {
    constructor(e = new ut(), t = new ut(0, 0, -1)) {
      (this.origin = e), (this.direction = t);
    }
    set(e, t) {
      return this.origin.copy(e), this.direction.copy(t), this;
    }
    copy(e) {
      return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
    }
    at(e, t) {
      return t.copy(this.origin).addScaledVector(this.direction, e);
    }
    lookAt(e) {
      return this.direction.copy(e).sub(this.origin).normalize(), this;
    }
    recast(e) {
      return this.origin.copy(this.at(e, Lt)), this;
    }
    closestPointToPoint(e, t) {
      t.subVectors(e, this.origin);
      const r = t.dot(this.direction);
      return r < 0
        ? t.copy(this.origin)
        : t.copy(this.origin).addScaledVector(this.direction, r);
    }
    distanceToPoint(e) {
      return Math.sqrt(this.distanceSqToPoint(e));
    }
    distanceSqToPoint(e) {
      const t = Lt.subVectors(e, this.origin).dot(this.direction);
      return t < 0
        ? this.origin.distanceToSquared(e)
        : (Lt.copy(this.origin).addScaledVector(this.direction, t),
          Lt.distanceToSquared(e));
    }
    distanceSqToSegment(e, t, r, n) {
      Ot.copy(e).add(t).multiplyScalar(0.5),
        Nt.copy(t).sub(e).normalize(),
        Ut.copy(this.origin).sub(Ot);
      const i = 0.5 * e.distanceTo(t),
        o = -this.direction.dot(Nt),
        s = Ut.dot(this.direction),
        a = -Ut.dot(Nt),
        l = Ut.lengthSq(),
        c = Math.abs(1 - o * o);
      let u, h, d, p;
      if (c > 0)
        if (((u = o * a - s), (h = o * s - a), (p = i * c), u >= 0))
          if (h >= -p)
            if (h <= p) {
              const e = 1 / c;
              (u *= e),
                (h *= e),
                (d = u * (u + o * h + 2 * s) + h * (o * u + h + 2 * a) + l);
            } else
              (h = i),
                (u = Math.max(0, -(o * h + s))),
                (d = -u * u + h * (h + 2 * a) + l);
          else
            (h = -i),
              (u = Math.max(0, -(o * h + s))),
              (d = -u * u + h * (h + 2 * a) + l);
        else
          h <= -p
            ? ((u = Math.max(0, -(-o * i + s))),
              (h = u > 0 ? -i : Math.min(Math.max(-i, -a), i)),
              (d = -u * u + h * (h + 2 * a) + l))
            : h <= p
            ? ((u = 0),
              (h = Math.min(Math.max(-i, -a), i)),
              (d = h * (h + 2 * a) + l))
            : ((u = Math.max(0, -(o * i + s))),
              (h = u > 0 ? i : Math.min(Math.max(-i, -a), i)),
              (d = -u * u + h * (h + 2 * a) + l));
      else
        (h = o > 0 ? -i : i),
          (u = Math.max(0, -(o * h + s))),
          (d = -u * u + h * (h + 2 * a) + l);
      return (
        r && r.copy(this.origin).addScaledVector(this.direction, u),
        n && n.copy(Ot).addScaledVector(Nt, h),
        d
      );
    }
    intersectSphere(e, t) {
      Lt.subVectors(e.center, this.origin);
      const r = Lt.dot(this.direction),
        n = Lt.dot(Lt) - r * r,
        i = e.radius * e.radius;
      if (n > i) return null;
      const o = Math.sqrt(i - n),
        s = r - o,
        a = r + o;
      return a < 0 ? null : s < 0 ? this.at(a, t) : this.at(s, t);
    }
    intersectsSphere(e) {
      return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
    }
    distanceToPlane(e) {
      const t = e.normal.dot(this.direction);
      if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
      const r = -(this.origin.dot(e.normal) + e.constant) / t;
      return r >= 0 ? r : null;
    }
    intersectPlane(e, t) {
      const r = this.distanceToPlane(e);
      return null === r ? null : this.at(r, t);
    }
    intersectsPlane(e) {
      const t = e.distanceToPoint(this.origin);
      return 0 === t || e.normal.dot(this.direction) * t < 0;
    }
    intersectBox(e, t) {
      let r, n, i, o, s, a;
      const l = 1 / this.direction.x,
        c = 1 / this.direction.y,
        u = 1 / this.direction.z,
        h = this.origin;
      return (
        l >= 0
          ? ((r = (e.min.x - h.x) * l), (n = (e.max.x - h.x) * l))
          : ((r = (e.max.x - h.x) * l), (n = (e.min.x - h.x) * l)),
        c >= 0
          ? ((i = (e.min.y - h.y) * c), (o = (e.max.y - h.y) * c))
          : ((i = (e.max.y - h.y) * c), (o = (e.min.y - h.y) * c)),
        r > o || i > n
          ? null
          : ((i > r || isNaN(r)) && (r = i),
            (o < n || isNaN(n)) && (n = o),
            u >= 0
              ? ((s = (e.min.z - h.z) * u), (a = (e.max.z - h.z) * u))
              : ((s = (e.max.z - h.z) * u), (a = (e.min.z - h.z) * u)),
            r > a || s > n
              ? null
              : ((s > r || r != r) && (r = s),
                (a < n || n != n) && (n = a),
                n < 0 ? null : this.at(r >= 0 ? r : n, t)))
      );
    }
    intersectsBox(e) {
      return null !== this.intersectBox(e, Lt);
    }
    intersectTriangle(e, t, r, n, i) {
      Dt.subVectors(t, e), kt.subVectors(r, e), Bt.crossVectors(Dt, kt);
      let o,
        s = this.direction.dot(Bt);
      if (s > 0) {
        if (n) return null;
        o = 1;
      } else {
        if (!(s < 0)) return null;
        (o = -1), (s = -s);
      }
      Ut.subVectors(this.origin, e);
      const a = o * this.direction.dot(kt.crossVectors(Ut, kt));
      if (a < 0) return null;
      const l = o * this.direction.dot(Dt.cross(Ut));
      if (l < 0) return null;
      if (a + l > s) return null;
      const c = -o * Ut.dot(Bt);
      return c < 0 ? null : this.at(c / s, i);
    }
    applyMatrix4(e) {
      return (
        this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
      );
    }
    equals(e) {
      return e.origin.equals(this.origin) && e.direction.equals(this.direction);
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class Ht {
    constructor(e, t, r, n, i, o, s, a, l, c, u, h, d, p, f, m) {
      (Ht.prototype.isMatrix4 = !0),
        (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        void 0 !== e &&
          this.set(e, t, r, n, i, o, s, a, l, c, u, h, d, p, f, m);
    }
    set(e, t, r, n, i, o, s, a, l, c, u, h, d, p, f, m) {
      const g = this.elements;
      return (
        (g[0] = e),
        (g[4] = t),
        (g[8] = r),
        (g[12] = n),
        (g[1] = i),
        (g[5] = o),
        (g[9] = s),
        (g[13] = a),
        (g[2] = l),
        (g[6] = c),
        (g[10] = u),
        (g[14] = h),
        (g[3] = d),
        (g[7] = p),
        (g[11] = f),
        (g[15] = m),
        this
      );
    }
    identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    clone() {
      return new Ht().fromArray(this.elements);
    }
    copy(e) {
      const t = this.elements,
        r = e.elements;
      return (
        (t[0] = r[0]),
        (t[1] = r[1]),
        (t[2] = r[2]),
        (t[3] = r[3]),
        (t[4] = r[4]),
        (t[5] = r[5]),
        (t[6] = r[6]),
        (t[7] = r[7]),
        (t[8] = r[8]),
        (t[9] = r[9]),
        (t[10] = r[10]),
        (t[11] = r[11]),
        (t[12] = r[12]),
        (t[13] = r[13]),
        (t[14] = r[14]),
        (t[15] = r[15]),
        this
      );
    }
    copyPosition(e) {
      const t = this.elements,
        r = e.elements;
      return (t[12] = r[12]), (t[13] = r[13]), (t[14] = r[14]), this;
    }
    setFromMatrix3(e) {
      const t = e.elements;
      return (
        this.set(
          t[0],
          t[3],
          t[6],
          0,
          t[1],
          t[4],
          t[7],
          0,
          t[2],
          t[5],
          t[8],
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    }
    extractBasis(e, t, r) {
      return (
        e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        r.setFromMatrixColumn(this, 2),
        this
      );
    }
    makeBasis(e, t, r) {
      return (
        this.set(
          e.x,
          t.x,
          r.x,
          0,
          e.y,
          t.y,
          r.y,
          0,
          e.z,
          t.z,
          r.z,
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    }
    extractRotation(e) {
      const t = this.elements,
        r = e.elements,
        n = 1 / zt.setFromMatrixColumn(e, 0).length(),
        i = 1 / zt.setFromMatrixColumn(e, 1).length(),
        o = 1 / zt.setFromMatrixColumn(e, 2).length();
      return (
        (t[0] = r[0] * n),
        (t[1] = r[1] * n),
        (t[2] = r[2] * n),
        (t[3] = 0),
        (t[4] = r[4] * i),
        (t[5] = r[5] * i),
        (t[6] = r[6] * i),
        (t[7] = 0),
        (t[8] = r[8] * o),
        (t[9] = r[9] * o),
        (t[10] = r[10] * o),
        (t[11] = 0),
        (t[12] = 0),
        (t[13] = 0),
        (t[14] = 0),
        (t[15] = 1),
        this
      );
    }
    makeRotationFromEuler(e) {
      const t = this.elements,
        r = e.x,
        n = e.y,
        i = e.z,
        o = Math.cos(r),
        s = Math.sin(r),
        a = Math.cos(n),
        l = Math.sin(n),
        c = Math.cos(i),
        u = Math.sin(i);
      if ("XYZ" === e.order) {
        const e = o * c,
          r = o * u,
          n = s * c,
          i = s * u;
        (t[0] = a * c),
          (t[4] = -a * u),
          (t[8] = l),
          (t[1] = r + n * l),
          (t[5] = e - i * l),
          (t[9] = -s * a),
          (t[2] = i - e * l),
          (t[6] = n + r * l),
          (t[10] = o * a);
      } else if ("YXZ" === e.order) {
        const e = a * c,
          r = a * u,
          n = l * c,
          i = l * u;
        (t[0] = e + i * s),
          (t[4] = n * s - r),
          (t[8] = o * l),
          (t[1] = o * u),
          (t[5] = o * c),
          (t[9] = -s),
          (t[2] = r * s - n),
          (t[6] = i + e * s),
          (t[10] = o * a);
      } else if ("ZXY" === e.order) {
        const e = a * c,
          r = a * u,
          n = l * c,
          i = l * u;
        (t[0] = e - i * s),
          (t[4] = -o * u),
          (t[8] = n + r * s),
          (t[1] = r + n * s),
          (t[5] = o * c),
          (t[9] = i - e * s),
          (t[2] = -o * l),
          (t[6] = s),
          (t[10] = o * a);
      } else if ("ZYX" === e.order) {
        const e = o * c,
          r = o * u,
          n = s * c,
          i = s * u;
        (t[0] = a * c),
          (t[4] = n * l - r),
          (t[8] = e * l + i),
          (t[1] = a * u),
          (t[5] = i * l + e),
          (t[9] = r * l - n),
          (t[2] = -l),
          (t[6] = s * a),
          (t[10] = o * a);
      } else if ("YZX" === e.order) {
        const e = o * a,
          r = o * l,
          n = s * a,
          i = s * l;
        (t[0] = a * c),
          (t[4] = i - e * u),
          (t[8] = n * u + r),
          (t[1] = u),
          (t[5] = o * c),
          (t[9] = -s * c),
          (t[2] = -l * c),
          (t[6] = r * u + n),
          (t[10] = e - i * u);
      } else if ("XZY" === e.order) {
        const e = o * a,
          r = o * l,
          n = s * a,
          i = s * l;
        (t[0] = a * c),
          (t[4] = -u),
          (t[8] = l * c),
          (t[1] = e * u + i),
          (t[5] = o * c),
          (t[9] = r * u - n),
          (t[2] = n * u - r),
          (t[6] = s * c),
          (t[10] = i * u + e);
      }
      return (
        (t[3] = 0),
        (t[7] = 0),
        (t[11] = 0),
        (t[12] = 0),
        (t[13] = 0),
        (t[14] = 0),
        (t[15] = 1),
        this
      );
    }
    makeRotationFromQuaternion(e) {
      return this.compose(jt, e, Wt);
    }
    lookAt(e, t, r) {
      const n = this.elements;
      return (
        qt.subVectors(e, t),
        0 === qt.lengthSq() && (qt.z = 1),
        qt.normalize(),
        Gt.crossVectors(r, qt),
        0 === Gt.lengthSq() &&
          (1 === Math.abs(r.z) ? (qt.x += 1e-4) : (qt.z += 1e-4),
          qt.normalize(),
          Gt.crossVectors(r, qt)),
        Gt.normalize(),
        Xt.crossVectors(qt, Gt),
        (n[0] = Gt.x),
        (n[4] = Xt.x),
        (n[8] = qt.x),
        (n[1] = Gt.y),
        (n[5] = Xt.y),
        (n[9] = qt.y),
        (n[2] = Gt.z),
        (n[6] = Xt.z),
        (n[10] = qt.z),
        this
      );
    }
    multiply(e) {
      return this.multiplyMatrices(this, e);
    }
    premultiply(e) {
      return this.multiplyMatrices(e, this);
    }
    multiplyMatrices(e, t) {
      const r = e.elements,
        n = t.elements,
        i = this.elements,
        o = r[0],
        s = r[4],
        a = r[8],
        l = r[12],
        c = r[1],
        u = r[5],
        h = r[9],
        d = r[13],
        p = r[2],
        f = r[6],
        m = r[10],
        g = r[14],
        _ = r[3],
        v = r[7],
        y = r[11],
        b = r[15],
        x = n[0],
        w = n[4],
        S = n[8],
        E = n[12],
        M = n[1],
        T = n[5],
        A = n[9],
        R = n[13],
        P = n[2],
        C = n[6],
        I = n[10],
        L = n[14],
        O = n[3],
        N = n[7],
        U = n[11],
        D = n[15];
      return (
        (i[0] = o * x + s * M + a * P + l * O),
        (i[4] = o * w + s * T + a * C + l * N),
        (i[8] = o * S + s * A + a * I + l * U),
        (i[12] = o * E + s * R + a * L + l * D),
        (i[1] = c * x + u * M + h * P + d * O),
        (i[5] = c * w + u * T + h * C + d * N),
        (i[9] = c * S + u * A + h * I + d * U),
        (i[13] = c * E + u * R + h * L + d * D),
        (i[2] = p * x + f * M + m * P + g * O),
        (i[6] = p * w + f * T + m * C + g * N),
        (i[10] = p * S + f * A + m * I + g * U),
        (i[14] = p * E + f * R + m * L + g * D),
        (i[3] = _ * x + v * M + y * P + b * O),
        (i[7] = _ * w + v * T + y * C + b * N),
        (i[11] = _ * S + v * A + y * I + b * U),
        (i[15] = _ * E + v * R + y * L + b * D),
        this
      );
    }
    multiplyScalar(e) {
      const t = this.elements;
      return (
        (t[0] *= e),
        (t[4] *= e),
        (t[8] *= e),
        (t[12] *= e),
        (t[1] *= e),
        (t[5] *= e),
        (t[9] *= e),
        (t[13] *= e),
        (t[2] *= e),
        (t[6] *= e),
        (t[10] *= e),
        (t[14] *= e),
        (t[3] *= e),
        (t[7] *= e),
        (t[11] *= e),
        (t[15] *= e),
        this
      );
    }
    determinant() {
      const e = this.elements,
        t = e[0],
        r = e[4],
        n = e[8],
        i = e[12],
        o = e[1],
        s = e[5],
        a = e[9],
        l = e[13],
        c = e[2],
        u = e[6],
        h = e[10],
        d = e[14];
      return (
        e[3] *
          (+i * a * u -
            n * l * u -
            i * s * h +
            r * l * h +
            n * s * d -
            r * a * d) +
        e[7] *
          (+t * a * d -
            t * l * h +
            i * o * h -
            n * o * d +
            n * l * c -
            i * a * c) +
        e[11] *
          (+t * l * u -
            t * s * d -
            i * o * u +
            r * o * d +
            i * s * c -
            r * l * c) +
        e[15] *
          (-n * s * c -
            t * a * u +
            t * s * h +
            n * o * u -
            r * o * h +
            r * a * c)
      );
    }
    transpose() {
      const e = this.elements;
      let t;
      return (
        (t = e[1]),
        (e[1] = e[4]),
        (e[4] = t),
        (t = e[2]),
        (e[2] = e[8]),
        (e[8] = t),
        (t = e[6]),
        (e[6] = e[9]),
        (e[9] = t),
        (t = e[3]),
        (e[3] = e[12]),
        (e[12] = t),
        (t = e[7]),
        (e[7] = e[13]),
        (e[13] = t),
        (t = e[11]),
        (e[11] = e[14]),
        (e[14] = t),
        this
      );
    }
    setPosition(e, t, r) {
      const n = this.elements;
      return (
        e.isVector3
          ? ((n[12] = e.x), (n[13] = e.y), (n[14] = e.z))
          : ((n[12] = e), (n[13] = t), (n[14] = r)),
        this
      );
    }
    invert() {
      const e = this.elements,
        t = e[0],
        r = e[1],
        n = e[2],
        i = e[3],
        o = e[4],
        s = e[5],
        a = e[6],
        l = e[7],
        c = e[8],
        u = e[9],
        h = e[10],
        d = e[11],
        p = e[12],
        f = e[13],
        m = e[14],
        g = e[15],
        _ =
          u * m * l - f * h * l + f * a * d - s * m * d - u * a * g + s * h * g,
        v =
          p * h * l - c * m * l - p * a * d + o * m * d + c * a * g - o * h * g,
        y =
          c * f * l - p * u * l + p * s * d - o * f * d - c * s * g + o * u * g,
        b =
          p * u * a - c * f * a - p * s * h + o * f * h + c * s * m - o * u * m,
        x = t * _ + r * v + n * y + i * b;
      if (0 === x)
        return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const w = 1 / x;
      return (
        (e[0] = _ * w),
        (e[1] =
          (f * h * i -
            u * m * i -
            f * n * d +
            r * m * d +
            u * n * g -
            r * h * g) *
          w),
        (e[2] =
          (s * m * i -
            f * a * i +
            f * n * l -
            r * m * l -
            s * n * g +
            r * a * g) *
          w),
        (e[3] =
          (u * a * i -
            s * h * i -
            u * n * l +
            r * h * l +
            s * n * d -
            r * a * d) *
          w),
        (e[4] = v * w),
        (e[5] =
          (c * m * i -
            p * h * i +
            p * n * d -
            t * m * d -
            c * n * g +
            t * h * g) *
          w),
        (e[6] =
          (p * a * i -
            o * m * i -
            p * n * l +
            t * m * l +
            o * n * g -
            t * a * g) *
          w),
        (e[7] =
          (o * h * i -
            c * a * i +
            c * n * l -
            t * h * l -
            o * n * d +
            t * a * d) *
          w),
        (e[8] = y * w),
        (e[9] =
          (p * u * i -
            c * f * i -
            p * r * d +
            t * f * d +
            c * r * g -
            t * u * g) *
          w),
        (e[10] =
          (o * f * i -
            p * s * i +
            p * r * l -
            t * f * l -
            o * r * g +
            t * s * g) *
          w),
        (e[11] =
          (c * s * i -
            o * u * i -
            c * r * l +
            t * u * l +
            o * r * d -
            t * s * d) *
          w),
        (e[12] = b * w),
        (e[13] =
          (c * f * n -
            p * u * n +
            p * r * h -
            t * f * h -
            c * r * m +
            t * u * m) *
          w),
        (e[14] =
          (p * s * n -
            o * f * n -
            p * r * a +
            t * f * a +
            o * r * m -
            t * s * m) *
          w),
        (e[15] =
          (o * u * n -
            c * s * n +
            c * r * a -
            t * u * a -
            o * r * h +
            t * s * h) *
          w),
        this
      );
    }
    scale(e) {
      const t = this.elements,
        r = e.x,
        n = e.y,
        i = e.z;
      return (
        (t[0] *= r),
        (t[4] *= n),
        (t[8] *= i),
        (t[1] *= r),
        (t[5] *= n),
        (t[9] *= i),
        (t[2] *= r),
        (t[6] *= n),
        (t[10] *= i),
        (t[3] *= r),
        (t[7] *= n),
        (t[11] *= i),
        this
      );
    }
    getMaxScaleOnAxis() {
      const e = this.elements,
        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
        r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
        n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
      return Math.sqrt(Math.max(t, r, n));
    }
    makeTranslation(e, t, r) {
      return (
        e.isVector3
          ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
          : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1),
        this
      );
    }
    makeRotationX(e) {
      const t = Math.cos(e),
        r = Math.sin(e);
      return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1), this;
    }
    makeRotationY(e) {
      const t = Math.cos(e),
        r = Math.sin(e);
      return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1), this;
    }
    makeRotationZ(e) {
      const t = Math.cos(e),
        r = Math.sin(e);
      return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
    }
    makeRotationAxis(e, t) {
      const r = Math.cos(t),
        n = Math.sin(t),
        i = 1 - r,
        o = e.x,
        s = e.y,
        a = e.z,
        l = i * o,
        c = i * s;
      return (
        this.set(
          l * o + r,
          l * s - n * a,
          l * a + n * s,
          0,
          l * s + n * a,
          c * s + r,
          c * a - n * o,
          0,
          l * a - n * s,
          c * a + n * o,
          i * a * a + r,
          0,
          0,
          0,
          0,
          1
        ),
        this
      );
    }
    makeScale(e, t, r) {
      return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1), this;
    }
    makeShear(e, t, r, n, i, o) {
      return this.set(1, r, i, 0, e, 1, o, 0, t, n, 1, 0, 0, 0, 0, 1), this;
    }
    compose(e, t, r) {
      const n = this.elements,
        i = t._x,
        o = t._y,
        s = t._z,
        a = t._w,
        l = i + i,
        c = o + o,
        u = s + s,
        h = i * l,
        d = i * c,
        p = i * u,
        f = o * c,
        m = o * u,
        g = s * u,
        _ = a * l,
        v = a * c,
        y = a * u,
        b = r.x,
        x = r.y,
        w = r.z;
      return (
        (n[0] = (1 - (f + g)) * b),
        (n[1] = (d + y) * b),
        (n[2] = (p - v) * b),
        (n[3] = 0),
        (n[4] = (d - y) * x),
        (n[5] = (1 - (h + g)) * x),
        (n[6] = (m + _) * x),
        (n[7] = 0),
        (n[8] = (p + v) * w),
        (n[9] = (m - _) * w),
        (n[10] = (1 - (h + f)) * w),
        (n[11] = 0),
        (n[12] = e.x),
        (n[13] = e.y),
        (n[14] = e.z),
        (n[15] = 1),
        this
      );
    }
    decompose(e, t, r) {
      const n = this.elements;
      let i = zt.set(n[0], n[1], n[2]).length();
      const o = zt.set(n[4], n[5], n[6]).length(),
        s = zt.set(n[8], n[9], n[10]).length();
      this.determinant() < 0 && (i = -i),
        (e.x = n[12]),
        (e.y = n[13]),
        (e.z = n[14]),
        Vt.copy(this);
      const a = 1 / i,
        l = 1 / o,
        c = 1 / s;
      return (
        (Vt.elements[0] *= a),
        (Vt.elements[1] *= a),
        (Vt.elements[2] *= a),
        (Vt.elements[4] *= l),
        (Vt.elements[5] *= l),
        (Vt.elements[6] *= l),
        (Vt.elements[8] *= c),
        (Vt.elements[9] *= c),
        (Vt.elements[10] *= c),
        t.setFromRotationMatrix(Vt),
        (r.x = i),
        (r.y = o),
        (r.z = s),
        this
      );
    }
    makePerspective(e, t, r, n, i, o, s = 2e3) {
      const a = this.elements,
        l = (2 * i) / (t - e),
        c = (2 * i) / (r - n),
        u = (t + e) / (t - e),
        h = (r + n) / (r - n);
      let d, p;
      if (s === xe) (d = -(o + i) / (o - i)), (p = (-2 * o * i) / (o - i));
      else {
        if (s !== we)
          throw new Error(
            "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + s
          );
        (d = -o / (o - i)), (p = (-o * i) / (o - i));
      }
      return (
        (a[0] = l),
        (a[4] = 0),
        (a[8] = u),
        (a[12] = 0),
        (a[1] = 0),
        (a[5] = c),
        (a[9] = h),
        (a[13] = 0),
        (a[2] = 0),
        (a[6] = 0),
        (a[10] = d),
        (a[14] = p),
        (a[3] = 0),
        (a[7] = 0),
        (a[11] = -1),
        (a[15] = 0),
        this
      );
    }
    makeOrthographic(e, t, r, n, i, o, s = 2e3) {
      const a = this.elements,
        l = 1 / (t - e),
        c = 1 / (r - n),
        u = 1 / (o - i),
        h = (t + e) * l,
        d = (r + n) * c;
      let p, f;
      if (s === xe) (p = (o + i) * u), (f = -2 * u);
      else {
        if (s !== we)
          throw new Error(
            "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + s
          );
        (p = i * u), (f = -1 * u);
      }
      return (
        (a[0] = 2 * l),
        (a[4] = 0),
        (a[8] = 0),
        (a[12] = -h),
        (a[1] = 0),
        (a[5] = 2 * c),
        (a[9] = 0),
        (a[13] = -d),
        (a[2] = 0),
        (a[6] = 0),
        (a[10] = f),
        (a[14] = -p),
        (a[3] = 0),
        (a[7] = 0),
        (a[11] = 0),
        (a[15] = 1),
        this
      );
    }
    equals(e) {
      const t = this.elements,
        r = e.elements;
      for (let e = 0; e < 16; e++) if (t[e] !== r[e]) return !1;
      return !0;
    }
    fromArray(e, t = 0) {
      for (let r = 0; r < 16; r++) this.elements[r] = e[r + t];
      return this;
    }
    toArray(e = [], t = 0) {
      const r = this.elements;
      return (
        (e[t] = r[0]),
        (e[t + 1] = r[1]),
        (e[t + 2] = r[2]),
        (e[t + 3] = r[3]),
        (e[t + 4] = r[4]),
        (e[t + 5] = r[5]),
        (e[t + 6] = r[6]),
        (e[t + 7] = r[7]),
        (e[t + 8] = r[8]),
        (e[t + 9] = r[9]),
        (e[t + 10] = r[10]),
        (e[t + 11] = r[11]),
        (e[t + 12] = r[12]),
        (e[t + 13] = r[13]),
        (e[t + 14] = r[14]),
        (e[t + 15] = r[15]),
        e
      );
    }
  }
  const zt = new ut(),
    Vt = new Ht(),
    jt = new ut(0, 0, 0),
    Wt = new ut(1, 1, 1),
    Gt = new ut(),
    Xt = new ut(),
    qt = new ut(),
    Yt = new Ht(),
    Kt = new ct();
  class $t {
    constructor(e = 0, t = 0, r = 0, n = $t.DEFAULT_ORDER) {
      (this.isEuler = !0),
        (this._x = e),
        (this._y = t),
        (this._z = r),
        (this._order = n);
    }
    get x() {
      return this._x;
    }
    set x(e) {
      (this._x = e), this._onChangeCallback();
    }
    get y() {
      return this._y;
    }
    set y(e) {
      (this._y = e), this._onChangeCallback();
    }
    get z() {
      return this._z;
    }
    set z(e) {
      (this._z = e), this._onChangeCallback();
    }
    get order() {
      return this._order;
    }
    set order(e) {
      (this._order = e), this._onChangeCallback();
    }
    set(e, t, r, n = this._order) {
      return (
        (this._x = e),
        (this._y = t),
        (this._z = r),
        (this._order = n),
        this._onChangeCallback(),
        this
      );
    }
    clone() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    }
    copy(e) {
      return (
        (this._x = e._x),
        (this._y = e._y),
        (this._z = e._z),
        (this._order = e._order),
        this._onChangeCallback(),
        this
      );
    }
    setFromRotationMatrix(e, t = this._order, r = !0) {
      const n = e.elements,
        i = n[0],
        o = n[4],
        s = n[8],
        a = n[1],
        l = n[5],
        c = n[9],
        u = n[2],
        h = n[6],
        d = n[10];
      switch (t) {
        case "XYZ":
          (this._y = Math.asin(Re(s, -1, 1))),
            Math.abs(s) < 0.9999999
              ? ((this._x = Math.atan2(-c, d)), (this._z = Math.atan2(-o, i)))
              : ((this._x = Math.atan2(h, l)), (this._z = 0));
          break;
        case "YXZ":
          (this._x = Math.asin(-Re(c, -1, 1))),
            Math.abs(c) < 0.9999999
              ? ((this._y = Math.atan2(s, d)), (this._z = Math.atan2(a, l)))
              : ((this._y = Math.atan2(-u, i)), (this._z = 0));
          break;
        case "ZXY":
          (this._x = Math.asin(Re(h, -1, 1))),
            Math.abs(h) < 0.9999999
              ? ((this._y = Math.atan2(-u, d)), (this._z = Math.atan2(-o, l)))
              : ((this._y = 0), (this._z = Math.atan2(a, i)));
          break;
        case "ZYX":
          (this._y = Math.asin(-Re(u, -1, 1))),
            Math.abs(u) < 0.9999999
              ? ((this._x = Math.atan2(h, d)), (this._z = Math.atan2(a, i)))
              : ((this._x = 0), (this._z = Math.atan2(-o, l)));
          break;
        case "YZX":
          (this._z = Math.asin(Re(a, -1, 1))),
            Math.abs(a) < 0.9999999
              ? ((this._x = Math.atan2(-c, l)), (this._y = Math.atan2(-u, i)))
              : ((this._x = 0), (this._y = Math.atan2(s, d)));
          break;
        case "XZY":
          (this._z = Math.asin(-Re(o, -1, 1))),
            Math.abs(o) < 0.9999999
              ? ((this._x = Math.atan2(h, l)), (this._y = Math.atan2(s, i)))
              : ((this._x = Math.atan2(-c, d)), (this._y = 0));
          break;
        default:
          console.warn(
            "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
              t
          );
      }
      return (this._order = t), !0 === r && this._onChangeCallback(), this;
    }
    setFromQuaternion(e, t, r) {
      return (
        Yt.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Yt, t, r)
      );
    }
    setFromVector3(e, t = this._order) {
      return this.set(e.x, e.y, e.z, t);
    }
    reorder(e) {
      return Kt.setFromEuler(this), this.setFromQuaternion(Kt, e);
    }
    equals(e) {
      return (
        e._x === this._x &&
        e._y === this._y &&
        e._z === this._z &&
        e._order === this._order
      );
    }
    fromArray(e) {
      return (
        (this._x = e[0]),
        (this._y = e[1]),
        (this._z = e[2]),
        void 0 !== e[3] && (this._order = e[3]),
        this._onChangeCallback(),
        this
      );
    }
    toArray(e = [], t = 0) {
      return (
        (e[t] = this._x),
        (e[t + 1] = this._y),
        (e[t + 2] = this._z),
        (e[t + 3] = this._order),
        e
      );
    }
    _onChange(e) {
      return (this._onChangeCallback = e), this;
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._order;
    }
  }
  $t.DEFAULT_ORDER = "XYZ";
  class Qt {
    constructor() {
      this.mask = 1;
    }
    set(e) {
      this.mask = (1 << e) >>> 0;
    }
    enable(e) {
      this.mask |= 1 << e;
    }
    enableAll() {
      this.mask = -1;
    }
    toggle(e) {
      this.mask ^= 1 << e;
    }
    disable(e) {
      this.mask &= ~(1 << e);
    }
    disableAll() {
      this.mask = 0;
    }
    test(e) {
      return 0 !== (this.mask & e.mask);
    }
    isEnabled(e) {
      return !!(this.mask & (1 << e));
    }
  }
  let Jt = 0;
  const Zt = new ut(),
    er = new ct(),
    tr = new Ht(),
    rr = new ut(),
    nr = new ut(),
    ir = new ut(),
    or = new ct(),
    sr = new ut(1, 0, 0),
    ar = new ut(0, 1, 0),
    lr = new ut(0, 0, 1),
    cr = { type: "added" },
    ur = { type: "removed" };
  class hr extends Se {
    constructor() {
      super(),
        (this.isObject3D = !0),
        Object.defineProperty(this, "id", { value: Jt++ }),
        (this.uuid = Ae()),
        (this.name = ""),
        (this.type = "Object3D"),
        (this.parent = null),
        (this.children = []),
        (this.up = hr.DEFAULT_UP.clone());
      const e = new ut(),
        t = new $t(),
        r = new ct(),
        n = new ut(1, 1, 1);
      t._onChange(function () {
        r.setFromEuler(t, !1);
      }),
        r._onChange(function () {
          t.setFromQuaternion(r, void 0, !1);
        }),
        Object.defineProperties(this, {
          position: { configurable: !0, enumerable: !0, value: e },
          rotation: { configurable: !0, enumerable: !0, value: t },
          quaternion: { configurable: !0, enumerable: !0, value: r },
          scale: { configurable: !0, enumerable: !0, value: n },
          modelViewMatrix: { value: new Ht() },
          normalMatrix: { value: new ke() },
        }),
        (this.matrix = new Ht()),
        (this.matrixWorld = new Ht()),
        (this.matrixAutoUpdate = hr.DEFAULT_MATRIX_AUTO_UPDATE),
        (this.matrixWorldAutoUpdate = hr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
        (this.matrixWorldNeedsUpdate = !1),
        (this.layers = new Qt()),
        (this.visible = !0),
        (this.castShadow = !1),
        (this.receiveShadow = !1),
        (this.frustumCulled = !0),
        (this.renderOrder = 0),
        (this.animations = []),
        (this.userData = {});
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
      this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale);
    }
    applyQuaternion(e) {
      return this.quaternion.premultiply(e), this;
    }
    setRotationFromAxisAngle(e, t) {
      this.quaternion.setFromAxisAngle(e, t);
    }
    setRotationFromEuler(e) {
      this.quaternion.setFromEuler(e, !0);
    }
    setRotationFromMatrix(e) {
      this.quaternion.setFromRotationMatrix(e);
    }
    setRotationFromQuaternion(e) {
      this.quaternion.copy(e);
    }
    rotateOnAxis(e, t) {
      return er.setFromAxisAngle(e, t), this.quaternion.multiply(er), this;
    }
    rotateOnWorldAxis(e, t) {
      return er.setFromAxisAngle(e, t), this.quaternion.premultiply(er), this;
    }
    rotateX(e) {
      return this.rotateOnAxis(sr, e);
    }
    rotateY(e) {
      return this.rotateOnAxis(ar, e);
    }
    rotateZ(e) {
      return this.rotateOnAxis(lr, e);
    }
    translateOnAxis(e, t) {
      return (
        Zt.copy(e).applyQuaternion(this.quaternion),
        this.position.add(Zt.multiplyScalar(t)),
        this
      );
    }
    translateX(e) {
      return this.translateOnAxis(sr, e);
    }
    translateY(e) {
      return this.translateOnAxis(ar, e);
    }
    translateZ(e) {
      return this.translateOnAxis(lr, e);
    }
    localToWorld(e) {
      return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
    }
    worldToLocal(e) {
      return (
        this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(tr.copy(this.matrixWorld).invert())
      );
    }
    lookAt(e, t, r) {
      e.isVector3 ? rr.copy(e) : rr.set(e, t, r);
      const n = this.parent;
      this.updateWorldMatrix(!0, !1),
        nr.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight
          ? tr.lookAt(nr, rr, this.up)
          : tr.lookAt(rr, nr, this.up),
        this.quaternion.setFromRotationMatrix(tr),
        n &&
          (tr.extractRotation(n.matrixWorld),
          er.setFromRotationMatrix(tr),
          this.quaternion.premultiply(er.invert()));
    }
    add(e) {
      if (arguments.length > 1) {
        for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
        return this;
      }
      return e === this
        ? (console.error(
            "THREE.Object3D.add: object can't be added as a child of itself.",
            e
          ),
          this)
        : (e && e.isObject3D
            ? (null !== e.parent && e.parent.remove(e),
              (e.parent = this),
              this.children.push(e),
              e.dispatchEvent(cr))
            : console.error(
                "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                e
              ),
          this);
    }
    remove(e) {
      if (arguments.length > 1) {
        for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
        return this;
      }
      const t = this.children.indexOf(e);
      return (
        -1 !== t &&
          ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(ur)),
        this
      );
    }
    removeFromParent() {
      const e = this.parent;
      return null !== e && e.remove(this), this;
    }
    clear() {
      return this.remove(...this.children);
    }
    attach(e) {
      return (
        this.updateWorldMatrix(!0, !1),
        tr.copy(this.matrixWorld).invert(),
        null !== e.parent &&
          (e.parent.updateWorldMatrix(!0, !1),
          tr.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(tr),
        this.add(e),
        e.updateWorldMatrix(!1, !0),
        this
      );
    }
    getObjectById(e) {
      return this.getObjectByProperty("id", e);
    }
    getObjectByName(e) {
      return this.getObjectByProperty("name", e);
    }
    getObjectByProperty(e, t) {
      if (this[e] === t) return this;
      for (let r = 0, n = this.children.length; r < n; r++) {
        const n = this.children[r].getObjectByProperty(e, t);
        if (void 0 !== n) return n;
      }
    }
    getObjectsByProperty(e, t, r = []) {
      this[e] === t && r.push(this);
      const n = this.children;
      for (let i = 0, o = n.length; i < o; i++)
        n[i].getObjectsByProperty(e, t, r);
      return r;
    }
    getWorldPosition(e) {
      return (
        this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
      );
    }
    getWorldQuaternion(e) {
      return (
        this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(nr, e, ir), e
      );
    }
    getWorldScale(e) {
      return (
        this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(nr, or, e), e
      );
    }
    getWorldDirection(e) {
      this.updateWorldMatrix(!0, !1);
      const t = this.matrixWorld.elements;
      return e.set(t[8], t[9], t[10]).normalize();
    }
    raycast() {}
    traverse(e) {
      e(this);
      const t = this.children;
      for (let r = 0, n = t.length; r < n; r++) t[r].traverse(e);
    }
    traverseVisible(e) {
      if (!1 === this.visible) return;
      e(this);
      const t = this.children;
      for (let r = 0, n = t.length; r < n; r++) t[r].traverseVisible(e);
    }
    traverseAncestors(e) {
      const t = this.parent;
      null !== t && (e(t), t.traverseAncestors(e));
    }
    updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale),
        (this.matrixWorldNeedsUpdate = !0);
    }
    updateMatrixWorld(e) {
      this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) &&
          (null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              ),
          (this.matrixWorldNeedsUpdate = !1),
          (e = !0));
      const t = this.children;
      for (let r = 0, n = t.length; r < n; r++) {
        const n = t[r];
        (!0 !== n.matrixWorldAutoUpdate && !0 !== e) || n.updateMatrixWorld(e);
      }
    }
    updateWorldMatrix(e, t) {
      const r = this.parent;
      if (
        (!0 === e &&
          null !== r &&
          !0 === r.matrixWorldAutoUpdate &&
          r.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        null === this.parent
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        !0 === t)
      ) {
        const e = this.children;
        for (let t = 0, r = e.length; t < r; t++) {
          const r = e[t];
          !0 === r.matrixWorldAutoUpdate && r.updateWorldMatrix(!1, !0);
        }
      }
    }
    toJSON(e) {
      const t = void 0 === e || "string" == typeof e,
        r = {};
      t &&
        ((e = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
          nodes: {},
        }),
        (r.metadata = {
          version: 4.6,
          type: "Object",
          generator: "Object3D.toJSON",
        }));
      const n = {};
      function i(t, r) {
        return void 0 === t[r.uuid] && (t[r.uuid] = r.toJSON(e)), r.uuid;
      }
      if (
        ((n.uuid = this.uuid),
        (n.type = this.type),
        "" !== this.name && (n.name = this.name),
        !0 === this.castShadow && (n.castShadow = !0),
        !0 === this.receiveShadow && (n.receiveShadow = !0),
        !1 === this.visible && (n.visible = !1),
        !1 === this.frustumCulled && (n.frustumCulled = !1),
        0 !== this.renderOrder && (n.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (n.userData = this.userData),
        (n.layers = this.layers.mask),
        (n.matrix = this.matrix.toArray()),
        (n.up = this.up.toArray()),
        !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1),
        this.isInstancedMesh &&
          ((n.type = "InstancedMesh"),
          (n.count = this.count),
          (n.instanceMatrix = this.instanceMatrix.toJSON()),
          null !== this.instanceColor &&
            (n.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh &&
          ((n.type = "BatchedMesh"),
          (n.perObjectFrustumCulled = this.perObjectFrustumCulled),
          (n.sortObjects = this.sortObjects),
          (n.drawRanges = this._drawRanges),
          (n.reservedRanges = this._reservedRanges),
          (n.visibility = this._visibility),
          (n.active = this._active),
          (n.bounds = this._bounds.map((e) => ({
            boxInitialized: e.boxInitialized,
            boxMin: e.box.min.toArray(),
            boxMax: e.box.max.toArray(),
            sphereInitialized: e.sphereInitialized,
            sphereRadius: e.sphere.radius,
            sphereCenter: e.sphere.center.toArray(),
          }))),
          (n.maxGeometryCount = this._maxGeometryCount),
          (n.maxVertexCount = this._maxVertexCount),
          (n.maxIndexCount = this._maxIndexCount),
          (n.geometryInitialized = this._geometryInitialized),
          (n.geometryCount = this._geometryCount),
          (n.matricesTexture = this._matricesTexture.toJSON(e)),
          null !== this.boundingSphere &&
            (n.boundingSphere = {
              center: n.boundingSphere.center.toArray(),
              radius: n.boundingSphere.radius,
            }),
          null !== this.boundingBox &&
            (n.boundingBox = {
              min: n.boundingBox.min.toArray(),
              max: n.boundingBox.max.toArray(),
            })),
        this.isScene)
      )
        this.background &&
          (this.background.isColor
            ? (n.background = this.background.toJSON())
            : this.background.isTexture &&
              (n.background = this.background.toJSON(e).uuid)),
          this.environment &&
            this.environment.isTexture &&
            !0 !== this.environment.isRenderTargetTexture &&
            (n.environment = this.environment.toJSON(e).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
        n.geometry = i(e.geometries, this.geometry);
        const t = this.geometry.parameters;
        if (void 0 !== t && void 0 !== t.shapes) {
          const r = t.shapes;
          if (Array.isArray(r))
            for (let t = 0, n = r.length; t < n; t++) {
              const n = r[t];
              i(e.shapes, n);
            }
          else i(e.shapes, r);
        }
      }
      if (
        (this.isSkinnedMesh &&
          ((n.bindMode = this.bindMode),
          (n.bindMatrix = this.bindMatrix.toArray()),
          void 0 !== this.skeleton &&
            (i(e.skeletons, this.skeleton), (n.skeleton = this.skeleton.uuid))),
        void 0 !== this.material)
      )
        if (Array.isArray(this.material)) {
          const t = [];
          for (let r = 0, n = this.material.length; r < n; r++)
            t.push(i(e.materials, this.material[r]));
          n.material = t;
        } else n.material = i(e.materials, this.material);
      if (this.children.length > 0) {
        n.children = [];
        for (let t = 0; t < this.children.length; t++)
          n.children.push(this.children[t].toJSON(e).object);
      }
      if (this.animations.length > 0) {
        n.animations = [];
        for (let t = 0; t < this.animations.length; t++) {
          const r = this.animations[t];
          n.animations.push(i(e.animations, r));
        }
      }
      if (t) {
        const t = o(e.geometries),
          n = o(e.materials),
          i = o(e.textures),
          s = o(e.images),
          a = o(e.shapes),
          l = o(e.skeletons),
          c = o(e.animations),
          u = o(e.nodes);
        t.length > 0 && (r.geometries = t),
          n.length > 0 && (r.materials = n),
          i.length > 0 && (r.textures = i),
          s.length > 0 && (r.images = s),
          a.length > 0 && (r.shapes = a),
          l.length > 0 && (r.skeletons = l),
          c.length > 0 && (r.animations = c),
          u.length > 0 && (r.nodes = u);
      }
      return (r.object = n), r;
      function o(e) {
        const t = [];
        for (const r in e) {
          const n = e[r];
          delete n.metadata, t.push(n);
        }
        return t;
      }
    }
    clone(e) {
      return new this.constructor().copy(this, e);
    }
    copy(e, t = !0) {
      if (
        ((this.name = e.name),
        this.up.copy(e.up),
        this.position.copy(e.position),
        (this.rotation.order = e.rotation.order),
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        (this.matrixAutoUpdate = e.matrixAutoUpdate),
        (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
        (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
        (this.layers.mask = e.layers.mask),
        (this.visible = e.visible),
        (this.castShadow = e.castShadow),
        (this.receiveShadow = e.receiveShadow),
        (this.frustumCulled = e.frustumCulled),
        (this.renderOrder = e.renderOrder),
        (this.animations = e.animations.slice()),
        (this.userData = JSON.parse(JSON.stringify(e.userData))),
        !0 === t)
      )
        for (let t = 0; t < e.children.length; t++) {
          const r = e.children[t];
          this.add(r.clone());
        }
      return this;
    }
  }
  (hr.DEFAULT_UP = new ut(0, 1, 0)),
    (hr.DEFAULT_MATRIX_AUTO_UPDATE = !0),
    (hr.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0);
  const dr = new ut(),
    pr = new ut(),
    fr = new ut(),
    mr = new ut(),
    gr = new ut(),
    _r = new ut(),
    vr = new ut(),
    yr = new ut(),
    br = new ut(),
    xr = new ut();
  let wr = !1;
  class Sr {
    constructor(e = new ut(), t = new ut(), r = new ut()) {
      (this.a = e), (this.b = t), (this.c = r);
    }
    static getNormal(e, t, r, n) {
      n.subVectors(r, t), dr.subVectors(e, t), n.cross(dr);
      const i = n.lengthSq();
      return i > 0 ? n.multiplyScalar(1 / Math.sqrt(i)) : n.set(0, 0, 0);
    }
    static getBarycoord(e, t, r, n, i) {
      dr.subVectors(n, t), pr.subVectors(r, t), fr.subVectors(e, t);
      const o = dr.dot(dr),
        s = dr.dot(pr),
        a = dr.dot(fr),
        l = pr.dot(pr),
        c = pr.dot(fr),
        u = o * l - s * s;
      if (0 === u) return i.set(0, 0, 0), null;
      const h = 1 / u,
        d = (l * a - s * c) * h,
        p = (o * c - s * a) * h;
      return i.set(1 - d - p, p, d);
    }
    static containsPoint(e, t, r, n) {
      return (
        null !== this.getBarycoord(e, t, r, n, mr) &&
        mr.x >= 0 &&
        mr.y >= 0 &&
        mr.x + mr.y <= 1
      );
    }
    static getUV(e, t, r, n, i, o, s, a) {
      return (
        !1 === wr &&
          (console.warn(
            "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
          ),
          (wr = !0)),
        this.getInterpolation(e, t, r, n, i, o, s, a)
      );
    }
    static getInterpolation(e, t, r, n, i, o, s, a) {
      return null === this.getBarycoord(e, t, r, n, mr)
        ? ((a.x = 0),
          (a.y = 0),
          "z" in a && (a.z = 0),
          "w" in a && (a.w = 0),
          null)
        : (a.setScalar(0),
          a.addScaledVector(i, mr.x),
          a.addScaledVector(o, mr.y),
          a.addScaledVector(s, mr.z),
          a);
    }
    static isFrontFacing(e, t, r, n) {
      return dr.subVectors(r, t), pr.subVectors(e, t), dr.cross(pr).dot(n) < 0;
    }
    set(e, t, r) {
      return this.a.copy(e), this.b.copy(t), this.c.copy(r), this;
    }
    setFromPointsAndIndices(e, t, r, n) {
      return this.a.copy(e[t]), this.b.copy(e[r]), this.c.copy(e[n]), this;
    }
    setFromAttributeAndIndices(e, t, r, n) {
      return (
        this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, r),
        this.c.fromBufferAttribute(e, n),
        this
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
    }
    getArea() {
      return (
        dr.subVectors(this.c, this.b),
        pr.subVectors(this.a, this.b),
        0.5 * dr.cross(pr).length()
      );
    }
    getMidpoint(e) {
      return e
        .addVectors(this.a, this.b)
        .add(this.c)
        .multiplyScalar(1 / 3);
    }
    getNormal(e) {
      return Sr.getNormal(this.a, this.b, this.c, e);
    }
    getPlane(e) {
      return e.setFromCoplanarPoints(this.a, this.b, this.c);
    }
    getBarycoord(e, t) {
      return Sr.getBarycoord(e, this.a, this.b, this.c, t);
    }
    getUV(e, t, r, n, i) {
      return (
        !1 === wr &&
          (console.warn(
            "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
          ),
          (wr = !0)),
        Sr.getInterpolation(e, this.a, this.b, this.c, t, r, n, i)
      );
    }
    getInterpolation(e, t, r, n, i) {
      return Sr.getInterpolation(e, this.a, this.b, this.c, t, r, n, i);
    }
    containsPoint(e) {
      return Sr.containsPoint(e, this.a, this.b, this.c);
    }
    isFrontFacing(e) {
      return Sr.isFrontFacing(this.a, this.b, this.c, e);
    }
    intersectsBox(e) {
      return e.intersectsTriangle(this);
    }
    closestPointToPoint(e, t) {
      const r = this.a,
        n = this.b,
        i = this.c;
      let o, s;
      gr.subVectors(n, r), _r.subVectors(i, r), yr.subVectors(e, r);
      const a = gr.dot(yr),
        l = _r.dot(yr);
      if (a <= 0 && l <= 0) return t.copy(r);
      br.subVectors(e, n);
      const c = gr.dot(br),
        u = _r.dot(br);
      if (c >= 0 && u <= c) return t.copy(n);
      const h = a * u - c * l;
      if (h <= 0 && a >= 0 && c <= 0)
        return (o = a / (a - c)), t.copy(r).addScaledVector(gr, o);
      xr.subVectors(e, i);
      const d = gr.dot(xr),
        p = _r.dot(xr);
      if (p >= 0 && d <= p) return t.copy(i);
      const f = d * l - a * p;
      if (f <= 0 && l >= 0 && p <= 0)
        return (s = l / (l - p)), t.copy(r).addScaledVector(_r, s);
      const m = c * p - d * u;
      if (m <= 0 && u - c >= 0 && d - p >= 0)
        return (
          vr.subVectors(i, n),
          (s = (u - c) / (u - c + (d - p))),
          t.copy(n).addScaledVector(vr, s)
        );
      const g = 1 / (m + f + h);
      return (
        (o = f * g),
        (s = h * g),
        t.copy(r).addScaledVector(gr, o).addScaledVector(_r, s)
      );
    }
    equals(e) {
      return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
    }
  }
  const Er = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074,
    },
    Mr = { h: 0, s: 0, l: 0 },
    Tr = { h: 0, s: 0, l: 0 };
  function Ar(e, t, r) {
    return (
      r < 0 && (r += 1),
      r > 1 && (r -= 1),
      r < 1 / 6
        ? e + 6 * (t - e) * r
        : r < 0.5
        ? t
        : r < 2 / 3
        ? e + 6 * (t - e) * (2 / 3 - r)
        : e
    );
  }
  class Rr {
    constructor(e, t, r) {
      return (
        (this.isColor = !0),
        (this.r = 1),
        (this.g = 1),
        (this.b = 1),
        this.set(e, t, r)
      );
    }
    set(e, t, r) {
      if (void 0 === t && void 0 === r) {
        const t = e;
        t && t.isColor
          ? this.copy(t)
          : "number" == typeof t
          ? this.setHex(t)
          : "string" == typeof t && this.setStyle(t);
      } else this.setRGB(e, t, r);
      return this;
    }
    setScalar(e) {
      return (this.r = e), (this.g = e), (this.b = e), this;
    }
    setHex(e, t = te) {
      return (
        (e = Math.floor(e)),
        (this.r = ((e >> 16) & 255) / 255),
        (this.g = ((e >> 8) & 255) / 255),
        (this.b = (255 & e) / 255),
        Ye.toWorkingColorSpace(this, t),
        this
      );
    }
    setRGB(e, t, r, n = Ye.workingColorSpace) {
      return (
        (this.r = e),
        (this.g = t),
        (this.b = r),
        Ye.toWorkingColorSpace(this, n),
        this
      );
    }
    setHSL(e, t, r, n = Ye.workingColorSpace) {
      if (((e = Pe(e, 1)), (t = Re(t, 0, 1)), (r = Re(r, 0, 1)), 0 === t))
        this.r = this.g = this.b = r;
      else {
        const n = r <= 0.5 ? r * (1 + t) : r + t - r * t,
          i = 2 * r - n;
        (this.r = Ar(i, n, e + 1 / 3)),
          (this.g = Ar(i, n, e)),
          (this.b = Ar(i, n, e - 1 / 3));
      }
      return Ye.toWorkingColorSpace(this, n), this;
    }
    setStyle(e, t = te) {
      function r(t) {
        void 0 !== t &&
          parseFloat(t) < 1 &&
          console.warn(
            "THREE.Color: Alpha component of " + e + " will be ignored."
          );
      }
      let n;
      if ((n = /^(\w+)\(([^\)]*)\)/.exec(e))) {
        let i;
        const o = n[1],
          s = n[2];
        switch (o) {
          case "rgb":
          case "rgba":
            if (
              (i =
                /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  s
                ))
            )
              return (
                r(i[4]),
                this.setRGB(
                  Math.min(255, parseInt(i[1], 10)) / 255,
                  Math.min(255, parseInt(i[2], 10)) / 255,
                  Math.min(255, parseInt(i[3], 10)) / 255,
                  t
                )
              );
            if (
              (i =
                /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  s
                ))
            )
              return (
                r(i[4]),
                this.setRGB(
                  Math.min(100, parseInt(i[1], 10)) / 100,
                  Math.min(100, parseInt(i[2], 10)) / 100,
                  Math.min(100, parseInt(i[3], 10)) / 100,
                  t
                )
              );
            break;
          case "hsl":
          case "hsla":
            if (
              (i =
                /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                  s
                ))
            )
              return (
                r(i[4]),
                this.setHSL(
                  parseFloat(i[1]) / 360,
                  parseFloat(i[2]) / 100,
                  parseFloat(i[3]) / 100,
                  t
                )
              );
            break;
          default:
            console.warn("THREE.Color: Unknown color model " + e);
        }
      } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(e))) {
        const r = n[1],
          i = r.length;
        if (3 === i)
          return this.setRGB(
            parseInt(r.charAt(0), 16) / 15,
            parseInt(r.charAt(1), 16) / 15,
            parseInt(r.charAt(2), 16) / 15,
            t
          );
        if (6 === i) return this.setHex(parseInt(r, 16), t);
        console.warn("THREE.Color: Invalid hex color " + e);
      } else if (e && e.length > 0) return this.setColorName(e, t);
      return this;
    }
    setColorName(e, t = te) {
      const r = Er[e.toLowerCase()];
      return (
        void 0 !== r
          ? this.setHex(r, t)
          : console.warn("THREE.Color: Unknown color " + e),
        this
      );
    }
    clone() {
      return new this.constructor(this.r, this.g, this.b);
    }
    copy(e) {
      return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
    }
    copySRGBToLinear(e) {
      return (this.r = Ke(e.r)), (this.g = Ke(e.g)), (this.b = Ke(e.b)), this;
    }
    copyLinearToSRGB(e) {
      return (this.r = $e(e.r)), (this.g = $e(e.g)), (this.b = $e(e.b)), this;
    }
    convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this;
    }
    convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this;
    }
    getHex(e = te) {
      return (
        Ye.fromWorkingColorSpace(Pr.copy(this), e),
        65536 * Math.round(Re(255 * Pr.r, 0, 255)) +
          256 * Math.round(Re(255 * Pr.g, 0, 255)) +
          Math.round(Re(255 * Pr.b, 0, 255))
      );
    }
    getHexString(e = te) {
      return ("000000" + this.getHex(e).toString(16)).slice(-6);
    }
    getHSL(e, t = Ye.workingColorSpace) {
      Ye.fromWorkingColorSpace(Pr.copy(this), t);
      const r = Pr.r,
        n = Pr.g,
        i = Pr.b,
        o = Math.max(r, n, i),
        s = Math.min(r, n, i);
      let a, l;
      const c = (s + o) / 2;
      if (s === o) (a = 0), (l = 0);
      else {
        const e = o - s;
        switch (((l = c <= 0.5 ? e / (o + s) : e / (2 - o - s)), o)) {
          case r:
            a = (n - i) / e + (n < i ? 6 : 0);
            break;
          case n:
            a = (i - r) / e + 2;
            break;
          case i:
            a = (r - n) / e + 4;
        }
        a /= 6;
      }
      return (e.h = a), (e.s = l), (e.l = c), e;
    }
    getRGB(e, t = Ye.workingColorSpace) {
      return (
        Ye.fromWorkingColorSpace(Pr.copy(this), t),
        (e.r = Pr.r),
        (e.g = Pr.g),
        (e.b = Pr.b),
        e
      );
    }
    getStyle(e = te) {
      Ye.fromWorkingColorSpace(Pr.copy(this), e);
      const t = Pr.r,
        r = Pr.g,
        n = Pr.b;
      return e !== te
        ? `color(${e} ${t.toFixed(3)} ${r.toFixed(3)} ${n.toFixed(3)})`
        : `rgb(${Math.round(255 * t)},${Math.round(255 * r)},${Math.round(
            255 * n
          )})`;
    }
    offsetHSL(e, t, r) {
      return this.getHSL(Mr), this.setHSL(Mr.h + e, Mr.s + t, Mr.l + r);
    }
    add(e) {
      return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
    }
    addColors(e, t) {
      return (
        (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
      );
    }
    addScalar(e) {
      return (this.r += e), (this.g += e), (this.b += e), this;
    }
    sub(e) {
      return (
        (this.r = Math.max(0, this.r - e.r)),
        (this.g = Math.max(0, this.g - e.g)),
        (this.b = Math.max(0, this.b - e.b)),
        this
      );
    }
    multiply(e) {
      return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
    }
    multiplyScalar(e) {
      return (this.r *= e), (this.g *= e), (this.b *= e), this;
    }
    lerp(e, t) {
      return (
        (this.r += (e.r - this.r) * t),
        (this.g += (e.g - this.g) * t),
        (this.b += (e.b - this.b) * t),
        this
      );
    }
    lerpColors(e, t, r) {
      return (
        (this.r = e.r + (t.r - e.r) * r),
        (this.g = e.g + (t.g - e.g) * r),
        (this.b = e.b + (t.b - e.b) * r),
        this
      );
    }
    lerpHSL(e, t) {
      this.getHSL(Mr), e.getHSL(Tr);
      const r = Ce(Mr.h, Tr.h, t),
        n = Ce(Mr.s, Tr.s, t),
        i = Ce(Mr.l, Tr.l, t);
      return this.setHSL(r, n, i), this;
    }
    setFromVector3(e) {
      return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
    }
    applyMatrix3(e) {
      const t = this.r,
        r = this.g,
        n = this.b,
        i = e.elements;
      return (
        (this.r = i[0] * t + i[3] * r + i[6] * n),
        (this.g = i[1] * t + i[4] * r + i[7] * n),
        (this.b = i[2] * t + i[5] * r + i[8] * n),
        this
      );
    }
    equals(e) {
      return e.r === this.r && e.g === this.g && e.b === this.b;
    }
    fromArray(e, t = 0) {
      return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
    }
    toArray(e = [], t = 0) {
      return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
    }
    fromBufferAttribute(e, t) {
      return (
        (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
      );
    }
    toJSON() {
      return this.getHex();
    }
    *[Symbol.iterator]() {
      yield this.r, yield this.g, yield this.b;
    }
  }
  const Pr = new Rr();
  Rr.NAMES = Er;
  let Cr = 0;
  class Ir extends Se {
    constructor() {
      super(),
        (this.isMaterial = !0),
        Object.defineProperty(this, "id", { value: Cr++ }),
        (this.uuid = Ae()),
        (this.name = ""),
        (this.type = "Material"),
        (this.blending = 1),
        (this.side = 0),
        (this.vertexColors = !1),
        (this.opacity = 1),
        (this.transparent = !1),
        (this.alphaHash = !1),
        (this.blendSrc = 204),
        (this.blendDst = 205),
        (this.blendEquation = o),
        (this.blendSrcAlpha = null),
        (this.blendDstAlpha = null),
        (this.blendEquationAlpha = null),
        (this.blendColor = new Rr(0, 0, 0)),
        (this.blendAlpha = 0),
        (this.depthFunc = 3),
        (this.depthTest = !0),
        (this.depthWrite = !0),
        (this.stencilWriteMask = 255),
        (this.stencilFunc = 519),
        (this.stencilRef = 0),
        (this.stencilFuncMask = 255),
        (this.stencilFail = ce),
        (this.stencilZFail = ce),
        (this.stencilZPass = ce),
        (this.stencilWrite = !1),
        (this.clippingPlanes = null),
        (this.clipIntersection = !1),
        (this.clipShadows = !1),
        (this.shadowSide = null),
        (this.colorWrite = !0),
        (this.precision = null),
        (this.polygonOffset = !1),
        (this.polygonOffsetFactor = 0),
        (this.polygonOffsetUnits = 0),
        (this.dithering = !1),
        (this.alphaToCoverage = !1),
        (this.premultipliedAlpha = !1),
        (this.forceSinglePass = !1),
        (this.visible = !0),
        (this.toneMapped = !0),
        (this.userData = {}),
        (this.version = 0),
        (this._alphaTest = 0);
    }
    get alphaTest() {
      return this._alphaTest;
    }
    set alphaTest(e) {
      this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
    }
    onBuild() {}
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
      return this.onBeforeCompile.toString();
    }
    setValues(e) {
      if (void 0 !== e)
        for (const t in e) {
          const r = e[t];
          if (void 0 === r) {
            console.warn(
              `THREE.Material: parameter '${t}' has value of undefined.`
            );
            continue;
          }
          const n = this[t];
          void 0 !== n
            ? n && n.isColor
              ? n.set(r)
              : n && n.isVector3 && r && r.isVector3
              ? n.copy(r)
              : (this[t] = r)
            : console.warn(
                `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
              );
        }
    }
    toJSON(e) {
      const t = void 0 === e || "string" == typeof e;
      t && (e = { textures: {}, images: {} });
      const r = {
        metadata: {
          version: 4.6,
          type: "Material",
          generator: "Material.toJSON",
        },
      };
      function n(e) {
        const t = [];
        for (const r in e) {
          const n = e[r];
          delete n.metadata, t.push(n);
        }
        return t;
      }
      if (
        ((r.uuid = this.uuid),
        (r.type = this.type),
        "" !== this.name && (r.name = this.name),
        this.color && this.color.isColor && (r.color = this.color.getHex()),
        void 0 !== this.roughness && (r.roughness = this.roughness),
        void 0 !== this.metalness && (r.metalness = this.metalness),
        void 0 !== this.sheen && (r.sheen = this.sheen),
        this.sheenColor &&
          this.sheenColor.isColor &&
          (r.sheenColor = this.sheenColor.getHex()),
        void 0 !== this.sheenRoughness &&
          (r.sheenRoughness = this.sheenRoughness),
        this.emissive &&
          this.emissive.isColor &&
          (r.emissive = this.emissive.getHex()),
        this.emissiveIntensity &&
          1 !== this.emissiveIntensity &&
          (r.emissiveIntensity = this.emissiveIntensity),
        this.specular &&
          this.specular.isColor &&
          (r.specular = this.specular.getHex()),
        void 0 !== this.specularIntensity &&
          (r.specularIntensity = this.specularIntensity),
        this.specularColor &&
          this.specularColor.isColor &&
          (r.specularColor = this.specularColor.getHex()),
        void 0 !== this.shininess && (r.shininess = this.shininess),
        void 0 !== this.clearcoat && (r.clearcoat = this.clearcoat),
        void 0 !== this.clearcoatRoughness &&
          (r.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap &&
          this.clearcoatMap.isTexture &&
          (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap &&
          this.clearcoatRoughnessMap.isTexture &&
          (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap &&
          this.clearcoatNormalMap.isTexture &&
          ((r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
          (r.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
        void 0 !== this.iridescence && (r.iridescence = this.iridescence),
        void 0 !== this.iridescenceIOR &&
          (r.iridescenceIOR = this.iridescenceIOR),
        void 0 !== this.iridescenceThicknessRange &&
          (r.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap &&
          this.iridescenceMap.isTexture &&
          (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap &&
          this.iridescenceThicknessMap.isTexture &&
          (r.iridescenceThicknessMap =
            this.iridescenceThicknessMap.toJSON(e).uuid),
        void 0 !== this.anisotropy && (r.anisotropy = this.anisotropy),
        void 0 !== this.anisotropyRotation &&
          (r.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap &&
          this.anisotropyMap.isTexture &&
          (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
        this.matcap &&
          this.matcap.isTexture &&
          (r.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap &&
          this.alphaMap.isTexture &&
          (r.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap &&
          this.lightMap.isTexture &&
          ((r.lightMap = this.lightMap.toJSON(e).uuid),
          (r.lightMapIntensity = this.lightMapIntensity)),
        this.aoMap &&
          this.aoMap.isTexture &&
          ((r.aoMap = this.aoMap.toJSON(e).uuid),
          (r.aoMapIntensity = this.aoMapIntensity)),
        this.bumpMap &&
          this.bumpMap.isTexture &&
          ((r.bumpMap = this.bumpMap.toJSON(e).uuid),
          (r.bumpScale = this.bumpScale)),
        this.normalMap &&
          this.normalMap.isTexture &&
          ((r.normalMap = this.normalMap.toJSON(e).uuid),
          (r.normalMapType = this.normalMapType),
          (r.normalScale = this.normalScale.toArray())),
        this.displacementMap &&
          this.displacementMap.isTexture &&
          ((r.displacementMap = this.displacementMap.toJSON(e).uuid),
          (r.displacementScale = this.displacementScale),
          (r.displacementBias = this.displacementBias)),
        this.roughnessMap &&
          this.roughnessMap.isTexture &&
          (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap &&
          this.metalnessMap.isTexture &&
          (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap &&
          this.emissiveMap.isTexture &&
          (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap &&
          this.specularMap.isTexture &&
          (r.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap &&
          this.specularIntensityMap.isTexture &&
          (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap &&
          this.specularColorMap.isTexture &&
          (r.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap &&
          this.envMap.isTexture &&
          ((r.envMap = this.envMap.toJSON(e).uuid),
          void 0 !== this.combine && (r.combine = this.combine)),
        void 0 !== this.envMapIntensity &&
          (r.envMapIntensity = this.envMapIntensity),
        void 0 !== this.reflectivity && (r.reflectivity = this.reflectivity),
        void 0 !== this.refractionRatio &&
          (r.refractionRatio = this.refractionRatio),
        this.gradientMap &&
          this.gradientMap.isTexture &&
          (r.gradientMap = this.gradientMap.toJSON(e).uuid),
        void 0 !== this.transmission && (r.transmission = this.transmission),
        this.transmissionMap &&
          this.transmissionMap.isTexture &&
          (r.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        void 0 !== this.thickness && (r.thickness = this.thickness),
        this.thicknessMap &&
          this.thicknessMap.isTexture &&
          (r.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        void 0 !== this.attenuationDistance &&
          this.attenuationDistance !== 1 / 0 &&
          (r.attenuationDistance = this.attenuationDistance),
        void 0 !== this.attenuationColor &&
          (r.attenuationColor = this.attenuationColor.getHex()),
        void 0 !== this.size && (r.size = this.size),
        null !== this.shadowSide && (r.shadowSide = this.shadowSide),
        void 0 !== this.sizeAttenuation &&
          (r.sizeAttenuation = this.sizeAttenuation),
        1 !== this.blending && (r.blending = this.blending),
        0 !== this.side && (r.side = this.side),
        !0 === this.vertexColors && (r.vertexColors = !0),
        this.opacity < 1 && (r.opacity = this.opacity),
        !0 === this.transparent && (r.transparent = !0),
        204 !== this.blendSrc && (r.blendSrc = this.blendSrc),
        205 !== this.blendDst && (r.blendDst = this.blendDst),
        this.blendEquation !== o && (r.blendEquation = this.blendEquation),
        null !== this.blendSrcAlpha && (r.blendSrcAlpha = this.blendSrcAlpha),
        null !== this.blendDstAlpha && (r.blendDstAlpha = this.blendDstAlpha),
        null !== this.blendEquationAlpha &&
          (r.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor &&
          this.blendColor.isColor &&
          (r.blendColor = this.blendColor.getHex()),
        0 !== this.blendAlpha && (r.blendAlpha = this.blendAlpha),
        3 !== this.depthFunc && (r.depthFunc = this.depthFunc),
        !1 === this.depthTest && (r.depthTest = this.depthTest),
        !1 === this.depthWrite && (r.depthWrite = this.depthWrite),
        !1 === this.colorWrite && (r.colorWrite = this.colorWrite),
        255 !== this.stencilWriteMask &&
          (r.stencilWriteMask = this.stencilWriteMask),
        519 !== this.stencilFunc && (r.stencilFunc = this.stencilFunc),
        0 !== this.stencilRef && (r.stencilRef = this.stencilRef),
        255 !== this.stencilFuncMask &&
          (r.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== ce && (r.stencilFail = this.stencilFail),
        this.stencilZFail !== ce && (r.stencilZFail = this.stencilZFail),
        this.stencilZPass !== ce && (r.stencilZPass = this.stencilZPass),
        !0 === this.stencilWrite && (r.stencilWrite = this.stencilWrite),
        void 0 !== this.rotation &&
          0 !== this.rotation &&
          (r.rotation = this.rotation),
        !0 === this.polygonOffset && (r.polygonOffset = !0),
        0 !== this.polygonOffsetFactor &&
          (r.polygonOffsetFactor = this.polygonOffsetFactor),
        0 !== this.polygonOffsetUnits &&
          (r.polygonOffsetUnits = this.polygonOffsetUnits),
        void 0 !== this.linewidth &&
          1 !== this.linewidth &&
          (r.linewidth = this.linewidth),
        void 0 !== this.dashSize && (r.dashSize = this.dashSize),
        void 0 !== this.gapSize && (r.gapSize = this.gapSize),
        void 0 !== this.scale && (r.scale = this.scale),
        !0 === this.dithering && (r.dithering = !0),
        this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
        !0 === this.alphaHash && (r.alphaHash = !0),
        !0 === this.alphaToCoverage && (r.alphaToCoverage = !0),
        !0 === this.premultipliedAlpha && (r.premultipliedAlpha = !0),
        !0 === this.forceSinglePass && (r.forceSinglePass = !0),
        !0 === this.wireframe && (r.wireframe = !0),
        this.wireframeLinewidth > 1 &&
          (r.wireframeLinewidth = this.wireframeLinewidth),
        "round" !== this.wireframeLinecap &&
          (r.wireframeLinecap = this.wireframeLinecap),
        "round" !== this.wireframeLinejoin &&
          (r.wireframeLinejoin = this.wireframeLinejoin),
        !0 === this.flatShading && (r.flatShading = !0),
        !1 === this.visible && (r.visible = !1),
        !1 === this.toneMapped && (r.toneMapped = !1),
        !1 === this.fog && (r.fog = !1),
        Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        t)
      ) {
        const t = n(e.textures),
          i = n(e.images);
        t.length > 0 && (r.textures = t), i.length > 0 && (r.images = i);
      }
      return r;
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      (this.name = e.name),
        (this.blending = e.blending),
        (this.side = e.side),
        (this.vertexColors = e.vertexColors),
        (this.opacity = e.opacity),
        (this.transparent = e.transparent),
        (this.blendSrc = e.blendSrc),
        (this.blendDst = e.blendDst),
        (this.blendEquation = e.blendEquation),
        (this.blendSrcAlpha = e.blendSrcAlpha),
        (this.blendDstAlpha = e.blendDstAlpha),
        (this.blendEquationAlpha = e.blendEquationAlpha),
        this.blendColor.copy(e.blendColor),
        (this.blendAlpha = e.blendAlpha),
        (this.depthFunc = e.depthFunc),
        (this.depthTest = e.depthTest),
        (this.depthWrite = e.depthWrite),
        (this.stencilWriteMask = e.stencilWriteMask),
        (this.stencilFunc = e.stencilFunc),
        (this.stencilRef = e.stencilRef),
        (this.stencilFuncMask = e.stencilFuncMask),
        (this.stencilFail = e.stencilFail),
        (this.stencilZFail = e.stencilZFail),
        (this.stencilZPass = e.stencilZPass),
        (this.stencilWrite = e.stencilWrite);
      const t = e.clippingPlanes;
      let r = null;
      if (null !== t) {
        const e = t.length;
        r = new Array(e);
        for (let n = 0; n !== e; ++n) r[n] = t[n].clone();
      }
      return (
        (this.clippingPlanes = r),
        (this.clipIntersection = e.clipIntersection),
        (this.clipShadows = e.clipShadows),
        (this.shadowSide = e.shadowSide),
        (this.colorWrite = e.colorWrite),
        (this.precision = e.precision),
        (this.polygonOffset = e.polygonOffset),
        (this.polygonOffsetFactor = e.polygonOffsetFactor),
        (this.polygonOffsetUnits = e.polygonOffsetUnits),
        (this.dithering = e.dithering),
        (this.alphaTest = e.alphaTest),
        (this.alphaHash = e.alphaHash),
        (this.alphaToCoverage = e.alphaToCoverage),
        (this.premultipliedAlpha = e.premultipliedAlpha),
        (this.forceSinglePass = e.forceSinglePass),
        (this.visible = e.visible),
        (this.toneMapped = e.toneMapped),
        (this.userData = JSON.parse(JSON.stringify(e.userData))),
        this
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
    set needsUpdate(e) {
      !0 === e && this.version++;
    }
  }
  class Lr extends Ir {
    constructor(e) {
      super(),
        (this.isMeshBasicMaterial = !0),
        (this.type = "MeshBasicMaterial"),
        (this.color = new Rr(16777215)),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.specularMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.combine = 0),
        (this.reflectivity = 1),
        (this.refractionRatio = 0.98),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.fog = !0),
        this.setValues(e);
    }
    copy(e) {
      return (
        super.copy(e),
        this.color.copy(e.color),
        (this.map = e.map),
        (this.lightMap = e.lightMap),
        (this.lightMapIntensity = e.lightMapIntensity),
        (this.aoMap = e.aoMap),
        (this.aoMapIntensity = e.aoMapIntensity),
        (this.specularMap = e.specularMap),
        (this.alphaMap = e.alphaMap),
        (this.envMap = e.envMap),
        (this.combine = e.combine),
        (this.reflectivity = e.reflectivity),
        (this.refractionRatio = e.refractionRatio),
        (this.wireframe = e.wireframe),
        (this.wireframeLinewidth = e.wireframeLinewidth),
        (this.wireframeLinecap = e.wireframeLinecap),
        (this.wireframeLinejoin = e.wireframeLinejoin),
        (this.fog = e.fog),
        this
      );
    }
  }
  const Or = new ut(),
    Nr = new De();
  class Ur {
    constructor(e, t, r = !1) {
      if (Array.isArray(e))
        throw new TypeError(
          "THREE.BufferAttribute: array should be a Typed Array."
        );
      (this.isBufferAttribute = !0),
        (this.name = ""),
        (this.array = e),
        (this.itemSize = t),
        (this.count = void 0 !== e ? e.length / t : 0),
        (this.normalized = r),
        (this.usage = ve),
        (this._updateRange = { offset: 0, count: -1 }),
        (this.updateRanges = []),
        (this.gpuType = F),
        (this.version = 0);
    }
    onUploadCallback() {}
    set needsUpdate(e) {
      !0 === e && this.version++;
    }
    get updateRange() {
      return (
        console.warn(
          "THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
        ),
        this._updateRange
      );
    }
    setUsage(e) {
      return (this.usage = e), this;
    }
    addUpdateRange(e, t) {
      this.updateRanges.push({ start: e, count: t });
    }
    clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
    copy(e) {
      return (
        (this.name = e.name),
        (this.array = new e.array.constructor(e.array)),
        (this.itemSize = e.itemSize),
        (this.count = e.count),
        (this.normalized = e.normalized),
        (this.usage = e.usage),
        (this.gpuType = e.gpuType),
        this
      );
    }
    copyAt(e, t, r) {
      (e *= this.itemSize), (r *= t.itemSize);
      for (let n = 0, i = this.itemSize; n < i; n++)
        this.array[e + n] = t.array[r + n];
      return this;
    }
    copyArray(e) {
      return this.array.set(e), this;
    }
    applyMatrix3(e) {
      if (2 === this.itemSize)
        for (let t = 0, r = this.count; t < r; t++)
          Nr.fromBufferAttribute(this, t),
            Nr.applyMatrix3(e),
            this.setXY(t, Nr.x, Nr.y);
      else if (3 === this.itemSize)
        for (let t = 0, r = this.count; t < r; t++)
          Or.fromBufferAttribute(this, t),
            Or.applyMatrix3(e),
            this.setXYZ(t, Or.x, Or.y, Or.z);
      return this;
    }
    applyMatrix4(e) {
      for (let t = 0, r = this.count; t < r; t++)
        Or.fromBufferAttribute(this, t),
          Or.applyMatrix4(e),
          this.setXYZ(t, Or.x, Or.y, Or.z);
      return this;
    }
    applyNormalMatrix(e) {
      for (let t = 0, r = this.count; t < r; t++)
        Or.fromBufferAttribute(this, t),
          Or.applyNormalMatrix(e),
          this.setXYZ(t, Or.x, Or.y, Or.z);
      return this;
    }
    transformDirection(e) {
      for (let t = 0, r = this.count; t < r; t++)
        Or.fromBufferAttribute(this, t),
          Or.transformDirection(e),
          this.setXYZ(t, Or.x, Or.y, Or.z);
      return this;
    }
    set(e, t = 0) {
      return this.array.set(e, t), this;
    }
    getComponent(e, t) {
      let r = this.array[e * this.itemSize + t];
      return this.normalized && (r = Oe(r, this.array)), r;
    }
    setComponent(e, t, r) {
      return (
        this.normalized && (r = Ne(r, this.array)),
        (this.array[e * this.itemSize + t] = r),
        this
      );
    }
    getX(e) {
      let t = this.array[e * this.itemSize];
      return this.normalized && (t = Oe(t, this.array)), t;
    }
    setX(e, t) {
      return (
        this.normalized && (t = Ne(t, this.array)),
        (this.array[e * this.itemSize] = t),
        this
      );
    }
    getY(e) {
      let t = this.array[e * this.itemSize + 1];
      return this.normalized && (t = Oe(t, this.array)), t;
    }
    setY(e, t) {
      return (
        this.normalized && (t = Ne(t, this.array)),
        (this.array[e * this.itemSize + 1] = t),
        this
      );
    }
    getZ(e) {
      let t = this.array[e * this.itemSize + 2];
      return this.normalized && (t = Oe(t, this.array)), t;
    }
    setZ(e, t) {
      return (
        this.normalized && (t = Ne(t, this.array)),
        (this.array[e * this.itemSize + 2] = t),
        this
      );
    }
    getW(e) {
      let t = this.array[e * this.itemSize + 3];
      return this.normalized && (t = Oe(t, this.array)), t;
    }
    setW(e, t) {
      return (
        this.normalized && (t = Ne(t, this.array)),
        (this.array[e * this.itemSize + 3] = t),
        this
      );
    }
    setXY(e, t, r) {
      return (
        (e *= this.itemSize),
        this.normalized && ((t = Ne(t, this.array)), (r = Ne(r, this.array))),
        (this.array[e + 0] = t),
        (this.array[e + 1] = r),
        this
      );
    }
    setXYZ(e, t, r, n) {
      return (
        (e *= this.itemSize),
        this.normalized &&
          ((t = Ne(t, this.array)),
          (r = Ne(r, this.array)),
          (n = Ne(n, this.array))),
        (this.array[e + 0] = t),
        (this.array[e + 1] = r),
        (this.array[e + 2] = n),
        this
      );
    }
    setXYZW(e, t, r, n, i) {
      return (
        (e *= this.itemSize),
        this.normalized &&
          ((t = Ne(t, this.array)),
          (r = Ne(r, this.array)),
          (n = Ne(n, this.array)),
          (i = Ne(i, this.array))),
        (this.array[e + 0] = t),
        (this.array[e + 1] = r),
        (this.array[e + 2] = n),
        (this.array[e + 3] = i),
        this
      );
    }
    onUpload(e) {
      return (this.onUploadCallback = e), this;
    }
    clone() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
    toJSON() {
      const e = {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: Array.from(this.array),
        normalized: this.normalized,
      };
      return (
        "" !== this.name && (e.name = this.name),
        this.usage !== ve && (e.usage = this.usage),
        e
      );
    }
  }
  class Dr extends Ur {
    constructor(e, t, r) {
      super(new Uint16Array(e), t, r);
    }
  }
  class kr extends Ur {
    constructor(e, t, r) {
      super(new Uint32Array(e), t, r);
    }
  }
  class Br extends Ur {
    constructor(e, t, r) {
      super(new Float32Array(e), t, r);
    }
  }
  let Fr = 0;
  const Hr = new Ht(),
    zr = new hr(),
    Vr = new ut(),
    jr = new pt(),
    Wr = new pt(),
    Gr = new ut();
  class Xr extends Se {
    constructor() {
      super(),
        (this.isBufferGeometry = !0),
        Object.defineProperty(this, "id", { value: Fr++ }),
        (this.uuid = Ae()),
        (this.name = ""),
        (this.type = "BufferGeometry"),
        (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.morphTargetsRelative = !1),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.drawRange = { start: 0, count: 1 / 0 }),
        (this.userData = {});
    }
    getIndex() {
      return this.index;
    }
    setIndex(e) {
      return (
        Array.isArray(e)
          ? (this.index = new (Fe(e) ? kr : Dr)(e, 1))
          : (this.index = e),
        this
      );
    }
    getAttribute(e) {
      return this.attributes[e];
    }
    setAttribute(e, t) {
      return (this.attributes[e] = t), this;
    }
    deleteAttribute(e) {
      return delete this.attributes[e], this;
    }
    hasAttribute(e) {
      return void 0 !== this.attributes[e];
    }
    addGroup(e, t, r = 0) {
      this.groups.push({ start: e, count: t, materialIndex: r });
    }
    clearGroups() {
      this.groups = [];
    }
    setDrawRange(e, t) {
      (this.drawRange.start = e), (this.drawRange.count = t);
    }
    applyMatrix4(e) {
      const t = this.attributes.position;
      void 0 !== t && (t.applyMatrix4(e), (t.needsUpdate = !0));
      const r = this.attributes.normal;
      if (void 0 !== r) {
        const t = new ke().getNormalMatrix(e);
        r.applyNormalMatrix(t), (r.needsUpdate = !0);
      }
      const n = this.attributes.tangent;
      return (
        void 0 !== n && (n.transformDirection(e), (n.needsUpdate = !0)),
        null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        this
      );
    }
    applyQuaternion(e) {
      return Hr.makeRotationFromQuaternion(e), this.applyMatrix4(Hr), this;
    }
    rotateX(e) {
      return Hr.makeRotationX(e), this.applyMatrix4(Hr), this;
    }
    rotateY(e) {
      return Hr.makeRotationY(e), this.applyMatrix4(Hr), this;
    }
    rotateZ(e) {
      return Hr.makeRotationZ(e), this.applyMatrix4(Hr), this;
    }
    translate(e, t, r) {
      return Hr.makeTranslation(e, t, r), this.applyMatrix4(Hr), this;
    }
    scale(e, t, r) {
      return Hr.makeScale(e, t, r), this.applyMatrix4(Hr), this;
    }
    lookAt(e) {
      return (
        zr.lookAt(e), zr.updateMatrix(), this.applyMatrix4(zr.matrix), this
      );
    }
    center() {
      return (
        this.computeBoundingBox(),
        this.boundingBox.getCenter(Vr).negate(),
        this.translate(Vr.x, Vr.y, Vr.z),
        this
      );
    }
    setFromPoints(e) {
      const t = [];
      for (let r = 0, n = e.length; r < n; r++) {
        const n = e[r];
        t.push(n.x, n.y, n.z || 0);
      }
      return this.setAttribute("position", new Br(t, 3)), this;
    }
    computeBoundingBox() {
      null === this.boundingBox && (this.boundingBox = new pt());
      const e = this.attributes.position,
        t = this.morphAttributes.position;
      if (e && e.isGLBufferAttribute)
        return (
          console.error(
            'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
            this
          ),
          void this.boundingBox.set(
            new ut(-1 / 0, -1 / 0, -1 / 0),
            new ut(1 / 0, 1 / 0, 1 / 0)
          )
        );
      if (void 0 !== e) {
        if ((this.boundingBox.setFromBufferAttribute(e), t))
          for (let e = 0, r = t.length; e < r; e++) {
            const r = t[e];
            jr.setFromBufferAttribute(r),
              this.morphTargetsRelative
                ? (Gr.addVectors(this.boundingBox.min, jr.min),
                  this.boundingBox.expandByPoint(Gr),
                  Gr.addVectors(this.boundingBox.max, jr.max),
                  this.boundingBox.expandByPoint(Gr))
                : (this.boundingBox.expandByPoint(jr.min),
                  this.boundingBox.expandByPoint(jr.max));
          }
      } else this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) ||
        isNaN(this.boundingBox.min.y) ||
        isNaN(this.boundingBox.min.z)) &&
        console.error(
          'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
          this
        );
    }
    computeBoundingSphere() {
      null === this.boundingSphere && (this.boundingSphere = new It());
      const e = this.attributes.position,
        t = this.morphAttributes.position;
      if (e && e.isGLBufferAttribute)
        return (
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
            this
          ),
          void this.boundingSphere.set(new ut(), 1 / 0)
        );
      if (e) {
        const r = this.boundingSphere.center;
        if ((jr.setFromBufferAttribute(e), t))
          for (let e = 0, r = t.length; e < r; e++) {
            const r = t[e];
            Wr.setFromBufferAttribute(r),
              this.morphTargetsRelative
                ? (Gr.addVectors(jr.min, Wr.min),
                  jr.expandByPoint(Gr),
                  Gr.addVectors(jr.max, Wr.max),
                  jr.expandByPoint(Gr))
                : (jr.expandByPoint(Wr.min), jr.expandByPoint(Wr.max));
          }
        jr.getCenter(r);
        let n = 0;
        for (let t = 0, i = e.count; t < i; t++)
          Gr.fromBufferAttribute(e, t),
            (n = Math.max(n, r.distanceToSquared(Gr)));
        if (t)
          for (let i = 0, o = t.length; i < o; i++) {
            const o = t[i],
              s = this.morphTargetsRelative;
            for (let t = 0, i = o.count; t < i; t++)
              Gr.fromBufferAttribute(o, t),
                s && (Vr.fromBufferAttribute(e, t), Gr.add(Vr)),
                (n = Math.max(n, r.distanceToSquared(Gr)));
          }
        (this.boundingSphere.radius = Math.sqrt(n)),
          isNaN(this.boundingSphere.radius) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
              this
            );
      }
    }
    computeTangents() {
      const e = this.index,
        t = this.attributes;
      if (
        null === e ||
        void 0 === t.position ||
        void 0 === t.normal ||
        void 0 === t.uv
      )
        return void console.error(
          "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
        );
      const r = e.array,
        n = t.position.array,
        i = t.normal.array,
        o = t.uv.array,
        s = n.length / 3;
      !1 === this.hasAttribute("tangent") &&
        this.setAttribute("tangent", new Ur(new Float32Array(4 * s), 4));
      const a = this.getAttribute("tangent").array,
        l = [],
        c = [];
      for (let e = 0; e < s; e++) (l[e] = new ut()), (c[e] = new ut());
      const u = new ut(),
        h = new ut(),
        d = new ut(),
        p = new De(),
        f = new De(),
        m = new De(),
        g = new ut(),
        _ = new ut();
      function v(e, t, r) {
        u.fromArray(n, 3 * e),
          h.fromArray(n, 3 * t),
          d.fromArray(n, 3 * r),
          p.fromArray(o, 2 * e),
          f.fromArray(o, 2 * t),
          m.fromArray(o, 2 * r),
          h.sub(u),
          d.sub(u),
          f.sub(p),
          m.sub(p);
        const i = 1 / (f.x * m.y - m.x * f.y);
        isFinite(i) &&
          (g
            .copy(h)
            .multiplyScalar(m.y)
            .addScaledVector(d, -f.y)
            .multiplyScalar(i),
          _.copy(d)
            .multiplyScalar(f.x)
            .addScaledVector(h, -m.x)
            .multiplyScalar(i),
          l[e].add(g),
          l[t].add(g),
          l[r].add(g),
          c[e].add(_),
          c[t].add(_),
          c[r].add(_));
      }
      let y = this.groups;
      0 === y.length && (y = [{ start: 0, count: r.length }]);
      for (let e = 0, t = y.length; e < t; ++e) {
        const t = y[e],
          n = t.start;
        for (let e = n, i = n + t.count; e < i; e += 3)
          v(r[e + 0], r[e + 1], r[e + 2]);
      }
      const b = new ut(),
        x = new ut(),
        w = new ut(),
        S = new ut();
      function E(e) {
        w.fromArray(i, 3 * e), S.copy(w);
        const t = l[e];
        b.copy(t),
          b.sub(w.multiplyScalar(w.dot(t))).normalize(),
          x.crossVectors(S, t);
        const r = x.dot(c[e]) < 0 ? -1 : 1;
        (a[4 * e] = b.x),
          (a[4 * e + 1] = b.y),
          (a[4 * e + 2] = b.z),
          (a[4 * e + 3] = r);
      }
      for (let e = 0, t = y.length; e < t; ++e) {
        const t = y[e],
          n = t.start;
        for (let e = n, i = n + t.count; e < i; e += 3)
          E(r[e + 0]), E(r[e + 1]), E(r[e + 2]);
      }
    }
    computeVertexNormals() {
      const e = this.index,
        t = this.getAttribute("position");
      if (void 0 !== t) {
        let r = this.getAttribute("normal");
        if (void 0 === r)
          (r = new Ur(new Float32Array(3 * t.count), 3)),
            this.setAttribute("normal", r);
        else for (let e = 0, t = r.count; e < t; e++) r.setXYZ(e, 0, 0, 0);
        const n = new ut(),
          i = new ut(),
          o = new ut(),
          s = new ut(),
          a = new ut(),
          l = new ut(),
          c = new ut(),
          u = new ut();
        if (e)
          for (let h = 0, d = e.count; h < d; h += 3) {
            const d = e.getX(h + 0),
              p = e.getX(h + 1),
              f = e.getX(h + 2);
            n.fromBufferAttribute(t, d),
              i.fromBufferAttribute(t, p),
              o.fromBufferAttribute(t, f),
              c.subVectors(o, i),
              u.subVectors(n, i),
              c.cross(u),
              s.fromBufferAttribute(r, d),
              a.fromBufferAttribute(r, p),
              l.fromBufferAttribute(r, f),
              s.add(c),
              a.add(c),
              l.add(c),
              r.setXYZ(d, s.x, s.y, s.z),
              r.setXYZ(p, a.x, a.y, a.z),
              r.setXYZ(f, l.x, l.y, l.z);
          }
        else
          for (let e = 0, s = t.count; e < s; e += 3)
            n.fromBufferAttribute(t, e + 0),
              i.fromBufferAttribute(t, e + 1),
              o.fromBufferAttribute(t, e + 2),
              c.subVectors(o, i),
              u.subVectors(n, i),
              c.cross(u),
              r.setXYZ(e + 0, c.x, c.y, c.z),
              r.setXYZ(e + 1, c.x, c.y, c.z),
              r.setXYZ(e + 2, c.x, c.y, c.z);
        this.normalizeNormals(), (r.needsUpdate = !0);
      }
    }
    normalizeNormals() {
      const e = this.attributes.normal;
      for (let t = 0, r = e.count; t < r; t++)
        Gr.fromBufferAttribute(e, t),
          Gr.normalize(),
          e.setXYZ(t, Gr.x, Gr.y, Gr.z);
    }
    toNonIndexed() {
      function e(e, t) {
        const r = e.array,
          n = e.itemSize,
          i = e.normalized,
          o = new r.constructor(t.length * n);
        let s = 0,
          a = 0;
        for (let i = 0, l = t.length; i < l; i++) {
          s = e.isInterleavedBufferAttribute
            ? t[i] * e.data.stride + e.offset
            : t[i] * n;
          for (let e = 0; e < n; e++) o[a++] = r[s++];
        }
        return new Ur(o, n, i);
      }
      if (null === this.index)
        return (
          console.warn(
            "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
          ),
          this
        );
      const t = new Xr(),
        r = this.index.array,
        n = this.attributes;
      for (const i in n) {
        const o = e(n[i], r);
        t.setAttribute(i, o);
      }
      const i = this.morphAttributes;
      for (const n in i) {
        const o = [],
          s = i[n];
        for (let t = 0, n = s.length; t < n; t++) {
          const n = e(s[t], r);
          o.push(n);
        }
        t.morphAttributes[n] = o;
      }
      t.morphTargetsRelative = this.morphTargetsRelative;
      const o = this.groups;
      for (let e = 0, r = o.length; e < r; e++) {
        const r = o[e];
        t.addGroup(r.start, r.count, r.materialIndex);
      }
      return t;
    }
    toJSON() {
      const e = {
        metadata: {
          version: 4.6,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON",
        },
      };
      if (
        ((e.uuid = this.uuid),
        (e.type = this.type),
        "" !== this.name && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        void 0 !== this.parameters)
      ) {
        const t = this.parameters;
        for (const r in t) void 0 !== t[r] && (e[r] = t[r]);
        return e;
      }
      e.data = { attributes: {} };
      const t = this.index;
      null !== t &&
        (e.data.index = {
          type: t.array.constructor.name,
          array: Array.prototype.slice.call(t.array),
        });
      const r = this.attributes;
      for (const t in r) {
        const n = r[t];
        e.data.attributes[t] = n.toJSON(e.data);
      }
      const n = {};
      let i = !1;
      for (const t in this.morphAttributes) {
        const r = this.morphAttributes[t],
          o = [];
        for (let t = 0, n = r.length; t < n; t++) {
          const n = r[t];
          o.push(n.toJSON(e.data));
        }
        o.length > 0 && ((n[t] = o), (i = !0));
      }
      i &&
        ((e.data.morphAttributes = n),
        (e.data.morphTargetsRelative = this.morphTargetsRelative));
      const o = this.groups;
      o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
      const s = this.boundingSphere;
      return (
        null !== s &&
          (e.data.boundingSphere = {
            center: s.center.toArray(),
            radius: s.radius,
          }),
        e
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    copy(e) {
      (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null);
      const t = {};
      this.name = e.name;
      const r = e.index;
      null !== r && this.setIndex(r.clone(t));
      const n = e.attributes;
      for (const e in n) {
        const r = n[e];
        this.setAttribute(e, r.clone(t));
      }
      const i = e.morphAttributes;
      for (const e in i) {
        const r = [],
          n = i[e];
        for (let e = 0, i = n.length; e < i; e++) r.push(n[e].clone(t));
        this.morphAttributes[e] = r;
      }
      this.morphTargetsRelative = e.morphTargetsRelative;
      const o = e.groups;
      for (let e = 0, t = o.length; e < t; e++) {
        const t = o[e];
        this.addGroup(t.start, t.count, t.materialIndex);
      }
      const s = e.boundingBox;
      null !== s && (this.boundingBox = s.clone());
      const a = e.boundingSphere;
      return (
        null !== a && (this.boundingSphere = a.clone()),
        (this.drawRange.start = e.drawRange.start),
        (this.drawRange.count = e.drawRange.count),
        (this.userData = e.userData),
        this
      );
    }
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  const qr = new Ht(),
    Yr = new Ft(),
    Kr = new It(),
    $r = new ut(),
    Qr = new ut(),
    Jr = new ut(),
    Zr = new ut(),
    en = new ut(),
    tn = new ut(),
    rn = new De(),
    nn = new De(),
    on = new De(),
    sn = new ut(),
    an = new ut(),
    ln = new ut(),
    cn = new ut(),
    un = new ut();
  class hn extends hr {
    constructor(e = new Xr(), t = new Lr()) {
      super(),
        (this.isMesh = !0),
        (this.type = "Mesh"),
        (this.geometry = e),
        (this.material = t),
        this.updateMorphTargets();
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        void 0 !== e.morphTargetInfluences &&
          (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        void 0 !== e.morphTargetDictionary &&
          (this.morphTargetDictionary = Object.assign(
            {},
            e.morphTargetDictionary
          )),
        (this.material = Array.isArray(e.material)
          ? e.material.slice()
          : e.material),
        (this.geometry = e.geometry),
        this
      );
    }
    updateMorphTargets() {
      const e = this.geometry.morphAttributes,
        t = Object.keys(e);
      if (t.length > 0) {
        const r = e[t[0]];
        if (void 0 !== r) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let e = 0, t = r.length; e < t; e++) {
            const t = r[e].name || String(e);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[t] = e);
          }
        }
      }
    }
    getVertexPosition(e, t) {
      const r = this.geometry,
        n = r.attributes.position,
        i = r.morphAttributes.position,
        o = r.morphTargetsRelative;
      t.fromBufferAttribute(n, e);
      const s = this.morphTargetInfluences;
      if (i && s) {
        tn.set(0, 0, 0);
        for (let r = 0, n = i.length; r < n; r++) {
          const n = s[r],
            a = i[r];
          0 !== n &&
            (en.fromBufferAttribute(a, e),
            o ? tn.addScaledVector(en, n) : tn.addScaledVector(en.sub(t), n));
        }
        t.add(tn);
      }
      return t;
    }
    raycast(e, t) {
      const r = this.geometry,
        n = this.material,
        i = this.matrixWorld;
      if (void 0 !== n) {
        if (
          (null === r.boundingSphere && r.computeBoundingSphere(),
          Kr.copy(r.boundingSphere),
          Kr.applyMatrix4(i),
          Yr.copy(e.ray).recast(e.near),
          !1 === Kr.containsPoint(Yr.origin))
        ) {
          if (null === Yr.intersectSphere(Kr, $r)) return;
          if (Yr.origin.distanceToSquared($r) > (e.far - e.near) ** 2) return;
        }
        qr.copy(i).invert(),
          Yr.copy(e.ray).applyMatrix4(qr),
          (null !== r.boundingBox && !1 === Yr.intersectsBox(r.boundingBox)) ||
            this._computeIntersections(e, t, Yr);
      }
    }
    _computeIntersections(e, t, r) {
      let n;
      const i = this.geometry,
        o = this.material,
        s = i.index,
        a = i.attributes.position,
        l = i.attributes.uv,
        c = i.attributes.uv1,
        u = i.attributes.normal,
        h = i.groups,
        d = i.drawRange;
      if (null !== s)
        if (Array.isArray(o))
          for (let i = 0, a = h.length; i < a; i++) {
            const a = h[i],
              p = o[a.materialIndex];
            for (
              let i = Math.max(a.start, d.start),
                o = Math.min(
                  s.count,
                  Math.min(a.start + a.count, d.start + d.count)
                );
              i < o;
              i += 3
            )
              (n = dn(
                this,
                p,
                e,
                r,
                l,
                c,
                u,
                s.getX(i),
                s.getX(i + 1),
                s.getX(i + 2)
              )),
                n &&
                  ((n.faceIndex = Math.floor(i / 3)),
                  (n.face.materialIndex = a.materialIndex),
                  t.push(n));
          }
        else
          for (
            let i = Math.max(0, d.start),
              a = Math.min(s.count, d.start + d.count);
            i < a;
            i += 3
          )
            (n = dn(
              this,
              o,
              e,
              r,
              l,
              c,
              u,
              s.getX(i),
              s.getX(i + 1),
              s.getX(i + 2)
            )),
              n && ((n.faceIndex = Math.floor(i / 3)), t.push(n));
      else if (void 0 !== a)
        if (Array.isArray(o))
          for (let i = 0, s = h.length; i < s; i++) {
            const s = h[i],
              p = o[s.materialIndex];
            for (
              let i = Math.max(s.start, d.start),
                o = Math.min(
                  a.count,
                  Math.min(s.start + s.count, d.start + d.count)
                );
              i < o;
              i += 3
            )
              (n = dn(this, p, e, r, l, c, u, i, i + 1, i + 2)),
                n &&
                  ((n.faceIndex = Math.floor(i / 3)),
                  (n.face.materialIndex = s.materialIndex),
                  t.push(n));
          }
        else
          for (
            let i = Math.max(0, d.start),
              s = Math.min(a.count, d.start + d.count);
            i < s;
            i += 3
          )
            (n = dn(this, o, e, r, l, c, u, i, i + 1, i + 2)),
              n && ((n.faceIndex = Math.floor(i / 3)), t.push(n));
    }
  }
  function dn(e, t, r, n, i, o, s, a, l, c) {
    e.getVertexPosition(a, Qr),
      e.getVertexPosition(l, Jr),
      e.getVertexPosition(c, Zr);
    const u = (function (e, t, r, n, i, o, s, a) {
      let l;
      if (
        ((l =
          1 === t.side
            ? n.intersectTriangle(s, o, i, !0, a)
            : n.intersectTriangle(i, o, s, 0 === t.side, a)),
        null === l)
      )
        return null;
      un.copy(a), un.applyMatrix4(e.matrixWorld);
      const c = r.ray.origin.distanceTo(un);
      return c < r.near || c > r.far
        ? null
        : { distance: c, point: un.clone(), object: e };
    })(e, t, r, n, Qr, Jr, Zr, cn);
    if (u) {
      i &&
        (rn.fromBufferAttribute(i, a),
        nn.fromBufferAttribute(i, l),
        on.fromBufferAttribute(i, c),
        (u.uv = Sr.getInterpolation(cn, Qr, Jr, Zr, rn, nn, on, new De()))),
        o &&
          (rn.fromBufferAttribute(o, a),
          nn.fromBufferAttribute(o, l),
          on.fromBufferAttribute(o, c),
          (u.uv1 = Sr.getInterpolation(cn, Qr, Jr, Zr, rn, nn, on, new De())),
          (u.uv2 = u.uv1)),
        s &&
          (sn.fromBufferAttribute(s, a),
          an.fromBufferAttribute(s, l),
          ln.fromBufferAttribute(s, c),
          (u.normal = Sr.getInterpolation(
            cn,
            Qr,
            Jr,
            Zr,
            sn,
            an,
            ln,
            new ut()
          )),
          u.normal.dot(n.direction) > 0 && u.normal.multiplyScalar(-1));
      const e = { a, b: l, c, normal: new ut(), materialIndex: 0 };
      Sr.getNormal(Qr, Jr, Zr, e.normal), (u.face = e);
    }
    return u;
  }
  class pn extends Xr {
    constructor(e = 1, t = 1, r = 1, n = 1, i = 1, o = 1) {
      super(),
        (this.type = "BoxGeometry"),
        (this.parameters = {
          width: e,
          height: t,
          depth: r,
          widthSegments: n,
          heightSegments: i,
          depthSegments: o,
        });
      const s = this;
      (n = Math.floor(n)), (i = Math.floor(i)), (o = Math.floor(o));
      const a = [],
        l = [],
        c = [],
        u = [];
      let h = 0,
        d = 0;
      function p(e, t, r, n, i, o, p, f, m, g, _) {
        const v = o / m,
          y = p / g,
          b = o / 2,
          x = p / 2,
          w = f / 2,
          S = m + 1,
          E = g + 1;
        let M = 0,
          T = 0;
        const A = new ut();
        for (let o = 0; o < E; o++) {
          const s = o * y - x;
          for (let a = 0; a < S; a++) {
            const h = a * v - b;
            (A[e] = h * n),
              (A[t] = s * i),
              (A[r] = w),
              l.push(A.x, A.y, A.z),
              (A[e] = 0),
              (A[t] = 0),
              (A[r] = f > 0 ? 1 : -1),
              c.push(A.x, A.y, A.z),
              u.push(a / m),
              u.push(1 - o / g),
              (M += 1);
          }
        }
        for (let e = 0; e < g; e++)
          for (let t = 0; t < m; t++) {
            const r = h + t + S * e,
              n = h + t + S * (e + 1),
              i = h + (t + 1) + S * (e + 1),
              o = h + (t + 1) + S * e;
            a.push(r, n, o), a.push(n, i, o), (T += 6);
          }
        s.addGroup(d, T, _), (d += T), (h += M);
      }
      p("z", "y", "x", -1, -1, r, t, e, o, i, 0),
        p("z", "y", "x", 1, -1, r, t, -e, o, i, 1),
        p("x", "z", "y", 1, 1, e, r, t, n, o, 2),
        p("x", "z", "y", 1, -1, e, r, -t, n, o, 3),
        p("x", "y", "z", 1, -1, e, t, r, n, i, 4),
        p("x", "y", "z", -1, -1, e, t, -r, n, i, 5),
        this.setIndex(a),
        this.setAttribute("position", new Br(l, 3)),
        this.setAttribute("normal", new Br(c, 3)),
        this.setAttribute("uv", new Br(u, 2));
    }
    copy(e) {
      return (
        super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
      );
    }
    static fromJSON(e) {
      return new pn(
        e.width,
        e.height,
        e.depth,
        e.widthSegments,
        e.heightSegments,
        e.depthSegments
      );
    }
  }
  function fn(e) {
    const t = {};
    for (const r in e) {
      t[r] = {};
      for (const n in e[r]) {
        const i = e[r][n];
        i &&
        (i.isColor ||
          i.isMatrix3 ||
          i.isMatrix4 ||
          i.isVector2 ||
          i.isVector3 ||
          i.isVector4 ||
          i.isTexture ||
          i.isQuaternion)
          ? i.isRenderTargetTexture
            ? (console.warn(
                "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
              ),
              (t[r][n] = null))
            : (t[r][n] = i.clone())
          : Array.isArray(i)
          ? (t[r][n] = i.slice())
          : (t[r][n] = i);
      }
    }
    return t;
  }
  function mn(e) {
    const t = {};
    for (let r = 0; r < e.length; r++) {
      const n = fn(e[r]);
      for (const e in n) t[e] = n[e];
    }
    return t;
  }
  function gn(e) {
    return null === e.getRenderTarget()
      ? e.outputColorSpace
      : Ye.workingColorSpace;
  }
  const _n = { clone: fn, merge: mn };
  class vn extends Ir {
    constructor(e) {
      super(),
        (this.isShaderMaterial = !0),
        (this.type = "ShaderMaterial"),
        (this.defines = {}),
        (this.uniforms = {}),
        (this.uniformsGroups = []),
        (this.vertexShader =
          "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
        (this.fragmentShader =
          "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
        (this.linewidth = 1),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.fog = !1),
        (this.lights = !1),
        (this.clipping = !1),
        (this.forceSinglePass = !0),
        (this.extensions = {
          derivatives: !1,
          fragDepth: !1,
          drawBuffers: !1,
          shaderTextureLOD: !1,
          clipCullDistance: !1,
        }),
        (this.defaultAttributeValues = {
          color: [1, 1, 1],
          uv: [0, 0],
          uv1: [0, 0],
        }),
        (this.index0AttributeName = void 0),
        (this.uniformsNeedUpdate = !1),
        (this.glslVersion = null),
        void 0 !== e && this.setValues(e);
    }
    copy(e) {
      return (
        super.copy(e),
        (this.fragmentShader = e.fragmentShader),
        (this.vertexShader = e.vertexShader),
        (this.uniforms = fn(e.uniforms)),
        (this.uniformsGroups = (function (e) {
          const t = [];
          for (let r = 0; r < e.length; r++) t.push(e[r].clone());
          return t;
        })(e.uniformsGroups)),
        (this.defines = Object.assign({}, e.defines)),
        (this.wireframe = e.wireframe),
        (this.wireframeLinewidth = e.wireframeLinewidth),
        (this.fog = e.fog),
        (this.lights = e.lights),
        (this.clipping = e.clipping),
        (this.extensions = Object.assign({}, e.extensions)),
        (this.glslVersion = e.glslVersion),
        this
      );
    }
    toJSON(e) {
      const t = super.toJSON(e);
      (t.glslVersion = this.glslVersion), (t.uniforms = {});
      for (const r in this.uniforms) {
        const n = this.uniforms[r].value;
        n && n.isTexture
          ? (t.uniforms[r] = { type: "t", value: n.toJSON(e).uuid })
          : n && n.isColor
          ? (t.uniforms[r] = { type: "c", value: n.getHex() })
          : n && n.isVector2
          ? (t.uniforms[r] = { type: "v2", value: n.toArray() })
          : n && n.isVector3
          ? (t.uniforms[r] = { type: "v3", value: n.toArray() })
          : n && n.isVector4
          ? (t.uniforms[r] = { type: "v4", value: n.toArray() })
          : n && n.isMatrix3
          ? (t.uniforms[r] = { type: "m3", value: n.toArray() })
          : n && n.isMatrix4
          ? (t.uniforms[r] = { type: "m4", value: n.toArray() })
          : (t.uniforms[r] = { value: n });
      }
      Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        (t.vertexShader = this.vertexShader),
        (t.fragmentShader = this.fragmentShader),
        (t.lights = this.lights),
        (t.clipping = this.clipping);
      const r = {};
      for (const e in this.extensions) !0 === this.extensions[e] && (r[e] = !0);
      return Object.keys(r).length > 0 && (t.extensions = r), t;
    }
  }
  class yn extends hr {
    constructor() {
      super(),
        (this.isCamera = !0),
        (this.type = "Camera"),
        (this.matrixWorldInverse = new Ht()),
        (this.projectionMatrix = new Ht()),
        (this.projectionMatrixInverse = new Ht()),
        (this.coordinateSystem = xe);
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        (this.coordinateSystem = e.coordinateSystem),
        this
      );
    }
    getWorldDirection(e) {
      return super.getWorldDirection(e).negate();
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    updateWorldMatrix(e, t) {
      super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  class bn extends yn {
    constructor(e = 50, t = 1, r = 0.1, n = 2e3) {
      super(),
        (this.isPerspectiveCamera = !0),
        (this.type = "PerspectiveCamera"),
        (this.fov = e),
        (this.zoom = 1),
        (this.near = r),
        (this.far = n),
        (this.focus = 10),
        (this.aspect = t),
        (this.view = null),
        (this.filmGauge = 35),
        (this.filmOffset = 0),
        this.updateProjectionMatrix();
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        (this.fov = e.fov),
        (this.zoom = e.zoom),
        (this.near = e.near),
        (this.far = e.far),
        (this.focus = e.focus),
        (this.aspect = e.aspect),
        (this.view = null === e.view ? null : Object.assign({}, e.view)),
        (this.filmGauge = e.filmGauge),
        (this.filmOffset = e.filmOffset),
        this
      );
    }
    setFocalLength(e) {
      const t = (0.5 * this.getFilmHeight()) / e;
      (this.fov = 2 * Te * Math.atan(t)), this.updateProjectionMatrix();
    }
    getFocalLength() {
      const e = Math.tan(0.5 * Me * this.fov);
      return (0.5 * this.getFilmHeight()) / e;
    }
    getEffectiveFOV() {
      return 2 * Te * Math.atan(Math.tan(0.5 * Me * this.fov) / this.zoom);
    }
    getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1);
    }
    getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1);
    }
    setViewOffset(e, t, r, n, i, o) {
      (this.aspect = e / t),
        null === this.view &&
          (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1,
          }),
        (this.view.enabled = !0),
        (this.view.fullWidth = e),
        (this.view.fullHeight = t),
        (this.view.offsetX = r),
        (this.view.offsetY = n),
        (this.view.width = i),
        (this.view.height = o),
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
      null !== this.view && (this.view.enabled = !1),
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const e = this.near;
      let t = (e * Math.tan(0.5 * Me * this.fov)) / this.zoom,
        r = 2 * t,
        n = this.aspect * r,
        i = -0.5 * n;
      const o = this.view;
      if (null !== this.view && this.view.enabled) {
        const e = o.fullWidth,
          s = o.fullHeight;
        (i += (o.offsetX * n) / e),
          (t -= (o.offsetY * r) / s),
          (n *= o.width / e),
          (r *= o.height / s);
      }
      const s = this.filmOffset;
      0 !== s && (i += (e * s) / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(
          i,
          i + n,
          t,
          t - r,
          e,
          this.far,
          this.coordinateSystem
        ),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return (
        (t.object.fov = this.fov),
        (t.object.zoom = this.zoom),
        (t.object.near = this.near),
        (t.object.far = this.far),
        (t.object.focus = this.focus),
        (t.object.aspect = this.aspect),
        null !== this.view && (t.object.view = Object.assign({}, this.view)),
        (t.object.filmGauge = this.filmGauge),
        (t.object.filmOffset = this.filmOffset),
        t
      );
    }
  }
  const xn = -90;
  class wn extends hr {
    constructor(e, t, r) {
      super(),
        (this.type = "CubeCamera"),
        (this.renderTarget = r),
        (this.coordinateSystem = null),
        (this.activeMipmapLevel = 0);
      const n = new bn(xn, 1, e, t);
      (n.layers = this.layers), this.add(n);
      const i = new bn(xn, 1, e, t);
      (i.layers = this.layers), this.add(i);
      const o = new bn(xn, 1, e, t);
      (o.layers = this.layers), this.add(o);
      const s = new bn(xn, 1, e, t);
      (s.layers = this.layers), this.add(s);
      const a = new bn(xn, 1, e, t);
      (a.layers = this.layers), this.add(a);
      const l = new bn(xn, 1, e, t);
      (l.layers = this.layers), this.add(l);
    }
    updateCoordinateSystem() {
      const e = this.coordinateSystem,
        t = this.children.concat(),
        [r, n, i, o, s, a] = t;
      for (const e of t) this.remove(e);
      if (e === xe)
        r.up.set(0, 1, 0),
          r.lookAt(1, 0, 0),
          n.up.set(0, 1, 0),
          n.lookAt(-1, 0, 0),
          i.up.set(0, 0, -1),
          i.lookAt(0, 1, 0),
          o.up.set(0, 0, 1),
          o.lookAt(0, -1, 0),
          s.up.set(0, 1, 0),
          s.lookAt(0, 0, 1),
          a.up.set(0, 1, 0),
          a.lookAt(0, 0, -1);
      else {
        if (e !== we)
          throw new Error(
            "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
              e
          );
        r.up.set(0, -1, 0),
          r.lookAt(-1, 0, 0),
          n.up.set(0, -1, 0),
          n.lookAt(1, 0, 0),
          i.up.set(0, 0, 1),
          i.lookAt(0, 1, 0),
          o.up.set(0, 0, -1),
          o.lookAt(0, -1, 0),
          s.up.set(0, -1, 0),
          s.lookAt(0, 0, 1),
          a.up.set(0, -1, 0),
          a.lookAt(0, 0, -1);
      }
      for (const e of t) this.add(e), e.updateMatrixWorld();
    }
    update(e, t) {
      null === this.parent && this.updateMatrixWorld();
      const { renderTarget: r, activeMipmapLevel: n } = this;
      this.coordinateSystem !== e.coordinateSystem &&
        ((this.coordinateSystem = e.coordinateSystem),
        this.updateCoordinateSystem());
      const [i, o, s, a, l, c] = this.children,
        u = e.getRenderTarget(),
        h = e.getActiveCubeFace(),
        d = e.getActiveMipmapLevel(),
        p = e.xr.enabled;
      e.xr.enabled = !1;
      const f = r.texture.generateMipmaps;
      (r.texture.generateMipmaps = !1),
        e.setRenderTarget(r, 0, n),
        e.render(t, i),
        e.setRenderTarget(r, 1, n),
        e.render(t, o),
        e.setRenderTarget(r, 2, n),
        e.render(t, s),
        e.setRenderTarget(r, 3, n),
        e.render(t, a),
        e.setRenderTarget(r, 4, n),
        e.render(t, l),
        (r.texture.generateMipmaps = f),
        e.setRenderTarget(r, 5, n),
        e.render(t, c),
        e.setRenderTarget(u, h, d),
        (e.xr.enabled = p),
        (r.texture.needsPMREMUpdate = !0);
    }
  }
  class Sn extends nt {
    constructor(e, t, r, n, i, o, s, a, l, c) {
      super(
        (e = void 0 !== e ? e : []),
        (t = void 0 !== t ? t : E),
        r,
        n,
        i,
        o,
        s,
        a,
        l,
        c
      ),
        (this.isCubeTexture = !0),
        (this.flipY = !1);
    }
    get images() {
      return this.image;
    }
    set images(e) {
      this.image = e;
    }
  }
  class En extends st {
    constructor(e = 1, t = {}) {
      super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
      const r = { width: e, height: e, depth: 1 },
        n = [r, r, r, r, r, r];
      void 0 !== t.encoding &&
        (je(
          "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
        ),
        (t.colorSpace = t.encoding === Z ? te : ee)),
        (this.texture = new Sn(
          n,
          t.mapping,
          t.wrapS,
          t.wrapT,
          t.magFilter,
          t.minFilter,
          t.format,
          t.type,
          t.anisotropy,
          t.colorSpace
        )),
        (this.texture.isRenderTargetTexture = !0),
        (this.texture.generateMipmaps =
          void 0 !== t.generateMipmaps && t.generateMipmaps),
        (this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : O);
    }
    fromEquirectangularTexture(e, t) {
      (this.texture.type = t.type),
        (this.texture.colorSpace = t.colorSpace),
        (this.texture.generateMipmaps = t.generateMipmaps),
        (this.texture.minFilter = t.minFilter),
        (this.texture.magFilter = t.magFilter);
      const r = { tEquirect: { value: null } },
        n =
          "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
        i =
          "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
        o = new pn(5, 5, 5),
        s = new vn({
          name: "CubemapFromEquirect",
          uniforms: fn(r),
          vertexShader: n,
          fragmentShader: i,
          side: 1,
          blending: 0,
        });
      s.uniforms.tEquirect.value = t;
      const a = new hn(o, s),
        l = t.minFilter;
      return (
        t.minFilter === U && (t.minFilter = O),
        new wn(1, 10, this).update(e, a),
        (t.minFilter = l),
        a.geometry.dispose(),
        a.material.dispose(),
        this
      );
    }
    clear(e, t, r, n) {
      const i = e.getRenderTarget();
      for (let i = 0; i < 6; i++) e.setRenderTarget(this, i), e.clear(t, r, n);
      e.setRenderTarget(i);
    }
  }
  const Mn = new ut(),
    Tn = new ut(),
    An = new ke();
  class Rn {
    constructor(e = new ut(1, 0, 0), t = 0) {
      (this.isPlane = !0), (this.normal = e), (this.constant = t);
    }
    set(e, t) {
      return this.normal.copy(e), (this.constant = t), this;
    }
    setComponents(e, t, r, n) {
      return this.normal.set(e, t, r), (this.constant = n), this;
    }
    setFromNormalAndCoplanarPoint(e, t) {
      return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
    }
    setFromCoplanarPoints(e, t, r) {
      const n = Mn.subVectors(r, t).cross(Tn.subVectors(e, t)).normalize();
      return this.setFromNormalAndCoplanarPoint(n, e), this;
    }
    copy(e) {
      return this.normal.copy(e.normal), (this.constant = e.constant), this;
    }
    normalize() {
      const e = 1 / this.normal.length();
      return this.normal.multiplyScalar(e), (this.constant *= e), this;
    }
    negate() {
      return (this.constant *= -1), this.normal.negate(), this;
    }
    distanceToPoint(e) {
      return this.normal.dot(e) + this.constant;
    }
    distanceToSphere(e) {
      return this.distanceToPoint(e.center) - e.radius;
    }
    projectPoint(e, t) {
      return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
    }
    intersectLine(e, t) {
      const r = e.delta(Mn),
        n = this.normal.dot(r);
      if (0 === n)
        return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
      const i = -(e.start.dot(this.normal) + this.constant) / n;
      return i < 0 || i > 1 ? null : t.copy(e.start).addScaledVector(r, i);
    }
    intersectsLine(e) {
      const t = this.distanceToPoint(e.start),
        r = this.distanceToPoint(e.end);
      return (t < 0 && r > 0) || (r < 0 && t > 0);
    }
    intersectsBox(e) {
      return e.intersectsPlane(this);
    }
    intersectsSphere(e) {
      return e.intersectsPlane(this);
    }
    coplanarPoint(e) {
      return e.copy(this.normal).multiplyScalar(-this.constant);
    }
    applyMatrix4(e, t) {
      const r = t || An.getNormalMatrix(e),
        n = this.coplanarPoint(Mn).applyMatrix4(e),
        i = this.normal.applyMatrix3(r).normalize();
      return (this.constant = -n.dot(i)), this;
    }
    translate(e) {
      return (this.constant -= e.dot(this.normal)), this;
    }
    equals(e) {
      return e.normal.equals(this.normal) && e.constant === this.constant;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  const Pn = new It(),
    Cn = new ut();
  class In {
    constructor(
      e = new Rn(),
      t = new Rn(),
      r = new Rn(),
      n = new Rn(),
      i = new Rn(),
      o = new Rn()
    ) {
      this.planes = [e, t, r, n, i, o];
    }
    set(e, t, r, n, i, o) {
      const s = this.planes;
      return (
        s[0].copy(e),
        s[1].copy(t),
        s[2].copy(r),
        s[3].copy(n),
        s[4].copy(i),
        s[5].copy(o),
        this
      );
    }
    copy(e) {
      const t = this.planes;
      for (let r = 0; r < 6; r++) t[r].copy(e.planes[r]);
      return this;
    }
    setFromProjectionMatrix(e, t = 2e3) {
      const r = this.planes,
        n = e.elements,
        i = n[0],
        o = n[1],
        s = n[2],
        a = n[3],
        l = n[4],
        c = n[5],
        u = n[6],
        h = n[7],
        d = n[8],
        p = n[9],
        f = n[10],
        m = n[11],
        g = n[12],
        _ = n[13],
        v = n[14],
        y = n[15];
      if (
        (r[0].setComponents(a - i, h - l, m - d, y - g).normalize(),
        r[1].setComponents(a + i, h + l, m + d, y + g).normalize(),
        r[2].setComponents(a + o, h + c, m + p, y + _).normalize(),
        r[3].setComponents(a - o, h - c, m - p, y - _).normalize(),
        r[4].setComponents(a - s, h - u, m - f, y - v).normalize(),
        t === xe)
      )
        r[5].setComponents(a + s, h + u, m + f, y + v).normalize();
      else {
        if (t !== we)
          throw new Error(
            "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
              t
          );
        r[5].setComponents(s, u, f, v).normalize();
      }
      return this;
    }
    intersectsObject(e) {
      if (void 0 !== e.boundingSphere)
        null === e.boundingSphere && e.computeBoundingSphere(),
          Pn.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
      else {
        const t = e.geometry;
        null === t.boundingSphere && t.computeBoundingSphere(),
          Pn.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
      }
      return this.intersectsSphere(Pn);
    }
    intersectsSprite(e) {
      return (
        Pn.center.set(0, 0, 0),
        (Pn.radius = 0.7071067811865476),
        Pn.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(Pn)
      );
    }
    intersectsSphere(e) {
      const t = this.planes,
        r = e.center,
        n = -e.radius;
      for (let e = 0; e < 6; e++) if (t[e].distanceToPoint(r) < n) return !1;
      return !0;
    }
    intersectsBox(e) {
      const t = this.planes;
      for (let r = 0; r < 6; r++) {
        const n = t[r];
        if (
          ((Cn.x = n.normal.x > 0 ? e.max.x : e.min.x),
          (Cn.y = n.normal.y > 0 ? e.max.y : e.min.y),
          (Cn.z = n.normal.z > 0 ? e.max.z : e.min.z),
          n.distanceToPoint(Cn) < 0)
        )
          return !1;
      }
      return !0;
    }
    containsPoint(e) {
      const t = this.planes;
      for (let r = 0; r < 6; r++) if (t[r].distanceToPoint(e) < 0) return !1;
      return !0;
    }
    clone() {
      return new this.constructor().copy(this);
    }
  }
  function Ln() {
    let e = null,
      t = !1,
      r = null,
      n = null;
    function i(t, o) {
      r(t, o), (n = e.requestAnimationFrame(i));
    }
    return {
      start: function () {
        !0 !== t && null !== r && ((n = e.requestAnimationFrame(i)), (t = !0));
      },
      stop: function () {
        e.cancelAnimationFrame(n), (t = !1);
      },
      setAnimationLoop: function (e) {
        r = e;
      },
      setContext: function (t) {
        e = t;
      },
    };
  }
  function On(e, t) {
    const r = t.isWebGL2,
      n = new WeakMap();
    return {
      get: function (e) {
        return e.isInterleavedBufferAttribute && (e = e.data), n.get(e);
      },
      remove: function (t) {
        t.isInterleavedBufferAttribute && (t = t.data);
        const r = n.get(t);
        r && (e.deleteBuffer(r.buffer), n.delete(t));
      },
      update: function (t, i) {
        if (t.isGLBufferAttribute) {
          const e = n.get(t);
          return void (
            (!e || e.version < t.version) &&
            n.set(t, {
              buffer: t.buffer,
              type: t.type,
              bytesPerElement: t.elementSize,
              version: t.version,
            })
          );
        }
        t.isInterleavedBufferAttribute && (t = t.data);
        const o = n.get(t);
        if (void 0 === o)
          n.set(
            t,
            (function (t, n) {
              const i = t.array,
                o = t.usage,
                s = i.byteLength,
                a = e.createBuffer();
              let l;
              if (
                (e.bindBuffer(n, a),
                e.bufferData(n, i, o),
                t.onUploadCallback(),
                i instanceof Float32Array)
              )
                l = e.FLOAT;
              else if (i instanceof Uint16Array)
                if (t.isFloat16BufferAttribute) {
                  if (!r)
                    throw new Error(
                      "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                    );
                  l = e.HALF_FLOAT;
                } else l = e.UNSIGNED_SHORT;
              else if (i instanceof Int16Array) l = e.SHORT;
              else if (i instanceof Uint32Array) l = e.UNSIGNED_INT;
              else if (i instanceof Int32Array) l = e.INT;
              else if (i instanceof Int8Array) l = e.BYTE;
              else if (i instanceof Uint8Array) l = e.UNSIGNED_BYTE;
              else {
                if (!(i instanceof Uint8ClampedArray))
                  throw new Error(
                    "THREE.WebGLAttributes: Unsupported buffer data format: " +
                      i
                  );
                l = e.UNSIGNED_BYTE;
              }
              return {
                buffer: a,
                type: l,
                bytesPerElement: i.BYTES_PER_ELEMENT,
                version: t.version,
                size: s,
              };
            })(t, i)
          );
        else if (o.version < t.version) {
          if (o.size !== t.array.byteLength)
            throw new Error(
              "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
            );
          !(function (t, n, i) {
            const o = n.array,
              s = n._updateRange,
              a = n.updateRanges;
            if (
              (e.bindBuffer(i, t),
              -1 === s.count && 0 === a.length && e.bufferSubData(i, 0, o),
              0 !== a.length)
            ) {
              for (let t = 0, n = a.length; t < n; t++) {
                const n = a[t];
                r
                  ? e.bufferSubData(
                      i,
                      n.start * o.BYTES_PER_ELEMENT,
                      o,
                      n.start,
                      n.count
                    )
                  : e.bufferSubData(
                      i,
                      n.start * o.BYTES_PER_ELEMENT,
                      o.subarray(n.start, n.start + n.count)
                    );
              }
              n.clearUpdateRanges();
            }
            -1 !== s.count &&
              (r
                ? e.bufferSubData(
                    i,
                    s.offset * o.BYTES_PER_ELEMENT,
                    o,
                    s.offset,
                    s.count
                  )
                : e.bufferSubData(
                    i,
                    s.offset * o.BYTES_PER_ELEMENT,
                    o.subarray(s.offset, s.offset + s.count)
                  ),
              (s.count = -1)),
              n.onUploadCallback();
          })(o.buffer, t, i),
            (o.version = t.version);
        }
      },
    };
  }
  class Nn extends Xr {
    constructor(e = 1, t = 1, r = 1, n = 1) {
      super(),
        (this.type = "PlaneGeometry"),
        (this.parameters = {
          width: e,
          height: t,
          widthSegments: r,
          heightSegments: n,
        });
      const i = e / 2,
        o = t / 2,
        s = Math.floor(r),
        a = Math.floor(n),
        l = s + 1,
        c = a + 1,
        u = e / s,
        h = t / a,
        d = [],
        p = [],
        f = [],
        m = [];
      for (let e = 0; e < c; e++) {
        const t = e * h - o;
        for (let r = 0; r < l; r++) {
          const n = r * u - i;
          p.push(n, -t, 0), f.push(0, 0, 1), m.push(r / s), m.push(1 - e / a);
        }
      }
      for (let e = 0; e < a; e++)
        for (let t = 0; t < s; t++) {
          const r = t + l * e,
            n = t + l * (e + 1),
            i = t + 1 + l * (e + 1),
            o = t + 1 + l * e;
          d.push(r, n, o), d.push(n, i, o);
        }
      this.setIndex(d),
        this.setAttribute("position", new Br(p, 3)),
        this.setAttribute("normal", new Br(f, 3)),
        this.setAttribute("uv", new Br(m, 2));
    }
    copy(e) {
      return (
        super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
      );
    }
    static fromJSON(e) {
      return new Nn(e.width, e.height, e.widthSegments, e.heightSegments);
    }
  }
  const Un = {
      alphahash_fragment:
        "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
      alphahash_pars_fragment:
        "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
      alphamap_fragment:
        "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
      alphamap_pars_fragment:
        "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
      alphatest_fragment:
        "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
      alphatest_pars_fragment:
        "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
      aomap_fragment:
        "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
      aomap_pars_fragment:
        "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
      batching_pars_vertex:
        "#ifdef USE_BATCHING\n\tattribute float batchId;\n\tuniform highp sampler2D batchingTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
      batching_vertex:
        "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( batchId );\n#endif",
      begin_vertex:
        "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
      beginnormal_vertex:
        "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
      bsdfs:
        "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
      iridescence_fragment:
        "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
      bumpmap_pars_fragment:
        "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
      clipping_planes_fragment:
        "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
      clipping_planes_pars_fragment:
        "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
      clipping_planes_pars_vertex:
        "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
      clipping_planes_vertex:
        "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
      color_fragment:
        "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
      color_pars_fragment:
        "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
      color_pars_vertex:
        "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
      color_vertex:
        "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
      common:
        "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
      cube_uv_reflection_fragment:
        "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
      defaultnormal_vertex:
        "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
      displacementmap_pars_vertex:
        "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
      displacementmap_vertex:
        "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
      emissivemap_fragment:
        "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
      emissivemap_pars_fragment:
        "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
      colorspace_fragment:
        "gl_FragColor = linearToOutputTexel( gl_FragColor );",
      colorspace_pars_fragment:
        "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn sRGBTransferOETF( value );\n}",
      envmap_fragment:
        "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
      envmap_common_pars_fragment:
        "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
      envmap_pars_fragment:
        "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
      envmap_pars_vertex:
        "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
      envmap_physical_pars_fragment:
        "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
      envmap_vertex:
        "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
      fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
      fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
      fog_fragment:
        "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
      fog_pars_fragment:
        "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
      gradientmap_pars_fragment:
        "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
      lightmap_fragment:
        "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
      lightmap_pars_fragment:
        "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
      lights_lambert_fragment:
        "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
      lights_lambert_pars_fragment:
        "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
      lights_pars_begin:
        "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
      lights_toon_fragment:
        "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
      lights_toon_pars_fragment:
        "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
      lights_phong_fragment:
        "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
      lights_phong_pars_fragment:
        "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
      lights_physical_fragment:
        "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
      lights_physical_pars_fragment:
        "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
      lights_fragment_begin:
        "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
      lights_fragment_maps:
        "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
      lights_fragment_end:
        "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
      logdepthbuf_fragment:
        "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
      logdepthbuf_pars_fragment:
        "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
      logdepthbuf_pars_vertex:
        "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
      logdepthbuf_vertex:
        "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
      map_fragment:
        "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
      map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
      map_particle_fragment:
        "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
      map_particle_pars_fragment:
        "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
      metalnessmap_fragment:
        "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
      metalnessmap_pars_fragment:
        "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
      morphcolor_vertex:
        "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
      morphnormal_vertex:
        "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
      morphtarget_pars_vertex:
        "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
      morphtarget_vertex:
        "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
      normal_fragment_begin:
        "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
      normal_fragment_maps:
        "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
      normal_pars_fragment:
        "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
      normal_pars_vertex:
        "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
      normal_vertex:
        "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
      normalmap_pars_fragment:
        "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
      clearcoat_normal_fragment_begin:
        "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
      clearcoat_normal_fragment_maps:
        "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
      clearcoat_pars_fragment:
        "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
      iridescence_pars_fragment:
        "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
      opaque_fragment:
        "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
      packing:
        "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
      premultiplied_alpha_fragment:
        "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
      project_vertex:
        "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
      dithering_fragment:
        "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
      dithering_pars_fragment:
        "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
      roughnessmap_fragment:
        "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
      roughnessmap_pars_fragment:
        "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
      shadowmap_pars_fragment:
        "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
      shadowmap_pars_vertex:
        "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
      shadowmap_vertex:
        "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
      shadowmask_pars_fragment:
        "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
      skinbase_vertex:
        "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
      skinning_pars_vertex:
        "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
      skinning_vertex:
        "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
      skinnormal_vertex:
        "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
      specularmap_fragment:
        "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
      specularmap_pars_fragment:
        "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
      tonemapping_fragment:
        "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
      tonemapping_pars_fragment:
        "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor *= toneMappingExposure;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\treturn color;\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
      transmission_fragment:
        "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
      transmission_pars_fragment:
        "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
      uv_pars_fragment:
        "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
      uv_pars_vertex:
        "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
      uv_vertex:
        "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
      worldpos_vertex:
        "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
      background_vert:
        "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
      background_frag:
        "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
      backgroundCube_vert:
        "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
      backgroundCube_frag:
        "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
      cube_vert:
        "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
      cube_frag:
        "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
      depth_vert:
        "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
      depth_frag:
        "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
      distanceRGBA_vert:
        "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
      distanceRGBA_frag:
        "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
      equirect_vert:
        "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
      equirect_frag:
        "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
      linedashed_vert:
        "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      linedashed_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
      meshbasic_vert:
        "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
      meshbasic_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshlambert_vert:
        "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshlambert_frag:
        "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshmatcap_vert:
        "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
      meshmatcap_frag:
        "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshnormal_vert:
        "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
      meshnormal_frag:
        "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
      meshphong_vert:
        "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshphong_frag:
        "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshphysical_vert:
        "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
      meshphysical_frag:
        "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      meshtoon_vert:
        "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      meshtoon_frag:
        "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
      points_vert:
        "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
      points_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
      shadow_vert:
        "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
      shadow_frag:
        "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
      sprite_vert:
        "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
      sprite_frag:
        "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
    },
    Dn = {
      common: {
        diffuse: { value: new Rr(16777215) },
        opacity: { value: 1 },
        map: { value: null },
        mapTransform: { value: new ke() },
        alphaMap: { value: null },
        alphaMapTransform: { value: new ke() },
        alphaTest: { value: 0 },
      },
      specularmap: {
        specularMap: { value: null },
        specularMapTransform: { value: new ke() },
      },
      envmap: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        reflectivity: { value: 1 },
        ior: { value: 1.5 },
        refractionRatio: { value: 0.98 },
      },
      aomap: {
        aoMap: { value: null },
        aoMapIntensity: { value: 1 },
        aoMapTransform: { value: new ke() },
      },
      lightmap: {
        lightMap: { value: null },
        lightMapIntensity: { value: 1 },
        lightMapTransform: { value: new ke() },
      },
      bumpmap: {
        bumpMap: { value: null },
        bumpMapTransform: { value: new ke() },
        bumpScale: { value: 1 },
      },
      normalmap: {
        normalMap: { value: null },
        normalMapTransform: { value: new ke() },
        normalScale: { value: new De(1, 1) },
      },
      displacementmap: {
        displacementMap: { value: null },
        displacementMapTransform: { value: new ke() },
        displacementScale: { value: 1 },
        displacementBias: { value: 0 },
      },
      emissivemap: {
        emissiveMap: { value: null },
        emissiveMapTransform: { value: new ke() },
      },
      metalnessmap: {
        metalnessMap: { value: null },
        metalnessMapTransform: { value: new ke() },
      },
      roughnessmap: {
        roughnessMap: { value: null },
        roughnessMapTransform: { value: new ke() },
      },
      gradientmap: { gradientMap: { value: null } },
      fog: {
        fogDensity: { value: 25e-5 },
        fogNear: { value: 1 },
        fogFar: { value: 2e3 },
        fogColor: { value: new Rr(16777215) },
      },
      lights: {
        ambientLightColor: { value: [] },
        lightProbe: { value: [] },
        directionalLights: {
          value: [],
          properties: { direction: {}, color: {} },
        },
        directionalLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
          },
        },
        directionalShadowMap: { value: [] },
        directionalShadowMatrix: { value: [] },
        spotLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {},
          },
        },
        spotLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
          },
        },
        spotLightMap: { value: [] },
        spotShadowMap: { value: [] },
        spotLightMatrix: { value: [] },
        pointLights: {
          value: [],
          properties: { color: {}, position: {}, decay: {}, distance: {} },
        },
        pointLightShadows: {
          value: [],
          properties: {
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {},
          },
        },
        pointShadowMap: { value: [] },
        pointShadowMatrix: { value: [] },
        hemisphereLights: {
          value: [],
          properties: { direction: {}, skyColor: {}, groundColor: {} },
        },
        rectAreaLights: {
          value: [],
          properties: { color: {}, position: {}, width: {}, height: {} },
        },
        ltc_1: { value: null },
        ltc_2: { value: null },
      },
      points: {
        diffuse: { value: new Rr(16777215) },
        opacity: { value: 1 },
        size: { value: 1 },
        scale: { value: 1 },
        map: { value: null },
        alphaMap: { value: null },
        alphaMapTransform: { value: new ke() },
        alphaTest: { value: 0 },
        uvTransform: { value: new ke() },
      },
      sprite: {
        diffuse: { value: new Rr(16777215) },
        opacity: { value: 1 },
        center: { value: new De(0.5, 0.5) },
        rotation: { value: 0 },
        map: { value: null },
        mapTransform: { value: new ke() },
        alphaMap: { value: null },
        alphaMapTransform: { value: new ke() },
        alphaTest: { value: 0 },
      },
    },
    kn = {
      basic: {
        uniforms: mn([
          Dn.common,
          Dn.specularmap,
          Dn.envmap,
          Dn.aomap,
          Dn.lightmap,
          Dn.fog,
        ]),
        vertexShader: Un.meshbasic_vert,
        fragmentShader: Un.meshbasic_frag,
      },
      lambert: {
        uniforms: mn([
          Dn.common,
          Dn.specularmap,
          Dn.envmap,
          Dn.aomap,
          Dn.lightmap,
          Dn.emissivemap,
          Dn.bumpmap,
          Dn.normalmap,
          Dn.displacementmap,
          Dn.fog,
          Dn.lights,
          { emissive: { value: new Rr(0) } },
        ]),
        vertexShader: Un.meshlambert_vert,
        fragmentShader: Un.meshlambert_frag,
      },
      phong: {
        uniforms: mn([
          Dn.common,
          Dn.specularmap,
          Dn.envmap,
          Dn.aomap,
          Dn.lightmap,
          Dn.emissivemap,
          Dn.bumpmap,
          Dn.normalmap,
          Dn.displacementmap,
          Dn.fog,
          Dn.lights,
          {
            emissive: { value: new Rr(0) },
            specular: { value: new Rr(1118481) },
            shininess: { value: 30 },
          },
        ]),
        vertexShader: Un.meshphong_vert,
        fragmentShader: Un.meshphong_frag,
      },
      standard: {
        uniforms: mn([
          Dn.common,
          Dn.envmap,
          Dn.aomap,
          Dn.lightmap,
          Dn.emissivemap,
          Dn.bumpmap,
          Dn.normalmap,
          Dn.displacementmap,
          Dn.roughnessmap,
          Dn.metalnessmap,
          Dn.fog,
          Dn.lights,
          {
            emissive: { value: new Rr(0) },
            roughness: { value: 1 },
            metalness: { value: 0 },
            envMapIntensity: { value: 1 },
          },
        ]),
        vertexShader: Un.meshphysical_vert,
        fragmentShader: Un.meshphysical_frag,
      },
      toon: {
        uniforms: mn([
          Dn.common,
          Dn.aomap,
          Dn.lightmap,
          Dn.emissivemap,
          Dn.bumpmap,
          Dn.normalmap,
          Dn.displacementmap,
          Dn.gradientmap,
          Dn.fog,
          Dn.lights,
          { emissive: { value: new Rr(0) } },
        ]),
        vertexShader: Un.meshtoon_vert,
        fragmentShader: Un.meshtoon_frag,
      },
      matcap: {
        uniforms: mn([
          Dn.common,
          Dn.bumpmap,
          Dn.normalmap,
          Dn.displacementmap,
          Dn.fog,
          { matcap: { value: null } },
        ]),
        vertexShader: Un.meshmatcap_vert,
        fragmentShader: Un.meshmatcap_frag,
      },
      points: {
        uniforms: mn([Dn.points, Dn.fog]),
        vertexShader: Un.points_vert,
        fragmentShader: Un.points_frag,
      },
      dashed: {
        uniforms: mn([
          Dn.common,
          Dn.fog,
          {
            scale: { value: 1 },
            dashSize: { value: 1 },
            totalSize: { value: 2 },
          },
        ]),
        vertexShader: Un.linedashed_vert,
        fragmentShader: Un.linedashed_frag,
      },
      depth: {
        uniforms: mn([Dn.common, Dn.displacementmap]),
        vertexShader: Un.depth_vert,
        fragmentShader: Un.depth_frag,
      },
      normal: {
        uniforms: mn([
          Dn.common,
          Dn.bumpmap,
          Dn.normalmap,
          Dn.displacementmap,
          { opacity: { value: 1 } },
        ]),
        vertexShader: Un.meshnormal_vert,
        fragmentShader: Un.meshnormal_frag,
      },
      sprite: {
        uniforms: mn([Dn.sprite, Dn.fog]),
        vertexShader: Un.sprite_vert,
        fragmentShader: Un.sprite_frag,
      },
      background: {
        uniforms: {
          uvTransform: { value: new ke() },
          t2D: { value: null },
          backgroundIntensity: { value: 1 },
        },
        vertexShader: Un.background_vert,
        fragmentShader: Un.background_frag,
      },
      backgroundCube: {
        uniforms: {
          envMap: { value: null },
          flipEnvMap: { value: -1 },
          backgroundBlurriness: { value: 0 },
          backgroundIntensity: { value: 1 },
        },
        vertexShader: Un.backgroundCube_vert,
        fragmentShader: Un.backgroundCube_frag,
      },
      cube: {
        uniforms: {
          tCube: { value: null },
          tFlip: { value: -1 },
          opacity: { value: 1 },
        },
        vertexShader: Un.cube_vert,
        fragmentShader: Un.cube_frag,
      },
      equirect: {
        uniforms: { tEquirect: { value: null } },
        vertexShader: Un.equirect_vert,
        fragmentShader: Un.equirect_frag,
      },
      distanceRGBA: {
        uniforms: mn([
          Dn.common,
          Dn.displacementmap,
          {
            referencePosition: { value: new ut() },
            nearDistance: { value: 1 },
            farDistance: { value: 1e3 },
          },
        ]),
        vertexShader: Un.distanceRGBA_vert,
        fragmentShader: Un.distanceRGBA_frag,
      },
      shadow: {
        uniforms: mn([
          Dn.lights,
          Dn.fog,
          { color: { value: new Rr(0) }, opacity: { value: 1 } },
        ]),
        vertexShader: Un.shadow_vert,
        fragmentShader: Un.shadow_frag,
      },
    };
  kn.physical = {
    uniforms: mn([
      kn.standard.uniforms,
      {
        clearcoat: { value: 0 },
        clearcoatMap: { value: null },
        clearcoatMapTransform: { value: new ke() },
        clearcoatNormalMap: { value: null },
        clearcoatNormalMapTransform: { value: new ke() },
        clearcoatNormalScale: { value: new De(1, 1) },
        clearcoatRoughness: { value: 0 },
        clearcoatRoughnessMap: { value: null },
        clearcoatRoughnessMapTransform: { value: new ke() },
        iridescence: { value: 0 },
        iridescenceMap: { value: null },
        iridescenceMapTransform: { value: new ke() },
        iridescenceIOR: { value: 1.3 },
        iridescenceThicknessMinimum: { value: 100 },
        iridescenceThicknessMaximum: { value: 400 },
        iridescenceThicknessMap: { value: null },
        iridescenceThicknessMapTransform: { value: new ke() },
        sheen: { value: 0 },
        sheenColor: { value: new Rr(0) },
        sheenColorMap: { value: null },
        sheenColorMapTransform: { value: new ke() },
        sheenRoughness: { value: 1 },
        sheenRoughnessMap: { value: null },
        sheenRoughnessMapTransform: { value: new ke() },
        transmission: { value: 0 },
        transmissionMap: { value: null },
        transmissionMapTransform: { value: new ke() },
        transmissionSamplerSize: { value: new De() },
        transmissionSamplerMap: { value: null },
        thickness: { value: 0 },
        thicknessMap: { value: null },
        thicknessMapTransform: { value: new ke() },
        attenuationDistance: { value: 0 },
        attenuationColor: { value: new Rr(0) },
        specularColor: { value: new Rr(1, 1, 1) },
        specularColorMap: { value: null },
        specularColorMapTransform: { value: new ke() },
        specularIntensity: { value: 1 },
        specularIntensityMap: { value: null },
        specularIntensityMapTransform: { value: new ke() },
        anisotropyVector: { value: new De() },
        anisotropyMap: { value: null },
        anisotropyMapTransform: { value: new ke() },
      },
    ]),
    vertexShader: Un.meshphysical_vert,
    fragmentShader: Un.meshphysical_frag,
  };
  const Bn = { r: 0, b: 0, g: 0 };
  function Fn(e, t, r, n, i, o, s) {
    const a = new Rr(0);
    let l,
      c,
      u = !0 === o ? 0 : 1,
      h = null,
      d = 0,
      p = null;
    function f(t, r) {
      t.getRGB(Bn, gn(e)), n.buffers.color.setClear(Bn.r, Bn.g, Bn.b, r, s);
    }
    return {
      getClearColor: function () {
        return a;
      },
      setClearColor: function (e, t = 1) {
        a.set(e), (u = t), f(a, u);
      },
      getClearAlpha: function () {
        return u;
      },
      setClearAlpha: function (e) {
        (u = e), f(a, u);
      },
      render: function (o, m) {
        let g = !1,
          _ = !0 === m.isScene ? m.background : null;
        _ && _.isTexture && (_ = (m.backgroundBlurriness > 0 ? r : t).get(_)),
          null === _ ? f(a, u) : _ && _.isColor && (f(_, 1), (g = !0));
        const v = e.xr.getEnvironmentBlendMode();
        "additive" === v
          ? n.buffers.color.setClear(0, 0, 0, 1, s)
          : "alpha-blend" === v && n.buffers.color.setClear(0, 0, 0, 0, s),
          (e.autoClear || g) &&
            e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
          _ && (_.isCubeTexture || _.mapping === T)
            ? (void 0 === c &&
                ((c = new hn(
                  new pn(1, 1, 1),
                  new vn({
                    name: "BackgroundCubeMaterial",
                    uniforms: fn(kn.backgroundCube.uniforms),
                    vertexShader: kn.backgroundCube.vertexShader,
                    fragmentShader: kn.backgroundCube.fragmentShader,
                    side: 1,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                  })
                )),
                c.geometry.deleteAttribute("normal"),
                c.geometry.deleteAttribute("uv"),
                (c.onBeforeRender = function (e, t, r) {
                  this.matrixWorld.copyPosition(r.matrixWorld);
                }),
                Object.defineProperty(c.material, "envMap", {
                  get: function () {
                    return this.uniforms.envMap.value;
                  },
                }),
                i.update(c)),
              (c.material.uniforms.envMap.value = _),
              (c.material.uniforms.flipEnvMap.value =
                _.isCubeTexture && !1 === _.isRenderTargetTexture ? -1 : 1),
              (c.material.uniforms.backgroundBlurriness.value =
                m.backgroundBlurriness),
              (c.material.uniforms.backgroundIntensity.value =
                m.backgroundIntensity),
              (c.material.toneMapped = Ye.getTransfer(_.colorSpace) !== se),
              (h === _ && d === _.version && p === e.toneMapping) ||
                ((c.material.needsUpdate = !0),
                (h = _),
                (d = _.version),
                (p = e.toneMapping)),
              c.layers.enableAll(),
              o.unshift(c, c.geometry, c.material, 0, 0, null))
            : _ &&
              _.isTexture &&
              (void 0 === l &&
                ((l = new hn(
                  new Nn(2, 2),
                  new vn({
                    name: "BackgroundMaterial",
                    uniforms: fn(kn.background.uniforms),
                    vertexShader: kn.background.vertexShader,
                    fragmentShader: kn.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1,
                  })
                )),
                l.geometry.deleteAttribute("normal"),
                Object.defineProperty(l.material, "map", {
                  get: function () {
                    return this.uniforms.t2D.value;
                  },
                }),
                i.update(l)),
              (l.material.uniforms.t2D.value = _),
              (l.material.uniforms.backgroundIntensity.value =
                m.backgroundIntensity),
              (l.material.toneMapped = Ye.getTransfer(_.colorSpace) !== se),
              !0 === _.matrixAutoUpdate && _.updateMatrix(),
              l.material.uniforms.uvTransform.value.copy(_.matrix),
              (h === _ && d === _.version && p === e.toneMapping) ||
                ((l.material.needsUpdate = !0),
                (h = _),
                (d = _.version),
                (p = e.toneMapping)),
              l.layers.enableAll(),
              o.unshift(l, l.geometry, l.material, 0, 0, null));
      },
    };
  }
  function Hn(e, t, r, n) {
    const i = e.getParameter(e.MAX_VERTEX_ATTRIBS),
      o = n.isWebGL2 ? null : t.get("OES_vertex_array_object"),
      s = n.isWebGL2 || null !== o,
      a = {},
      l = p(null);
    let c = l,
      u = !1;
    function h(t) {
      return n.isWebGL2 ? e.bindVertexArray(t) : o.bindVertexArrayOES(t);
    }
    function d(t) {
      return n.isWebGL2 ? e.deleteVertexArray(t) : o.deleteVertexArrayOES(t);
    }
    function p(e) {
      const t = [],
        r = [],
        n = [];
      for (let e = 0; e < i; e++) (t[e] = 0), (r[e] = 0), (n[e] = 0);
      return {
        geometry: null,
        program: null,
        wireframe: !1,
        newAttributes: t,
        enabledAttributes: r,
        attributeDivisors: n,
        object: e,
        attributes: {},
        index: null,
      };
    }
    function f() {
      const e = c.newAttributes;
      for (let t = 0, r = e.length; t < r; t++) e[t] = 0;
    }
    function m(e) {
      g(e, 0);
    }
    function g(r, i) {
      const o = c.newAttributes,
        s = c.enabledAttributes,
        a = c.attributeDivisors;
      (o[r] = 1),
        0 === s[r] && (e.enableVertexAttribArray(r), (s[r] = 1)),
        a[r] !== i &&
          ((n.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[
            n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
          ](r, i),
          (a[r] = i));
    }
    function _() {
      const t = c.newAttributes,
        r = c.enabledAttributes;
      for (let n = 0, i = r.length; n < i; n++)
        r[n] !== t[n] && (e.disableVertexAttribArray(n), (r[n] = 0));
    }
    function v(t, r, n, i, o, s, a) {
      !0 === a
        ? e.vertexAttribIPointer(t, r, n, o, s)
        : e.vertexAttribPointer(t, r, n, i, o, s);
    }
    function y() {
      b(), (u = !0), c !== l && ((c = l), h(c.object));
    }
    function b() {
      (l.geometry = null), (l.program = null), (l.wireframe = !1);
    }
    return {
      setup: function (i, l, d, y, b) {
        let x = !1;
        if (s) {
          const t = (function (t, r, i) {
            const s = !0 === i.wireframe;
            let l = a[t.id];
            void 0 === l && ((l = {}), (a[t.id] = l));
            let c = l[r.id];
            void 0 === c && ((c = {}), (l[r.id] = c));
            let u = c[s];
            return (
              void 0 === u &&
                ((u = p(
                  n.isWebGL2 ? e.createVertexArray() : o.createVertexArrayOES()
                )),
                (c[s] = u)),
              u
            );
          })(y, d, l);
          c !== t && ((c = t), h(c.object)),
            (x = (function (e, t, r, n) {
              const i = c.attributes,
                o = t.attributes;
              let s = 0;
              const a = r.getAttributes();
              for (const t in a)
                if (a[t].location >= 0) {
                  const r = i[t];
                  let n = o[t];
                  if (
                    (void 0 === n &&
                      ("instanceMatrix" === t &&
                        e.instanceMatrix &&
                        (n = e.instanceMatrix),
                      "instanceColor" === t &&
                        e.instanceColor &&
                        (n = e.instanceColor)),
                    void 0 === r)
                  )
                    return !0;
                  if (r.attribute !== n) return !0;
                  if (n && r.data !== n.data) return !0;
                  s++;
                }
              return c.attributesNum !== s || c.index !== n;
            })(i, y, d, b)),
            x &&
              (function (e, t, r, n) {
                const i = {},
                  o = t.attributes;
                let s = 0;
                const a = r.getAttributes();
                for (const t in a)
                  if (a[t].location >= 0) {
                    let r = o[t];
                    void 0 === r &&
                      ("instanceMatrix" === t &&
                        e.instanceMatrix &&
                        (r = e.instanceMatrix),
                      "instanceColor" === t &&
                        e.instanceColor &&
                        (r = e.instanceColor));
                    const n = {};
                    (n.attribute = r),
                      r && r.data && (n.data = r.data),
                      (i[t] = n),
                      s++;
                  }
                (c.attributes = i), (c.attributesNum = s), (c.index = n);
              })(i, y, d, b);
        } else {
          const e = !0 === l.wireframe;
          (c.geometry === y.id && c.program === d.id && c.wireframe === e) ||
            ((c.geometry = y.id),
            (c.program = d.id),
            (c.wireframe = e),
            (x = !0));
        }
        null !== b && r.update(b, e.ELEMENT_ARRAY_BUFFER),
          (x || u) &&
            ((u = !1),
            (function (i, o, s, a) {
              if (
                !1 === n.isWebGL2 &&
                (i.isInstancedMesh || a.isInstancedBufferGeometry) &&
                null === t.get("ANGLE_instanced_arrays")
              )
                return;
              f();
              const l = a.attributes,
                c = s.getAttributes(),
                u = o.defaultAttributeValues;
              for (const t in c) {
                const o = c[t];
                if (o.location >= 0) {
                  let s = l[t];
                  if (
                    (void 0 === s &&
                      ("instanceMatrix" === t &&
                        i.instanceMatrix &&
                        (s = i.instanceMatrix),
                      "instanceColor" === t &&
                        i.instanceColor &&
                        (s = i.instanceColor)),
                    void 0 !== s)
                  ) {
                    const t = s.normalized,
                      l = s.itemSize,
                      c = r.get(s);
                    if (void 0 === c) continue;
                    const u = c.buffer,
                      h = c.type,
                      d = c.bytesPerElement,
                      p =
                        !0 === n.isWebGL2 &&
                        (h === e.INT ||
                          h === e.UNSIGNED_INT ||
                          1013 === s.gpuType);
                    if (s.isInterleavedBufferAttribute) {
                      const r = s.data,
                        n = r.stride,
                        c = s.offset;
                      if (r.isInstancedInterleavedBuffer) {
                        for (let e = 0; e < o.locationSize; e++)
                          g(o.location + e, r.meshPerAttribute);
                        !0 !== i.isInstancedMesh &&
                          void 0 === a._maxInstanceCount &&
                          (a._maxInstanceCount = r.meshPerAttribute * r.count);
                      } else
                        for (let e = 0; e < o.locationSize; e++)
                          m(o.location + e);
                      e.bindBuffer(e.ARRAY_BUFFER, u);
                      for (let e = 0; e < o.locationSize; e++)
                        v(
                          o.location + e,
                          l / o.locationSize,
                          h,
                          t,
                          n * d,
                          (c + (l / o.locationSize) * e) * d,
                          p
                        );
                    } else {
                      if (s.isInstancedBufferAttribute) {
                        for (let e = 0; e < o.locationSize; e++)
                          g(o.location + e, s.meshPerAttribute);
                        !0 !== i.isInstancedMesh &&
                          void 0 === a._maxInstanceCount &&
                          (a._maxInstanceCount = s.meshPerAttribute * s.count);
                      } else
                        for (let e = 0; e < o.locationSize; e++)
                          m(o.location + e);
                      e.bindBuffer(e.ARRAY_BUFFER, u);
                      for (let e = 0; e < o.locationSize; e++)
                        v(
                          o.location + e,
                          l / o.locationSize,
                          h,
                          t,
                          l * d,
                          (l / o.locationSize) * e * d,
                          p
                        );
                    }
                  } else if (void 0 !== u) {
                    const r = u[t];
                    if (void 0 !== r)
                      switch (r.length) {
                        case 2:
                          e.vertexAttrib2fv(o.location, r);
                          break;
                        case 3:
                          e.vertexAttrib3fv(o.location, r);
                          break;
                        case 4:
                          e.vertexAttrib4fv(o.location, r);
                          break;
                        default:
                          e.vertexAttrib1fv(o.location, r);
                      }
                  }
                }
              }
              _();
            })(i, l, d, y),
            null !== b &&
              e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, r.get(b).buffer));
      },
      reset: y,
      resetDefaultState: b,
      dispose: function () {
        y();
        for (const e in a) {
          const t = a[e];
          for (const e in t) {
            const r = t[e];
            for (const e in r) d(r[e].object), delete r[e];
            delete t[e];
          }
          delete a[e];
        }
      },
      releaseStatesOfGeometry: function (e) {
        if (void 0 === a[e.id]) return;
        const t = a[e.id];
        for (const e in t) {
          const r = t[e];
          for (const e in r) d(r[e].object), delete r[e];
          delete t[e];
        }
        delete a[e.id];
      },
      releaseStatesOfProgram: function (e) {
        for (const t in a) {
          const r = a[t];
          if (void 0 === r[e.id]) continue;
          const n = r[e.id];
          for (const e in n) d(n[e].object), delete n[e];
          delete r[e.id];
        }
      },
      initAttributes: f,
      enableAttribute: m,
      disableUnusedAttributes: _,
    };
  }
  function zn(e, t, r, n) {
    const i = n.isWebGL2;
    let o;
    (this.setMode = function (e) {
      o = e;
    }),
      (this.render = function (t, n) {
        e.drawArrays(o, t, n), r.update(n, o, 1);
      }),
      (this.renderInstances = function (n, s, a) {
        if (0 === a) return;
        let l, c;
        if (i) (l = e), (c = "drawArraysInstanced");
        else if (
          ((l = t.get("ANGLE_instanced_arrays")),
          (c = "drawArraysInstancedANGLE"),
          null === l)
        )
          return void console.error(
            "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
          );
        l[c](o, n, s, a), r.update(s, o, a);
      }),
      (this.renderMultiDraw = function (e, n, i) {
        if (0 === i) return;
        const s = t.get("WEBGL_multi_draw");
        if (null === s) for (let t = 0; t < i; t++) this.render(e[t], n[t]);
        else {
          s.multiDrawArraysWEBGL(o, e, 0, n, 0, i);
          let t = 0;
          for (let e = 0; e < i; e++) t += n[e];
          r.update(t, o, 1);
        }
      });
  }
  function Vn(e, t, r) {
    let n;
    function i(t) {
      if ("highp" === t) {
        if (
          e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision >
            0 &&
          e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT)
            .precision > 0
        )
          return "highp";
        t = "mediump";
      }
      return "mediump" === t &&
        e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision >
          0 &&
        e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT)
          .precision > 0
        ? "mediump"
        : "lowp";
    }
    const o =
      "undefined" != typeof WebGL2RenderingContext &&
      "WebGL2RenderingContext" === e.constructor.name;
    let s = void 0 !== r.precision ? r.precision : "highp";
    const a = i(s);
    a !== s &&
      (console.warn(
        "THREE.WebGLRenderer:",
        s,
        "not supported, using",
        a,
        "instead."
      ),
      (s = a));
    const l = o || t.has("WEBGL_draw_buffers"),
      c = !0 === r.logarithmicDepthBuffer,
      u = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
      h = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
      d = e.getParameter(e.MAX_TEXTURE_SIZE),
      p = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
      f = e.getParameter(e.MAX_VERTEX_ATTRIBS),
      m = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
      g = e.getParameter(e.MAX_VARYING_VECTORS),
      _ = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
      v = h > 0,
      y = o || t.has("OES_texture_float");
    return {
      isWebGL2: o,
      drawBuffers: l,
      getMaxAnisotropy: function () {
        if (void 0 !== n) return n;
        if (!0 === t.has("EXT_texture_filter_anisotropic")) {
          const r = t.get("EXT_texture_filter_anisotropic");
          n = e.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else n = 0;
        return n;
      },
      getMaxPrecision: i,
      precision: s,
      logarithmicDepthBuffer: c,
      maxTextures: u,
      maxVertexTextures: h,
      maxTextureSize: d,
      maxCubemapSize: p,
      maxAttributes: f,
      maxVertexUniforms: m,
      maxVaryings: g,
      maxFragmentUniforms: _,
      vertexTextures: v,
      floatFragmentTextures: y,
      floatVertexTextures: v && y,
      maxSamples: o ? e.getParameter(e.MAX_SAMPLES) : 0,
    };
  }
  function jn(e) {
    const t = this;
    let r = null,
      n = 0,
      i = !1,
      o = !1;
    const s = new Rn(),
      a = new ke(),
      l = { value: null, needsUpdate: !1 };
    function c(e, r, n, i) {
      const o = null !== e ? e.length : 0;
      let c = null;
      if (0 !== o) {
        if (((c = l.value), !0 !== i || null === c)) {
          const t = n + 4 * o,
            i = r.matrixWorldInverse;
          a.getNormalMatrix(i),
            (null === c || c.length < t) && (c = new Float32Array(t));
          for (let t = 0, r = n; t !== o; ++t, r += 4)
            s.copy(e[t]).applyMatrix4(i, a),
              s.normal.toArray(c, r),
              (c[r + 3] = s.constant);
        }
        (l.value = c), (l.needsUpdate = !0);
      }
      return (t.numPlanes = o), (t.numIntersection = 0), c;
    }
    (this.uniform = l),
      (this.numPlanes = 0),
      (this.numIntersection = 0),
      (this.init = function (e, t) {
        const r = 0 !== e.length || t || 0 !== n || i;
        return (i = t), (n = e.length), r;
      }),
      (this.beginShadows = function () {
        (o = !0), c(null);
      }),
      (this.endShadows = function () {
        o = !1;
      }),
      (this.setGlobalState = function (e, t) {
        r = c(e, t, 0);
      }),
      (this.setState = function (s, a, u) {
        const h = s.clippingPlanes,
          d = s.clipIntersection,
          p = s.clipShadows,
          f = e.get(s);
        if (!i || null === h || 0 === h.length || (o && !p))
          o
            ? c(null)
            : (l.value !== r && ((l.value = r), (l.needsUpdate = n > 0)),
              (t.numPlanes = n),
              (t.numIntersection = 0));
        else {
          const e = o ? 0 : n,
            t = 4 * e;
          let i = f.clippingState || null;
          (l.value = i), (i = c(h, a, t, u));
          for (let e = 0; e !== t; ++e) i[e] = r[e];
          (f.clippingState = i),
            (this.numIntersection = d ? this.numPlanes : 0),
            (this.numPlanes += e);
        }
      });
  }
  function Wn(e) {
    let t = new WeakMap();
    function r(e, t) {
      return 303 === t ? (e.mapping = E) : 304 === t && (e.mapping = M), e;
    }
    function n(e) {
      const r = e.target;
      r.removeEventListener("dispose", n);
      const i = t.get(r);
      void 0 !== i && (t.delete(r), i.dispose());
    }
    return {
      get: function (i) {
        if (i && i.isTexture) {
          const o = i.mapping;
          if (303 === o || 304 === o) {
            if (t.has(i)) return r(t.get(i).texture, i.mapping);
            {
              const o = i.image;
              if (o && o.height > 0) {
                const s = new En(o.height / 2);
                return (
                  s.fromEquirectangularTexture(e, i),
                  t.set(i, s),
                  i.addEventListener("dispose", n),
                  r(s.texture, i.mapping)
                );
              }
              return null;
            }
          }
        }
        return i;
      },
      dispose: function () {
        t = new WeakMap();
      },
    };
  }
  class Gn extends yn {
    constructor(e = -1, t = 1, r = 1, n = -1, i = 0.1, o = 2e3) {
      super(),
        (this.isOrthographicCamera = !0),
        (this.type = "OrthographicCamera"),
        (this.zoom = 1),
        (this.view = null),
        (this.left = e),
        (this.right = t),
        (this.top = r),
        (this.bottom = n),
        (this.near = i),
        (this.far = o),
        this.updateProjectionMatrix();
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        (this.left = e.left),
        (this.right = e.right),
        (this.top = e.top),
        (this.bottom = e.bottom),
        (this.near = e.near),
        (this.far = e.far),
        (this.zoom = e.zoom),
        (this.view = null === e.view ? null : Object.assign({}, e.view)),
        this
      );
    }
    setViewOffset(e, t, r, n, i, o) {
      null === this.view &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
        (this.view.enabled = !0),
        (this.view.fullWidth = e),
        (this.view.fullHeight = t),
        (this.view.offsetX = r),
        (this.view.offsetY = n),
        (this.view.width = i),
        (this.view.height = o),
        this.updateProjectionMatrix();
    }
    clearViewOffset() {
      null !== this.view && (this.view.enabled = !1),
        this.updateProjectionMatrix();
    }
    updateProjectionMatrix() {
      const e = (this.right - this.left) / (2 * this.zoom),
        t = (this.top - this.bottom) / (2 * this.zoom),
        r = (this.right + this.left) / 2,
        n = (this.top + this.bottom) / 2;
      let i = r - e,
        o = r + e,
        s = n + t,
        a = n - t;
      if (null !== this.view && this.view.enabled) {
        const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
          t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
        (i += e * this.view.offsetX),
          (o = i + e * this.view.width),
          (s -= t * this.view.offsetY),
          (a = s - t * this.view.height);
      }
      this.projectionMatrix.makeOrthographic(
        i,
        o,
        s,
        a,
        this.near,
        this.far,
        this.coordinateSystem
      ),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return (
        (t.object.zoom = this.zoom),
        (t.object.left = this.left),
        (t.object.right = this.right),
        (t.object.top = this.top),
        (t.object.bottom = this.bottom),
        (t.object.near = this.near),
        (t.object.far = this.far),
        null !== this.view && (t.object.view = Object.assign({}, this.view)),
        t
      );
    }
  }
  const Xn = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
    qn = new Gn(),
    Yn = new Rr();
  let Kn = null,
    $n = 0,
    Qn = 0;
  const Jn = (1 + Math.sqrt(5)) / 2,
    Zn = 1 / Jn,
    ei = [
      new ut(1, 1, 1),
      new ut(-1, 1, 1),
      new ut(1, 1, -1),
      new ut(-1, 1, -1),
      new ut(0, Jn, Zn),
      new ut(0, Jn, -Zn),
      new ut(Zn, 0, Jn),
      new ut(-Zn, 0, Jn),
      new ut(Jn, Zn, 0),
      new ut(-Jn, Zn, 0),
    ];
  class ti {
    constructor(e) {
      (this._renderer = e),
        (this._pingPongRenderTarget = null),
        (this._lodMax = 0),
        (this._cubeSize = 0),
        (this._lodPlanes = []),
        (this._sizeLods = []),
        (this._sigmas = []),
        (this._blurMaterial = null),
        (this._cubemapMaterial = null),
        (this._equirectMaterial = null),
        this._compileMaterial(this._blurMaterial);
    }
    fromScene(e, t = 0, r = 0.1, n = 100) {
      (Kn = this._renderer.getRenderTarget()),
        ($n = this._renderer.getActiveCubeFace()),
        (Qn = this._renderer.getActiveMipmapLevel()),
        this._setSize(256);
      const i = this._allocateTargets();
      return (
        (i.depthBuffer = !0),
        this._sceneToCubeUV(e, r, n, i),
        t > 0 && this._blur(i, 0, 0, t),
        this._applyPMREM(i),
        this._cleanup(i),
        i
      );
    }
    fromEquirectangular(e, t = null) {
      return this._fromTexture(e, t);
    }
    fromCubemap(e, t = null) {
      return this._fromTexture(e, t);
    }
    compileCubemapShader() {
      null === this._cubemapMaterial &&
        ((this._cubemapMaterial = oi()),
        this._compileMaterial(this._cubemapMaterial));
    }
    compileEquirectangularShader() {
      null === this._equirectMaterial &&
        ((this._equirectMaterial = ii()),
        this._compileMaterial(this._equirectMaterial));
    }
    dispose() {
      this._dispose(),
        null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
        null !== this._equirectMaterial && this._equirectMaterial.dispose();
    }
    _setSize(e) {
      (this._lodMax = Math.floor(Math.log2(e))),
        (this._cubeSize = Math.pow(2, this._lodMax));
    }
    _dispose() {
      null !== this._blurMaterial && this._blurMaterial.dispose(),
        null !== this._pingPongRenderTarget &&
          this._pingPongRenderTarget.dispose();
      for (let e = 0; e < this._lodPlanes.length; e++)
        this._lodPlanes[e].dispose();
    }
    _cleanup(e) {
      this._renderer.setRenderTarget(Kn, $n, Qn),
        (e.scissorTest = !1),
        ni(e, 0, 0, e.width, e.height);
    }
    _fromTexture(e, t) {
      e.mapping === E || e.mapping === M
        ? this._setSize(
            0 === e.image.length
              ? 16
              : e.image[0].width || e.image[0].image.width
          )
        : this._setSize(e.image.width / 4),
        (Kn = this._renderer.getRenderTarget()),
        ($n = this._renderer.getActiveCubeFace()),
        (Qn = this._renderer.getActiveMipmapLevel());
      const r = t || this._allocateTargets();
      return (
        this._textureToCubeUV(e, r), this._applyPMREM(r), this._cleanup(r), r
      );
    }
    _allocateTargets() {
      const e = 3 * Math.max(this._cubeSize, 112),
        t = 4 * this._cubeSize,
        r = {
          magFilter: O,
          minFilter: O,
          generateMipmaps: !1,
          type: H,
          format: V,
          colorSpace: re,
          depthBuffer: !1,
        },
        n = ri(e, t, r);
      if (
        null === this._pingPongRenderTarget ||
        this._pingPongRenderTarget.width !== e ||
        this._pingPongRenderTarget.height !== t
      ) {
        null !== this._pingPongRenderTarget && this._dispose(),
          (this._pingPongRenderTarget = ri(e, t, r));
        const { _lodMax: n } = this;
        ({
          sizeLods: this._sizeLods,
          lodPlanes: this._lodPlanes,
          sigmas: this._sigmas,
        } = (function (e) {
          const t = [],
            r = [],
            n = [];
          let i = e;
          const o = e - 4 + 1 + Xn.length;
          for (let s = 0; s < o; s++) {
            const o = Math.pow(2, i);
            r.push(o);
            let a = 1 / o;
            s > e - 4 ? (a = Xn[s - e + 4 - 1]) : 0 === s && (a = 0), n.push(a);
            const l = 1 / (o - 2),
              c = -l,
              u = 1 + l,
              h = [c, c, u, c, u, u, c, c, u, u, c, u],
              d = 6,
              p = 6,
              f = 3,
              m = 2,
              g = 1,
              _ = new Float32Array(f * p * d),
              v = new Float32Array(m * p * d),
              y = new Float32Array(g * p * d);
            for (let e = 0; e < d; e++) {
              const t = ((e % 3) * 2) / 3 - 1,
                r = e > 2 ? 0 : -1,
                n = [
                  t,
                  r,
                  0,
                  t + 2 / 3,
                  r,
                  0,
                  t + 2 / 3,
                  r + 1,
                  0,
                  t,
                  r,
                  0,
                  t + 2 / 3,
                  r + 1,
                  0,
                  t,
                  r + 1,
                  0,
                ];
              _.set(n, f * p * e), v.set(h, m * p * e);
              const i = [e, e, e, e, e, e];
              y.set(i, g * p * e);
            }
            const b = new Xr();
            b.setAttribute("position", new Ur(_, f)),
              b.setAttribute("uv", new Ur(v, m)),
              b.setAttribute("faceIndex", new Ur(y, g)),
              t.push(b),
              i > 4 && i--;
          }
          return { lodPlanes: t, sizeLods: r, sigmas: n };
        })(n)),
          (this._blurMaterial = (function (e, t, r) {
            const n = new Float32Array(20),
              i = new ut(0, 1, 0);
            return new vn({
              name: "SphericalGaussianBlur",
              defines: {
                n: 20,
                CUBEUV_TEXEL_WIDTH: 1 / t,
                CUBEUV_TEXEL_HEIGHT: 1 / r,
                CUBEUV_MAX_MIP: `${e}.0`,
              },
              uniforms: {
                envMap: { value: null },
                samples: { value: 1 },
                weights: { value: n },
                latitudinal: { value: !1 },
                dTheta: { value: 0 },
                mipInt: { value: 0 },
                poleAxis: { value: i },
              },
              vertexShader:
                "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
              fragmentShader:
                "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
              blending: 0,
              depthTest: !1,
              depthWrite: !1,
            });
          })(n, e, t));
      }
      return n;
    }
    _compileMaterial(e) {
      const t = new hn(this._lodPlanes[0], e);
      this._renderer.compile(t, qn);
    }
    _sceneToCubeUV(e, t, r, n) {
      const i = new bn(90, 1, t, r),
        o = [1, -1, 1, 1, 1, 1],
        s = [1, 1, 1, -1, -1, -1],
        a = this._renderer,
        l = a.autoClear,
        c = a.toneMapping;
      a.getClearColor(Yn), (a.toneMapping = 0), (a.autoClear = !1);
      const u = new Lr({
          name: "PMREM.Background",
          side: 1,
          depthWrite: !1,
          depthTest: !1,
        }),
        h = new hn(new pn(), u);
      let d = !1;
      const p = e.background;
      p
        ? p.isColor && (u.color.copy(p), (e.background = null), (d = !0))
        : (u.color.copy(Yn), (d = !0));
      for (let t = 0; t < 6; t++) {
        const r = t % 3;
        0 === r
          ? (i.up.set(0, o[t], 0), i.lookAt(s[t], 0, 0))
          : 1 === r
          ? (i.up.set(0, 0, o[t]), i.lookAt(0, s[t], 0))
          : (i.up.set(0, o[t], 0), i.lookAt(0, 0, s[t]));
        const l = this._cubeSize;
        ni(n, r * l, t > 2 ? l : 0, l, l),
          a.setRenderTarget(n),
          d && a.render(h, i),
          a.render(e, i);
      }
      h.geometry.dispose(),
        h.material.dispose(),
        (a.toneMapping = c),
        (a.autoClear = l),
        (e.background = p);
    }
    _textureToCubeUV(e, t) {
      const r = this._renderer,
        n = e.mapping === E || e.mapping === M;
      n
        ? (null === this._cubemapMaterial && (this._cubemapMaterial = oi()),
          (this._cubemapMaterial.uniforms.flipEnvMap.value =
            !1 === e.isRenderTargetTexture ? -1 : 1))
        : null === this._equirectMaterial && (this._equirectMaterial = ii());
      const i = n ? this._cubemapMaterial : this._equirectMaterial,
        o = new hn(this._lodPlanes[0], i);
      i.uniforms.envMap.value = e;
      const s = this._cubeSize;
      ni(t, 0, 0, 3 * s, 2 * s), r.setRenderTarget(t), r.render(o, qn);
    }
    _applyPMREM(e) {
      const t = this._renderer,
        r = t.autoClear;
      t.autoClear = !1;
      for (let t = 1; t < this._lodPlanes.length; t++) {
        const r = Math.sqrt(
            this._sigmas[t] * this._sigmas[t] -
              this._sigmas[t - 1] * this._sigmas[t - 1]
          ),
          n = ei[(t - 1) % ei.length];
        this._blur(e, t - 1, t, r, n);
      }
      t.autoClear = r;
    }
    _blur(e, t, r, n, i) {
      const o = this._pingPongRenderTarget;
      this._halfBlur(e, o, t, r, n, "latitudinal", i),
        this._halfBlur(o, e, r, r, n, "longitudinal", i);
    }
    _halfBlur(e, t, r, n, i, o, s) {
      const a = this._renderer,
        l = this._blurMaterial;
      "latitudinal" !== o &&
        "longitudinal" !== o &&
        console.error(
          "blur direction must be either latitudinal or longitudinal!"
        );
      const c = new hn(this._lodPlanes[n], l),
        u = l.uniforms,
        h = this._sizeLods[r] - 1,
        d = isFinite(i) ? Math.PI / (2 * h) : (2 * Math.PI) / 39,
        p = i / d,
        f = isFinite(i) ? 1 + Math.floor(3 * p) : 20;
      f > 20 &&
        console.warn(
          `sigmaRadians, ${i}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`
        );
      const m = [];
      let g = 0;
      for (let e = 0; e < 20; ++e) {
        const t = e / p,
          r = Math.exp((-t * t) / 2);
        m.push(r), 0 === e ? (g += r) : e < f && (g += 2 * r);
      }
      for (let e = 0; e < m.length; e++) m[e] = m[e] / g;
      (u.envMap.value = e.texture),
        (u.samples.value = f),
        (u.weights.value = m),
        (u.latitudinal.value = "latitudinal" === o),
        s && (u.poleAxis.value = s);
      const { _lodMax: _ } = this;
      (u.dTheta.value = d), (u.mipInt.value = _ - r);
      const v = this._sizeLods[n];
      ni(
        t,
        3 * v * (n > _ - 4 ? n - _ + 4 : 0),
        4 * (this._cubeSize - v),
        3 * v,
        2 * v
      ),
        a.setRenderTarget(t),
        a.render(c, qn);
    }
  }
  function ri(e, t, r) {
    const n = new st(e, t, r);
    return (
      (n.texture.mapping = T),
      (n.texture.name = "PMREM.cubeUv"),
      (n.scissorTest = !0),
      n
    );
  }
  function ni(e, t, r, n, i) {
    e.viewport.set(t, r, n, i), e.scissor.set(t, r, n, i);
  }
  function ii() {
    return new vn({
      name: "EquirectangularToCubeUV",
      uniforms: { envMap: { value: null } },
      vertexShader:
        "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
      fragmentShader:
        "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
      blending: 0,
      depthTest: !1,
      depthWrite: !1,
    });
  }
  function oi() {
    return new vn({
      name: "CubemapToCubeUV",
      uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
      vertexShader:
        "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
      fragmentShader:
        "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
      blending: 0,
      depthTest: !1,
      depthWrite: !1,
    });
  }
  function si(e) {
    let t = new WeakMap(),
      r = null;
    function n(e) {
      const r = e.target;
      r.removeEventListener("dispose", n);
      const i = t.get(r);
      void 0 !== i && (t.delete(r), i.dispose());
    }
    return {
      get: function (i) {
        if (i && i.isTexture) {
          const o = i.mapping,
            s = 303 === o || 304 === o,
            a = o === E || o === M;
          if (s || a) {
            if (i.isRenderTargetTexture && !0 === i.needsPMREMUpdate) {
              i.needsPMREMUpdate = !1;
              let n = t.get(i);
              return (
                null === r && (r = new ti(e)),
                (n = s ? r.fromEquirectangular(i, n) : r.fromCubemap(i, n)),
                t.set(i, n),
                n.texture
              );
            }
            if (t.has(i)) return t.get(i).texture;
            {
              const o = i.image;
              if (
                (s && o && o.height > 0) ||
                (a &&
                  o &&
                  (function (e) {
                    let t = 0;
                    for (let r = 0; r < 6; r++) void 0 !== e[r] && t++;
                    return 6 === t;
                  })(o))
              ) {
                null === r && (r = new ti(e));
                const o = s ? r.fromEquirectangular(i) : r.fromCubemap(i);
                return t.set(i, o), i.addEventListener("dispose", n), o.texture;
              }
              return null;
            }
          }
        }
        return i;
      },
      dispose: function () {
        (t = new WeakMap()), null !== r && (r.dispose(), (r = null));
      },
    };
  }
  function ai(e) {
    const t = {};
    function r(r) {
      if (void 0 !== t[r]) return t[r];
      let n;
      switch (r) {
        case "WEBGL_depth_texture":
          n =
            e.getExtension("WEBGL_depth_texture") ||
            e.getExtension("MOZ_WEBGL_depth_texture") ||
            e.getExtension("WEBKIT_WEBGL_depth_texture");
          break;
        case "EXT_texture_filter_anisotropic":
          n =
            e.getExtension("EXT_texture_filter_anisotropic") ||
            e.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
            e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
          break;
        case "WEBGL_compressed_texture_s3tc":
          n =
            e.getExtension("WEBGL_compressed_texture_s3tc") ||
            e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
            e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
          break;
        case "WEBGL_compressed_texture_pvrtc":
          n =
            e.getExtension("WEBGL_compressed_texture_pvrtc") ||
            e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
          break;
        default:
          n = e.getExtension(r);
      }
      return (t[r] = n), n;
    }
    return {
      has: function (e) {
        return null !== r(e);
      },
      init: function (e) {
        e.isWebGL2
          ? (r("EXT_color_buffer_float"), r("WEBGL_clip_cull_distance"))
          : (r("WEBGL_depth_texture"),
            r("OES_texture_float"),
            r("OES_texture_half_float"),
            r("OES_texture_half_float_linear"),
            r("OES_standard_derivatives"),
            r("OES_element_index_uint"),
            r("OES_vertex_array_object"),
            r("ANGLE_instanced_arrays")),
          r("OES_texture_float_linear"),
          r("EXT_color_buffer_half_float"),
          r("WEBGL_multisampled_render_to_texture");
      },
      get: function (e) {
        const t = r(e);
        return (
          null === t &&
            console.warn(
              "THREE.WebGLRenderer: " + e + " extension not supported."
            ),
          t
        );
      },
    };
  }
  function li(e, t, r, n) {
    const i = {},
      o = new WeakMap();
    function s(e) {
      const a = e.target;
      null !== a.index && t.remove(a.index);
      for (const e in a.attributes) t.remove(a.attributes[e]);
      for (const e in a.morphAttributes) {
        const r = a.morphAttributes[e];
        for (let e = 0, n = r.length; e < n; e++) t.remove(r[e]);
      }
      a.removeEventListener("dispose", s), delete i[a.id];
      const l = o.get(a);
      l && (t.remove(l), o.delete(a)),
        n.releaseStatesOfGeometry(a),
        !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
        r.memory.geometries--;
    }
    function a(e) {
      const r = [],
        n = e.index,
        i = e.attributes.position;
      let s = 0;
      if (null !== n) {
        const e = n.array;
        s = n.version;
        for (let t = 0, n = e.length; t < n; t += 3) {
          const n = e[t + 0],
            i = e[t + 1],
            o = e[t + 2];
          r.push(n, i, i, o, o, n);
        }
      } else {
        if (void 0 === i) return;
        {
          const e = i.array;
          s = i.version;
          for (let t = 0, n = e.length / 3 - 1; t < n; t += 3) {
            const e = t + 0,
              n = t + 1,
              i = t + 2;
            r.push(e, n, n, i, i, e);
          }
        }
      }
      const a = new (Fe(r) ? kr : Dr)(r, 1);
      a.version = s;
      const l = o.get(e);
      l && t.remove(l), o.set(e, a);
    }
    return {
      get: function (e, t) {
        return (
          !0 === i[t.id] ||
            (t.addEventListener("dispose", s),
            (i[t.id] = !0),
            r.memory.geometries++),
          t
        );
      },
      update: function (r) {
        const n = r.attributes;
        for (const r in n) t.update(n[r], e.ARRAY_BUFFER);
        const i = r.morphAttributes;
        for (const r in i) {
          const n = i[r];
          for (let r = 0, i = n.length; r < i; r++)
            t.update(n[r], e.ARRAY_BUFFER);
        }
      },
      getWireframeAttribute: function (e) {
        const t = o.get(e);
        if (t) {
          const r = e.index;
          null !== r && t.version < r.version && a(e);
        } else a(e);
        return o.get(e);
      },
    };
  }
  function ci(e, t, r, n) {
    const i = n.isWebGL2;
    let o, s, a;
    (this.setMode = function (e) {
      o = e;
    }),
      (this.setIndex = function (e) {
        (s = e.type), (a = e.bytesPerElement);
      }),
      (this.render = function (t, n) {
        e.drawElements(o, n, s, t * a), r.update(n, o, 1);
      }),
      (this.renderInstances = function (n, l, c) {
        if (0 === c) return;
        let u, h;
        if (i) (u = e), (h = "drawElementsInstanced");
        else if (
          ((u = t.get("ANGLE_instanced_arrays")),
          (h = "drawElementsInstancedANGLE"),
          null === u)
        )
          return void console.error(
            "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
          );
        u[h](o, l, s, n * a, c), r.update(l, o, c);
      }),
      (this.renderMultiDraw = function (e, n, i) {
        if (0 === i) return;
        const l = t.get("WEBGL_multi_draw");
        if (null === l) for (let t = 0; t < i; t++) this.render(e[t] / a, n[t]);
        else {
          l.multiDrawElementsWEBGL(o, n, 0, s, e, 0, i);
          let t = 0;
          for (let e = 0; e < i; e++) t += n[e];
          r.update(t, o, 1);
        }
      });
  }
  function ui(e) {
    const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return {
      memory: { geometries: 0, textures: 0 },
      render: t,
      programs: null,
      autoReset: !0,
      reset: function () {
        (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
      },
      update: function (r, n, i) {
        switch ((t.calls++, n)) {
          case e.TRIANGLES:
            t.triangles += i * (r / 3);
            break;
          case e.LINES:
            t.lines += i * (r / 2);
            break;
          case e.LINE_STRIP:
            t.lines += i * (r - 1);
            break;
          case e.LINE_LOOP:
            t.lines += i * r;
            break;
          case e.POINTS:
            t.points += i * r;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", n);
        }
      },
    };
  }
  function hi(e, t) {
    return e[0] - t[0];
  }
  function di(e, t) {
    return Math.abs(t[1]) - Math.abs(e[1]);
  }
  function pi(e, t, r) {
    const n = {},
      i = new Float32Array(8),
      o = new WeakMap(),
      s = new it(),
      a = [];
    for (let e = 0; e < 8; e++) a[e] = [e, 0];
    return {
      update: function (l, c, u) {
        const h = l.morphTargetInfluences;
        if (!0 === t.isWebGL2) {
          const d =
              c.morphAttributes.position ||
              c.morphAttributes.normal ||
              c.morphAttributes.color,
            p = void 0 !== d ? d.length : 0;
          let f = o.get(c);
          if (void 0 === f || f.count !== p) {
            void 0 !== f && f.texture.dispose();
            const _ = void 0 !== c.morphAttributes.position,
              v = void 0 !== c.morphAttributes.normal,
              y = void 0 !== c.morphAttributes.color,
              b = c.morphAttributes.position || [],
              x = c.morphAttributes.normal || [],
              w = c.morphAttributes.color || [];
            let S = 0;
            !0 === _ && (S = 1), !0 === v && (S = 2), !0 === y && (S = 3);
            let E = c.attributes.position.count * S,
              M = 1;
            E > t.maxTextureSize &&
              ((M = Math.ceil(E / t.maxTextureSize)), (E = t.maxTextureSize));
            const T = new Float32Array(E * M * 4 * p),
              A = new at(T, E, M, p);
            (A.type = F), (A.needsUpdate = !0);
            const R = 4 * S;
            for (let C = 0; C < p; C++) {
              const I = b[C],
                L = x[C],
                O = w[C],
                N = E * M * 4 * C;
              for (let U = 0; U < I.count; U++) {
                const D = U * R;
                !0 === _ &&
                  (s.fromBufferAttribute(I, U),
                  (T[N + D + 0] = s.x),
                  (T[N + D + 1] = s.y),
                  (T[N + D + 2] = s.z),
                  (T[N + D + 3] = 0)),
                  !0 === v &&
                    (s.fromBufferAttribute(L, U),
                    (T[N + D + 4] = s.x),
                    (T[N + D + 5] = s.y),
                    (T[N + D + 6] = s.z),
                    (T[N + D + 7] = 0)),
                  !0 === y &&
                    (s.fromBufferAttribute(O, U),
                    (T[N + D + 8] = s.x),
                    (T[N + D + 9] = s.y),
                    (T[N + D + 10] = s.z),
                    (T[N + D + 11] = 4 === O.itemSize ? s.w : 1));
              }
            }
            function P() {
              A.dispose(), o.delete(c), c.removeEventListener("dispose", P);
            }
            (f = { count: p, texture: A, size: new De(E, M) }),
              o.set(c, f),
              c.addEventListener("dispose", P);
          }
          let m = 0;
          for (let k = 0; k < h.length; k++) m += h[k];
          const g = c.morphTargetsRelative ? 1 : 1 - m;
          u.getUniforms().setValue(e, "morphTargetBaseInfluence", g),
            u.getUniforms().setValue(e, "morphTargetInfluences", h),
            u.getUniforms().setValue(e, "morphTargetsTexture", f.texture, r),
            u.getUniforms().setValue(e, "morphTargetsTextureSize", f.size);
        } else {
          const B = void 0 === h ? 0 : h.length;
          let H = n[c.id];
          if (void 0 === H || H.length !== B) {
            H = [];
            for (let G = 0; G < B; G++) H[G] = [G, 0];
            n[c.id] = H;
          }
          for (let X = 0; X < B; X++) {
            const q = H[X];
            (q[0] = X), (q[1] = h[X]);
          }
          H.sort(di);
          for (let Y = 0; Y < 8; Y++)
            Y < B && H[Y][1]
              ? ((a[Y][0] = H[Y][0]), (a[Y][1] = H[Y][1]))
              : ((a[Y][0] = Number.MAX_SAFE_INTEGER), (a[Y][1] = 0));
          a.sort(hi);
          const z = c.morphAttributes.position,
            V = c.morphAttributes.normal;
          let j = 0;
          for (let K = 0; K < 8; K++) {
            const $ = a[K],
              Q = $[0],
              J = $[1];
            Q !== Number.MAX_SAFE_INTEGER && J
              ? (z &&
                  c.getAttribute("morphTarget" + K) !== z[Q] &&
                  c.setAttribute("morphTarget" + K, z[Q]),
                V &&
                  c.getAttribute("morphNormal" + K) !== V[Q] &&
                  c.setAttribute("morphNormal" + K, V[Q]),
                (i[K] = J),
                (j += J))
              : (z &&
                  !0 === c.hasAttribute("morphTarget" + K) &&
                  c.deleteAttribute("morphTarget" + K),
                V &&
                  !0 === c.hasAttribute("morphNormal" + K) &&
                  c.deleteAttribute("morphNormal" + K),
                (i[K] = 0));
          }
          const W = c.morphTargetsRelative ? 1 : 1 - j;
          u.getUniforms().setValue(e, "morphTargetBaseInfluence", W),
            u.getUniforms().setValue(e, "morphTargetInfluences", i);
        }
      },
    };
  }
  function fi(e, t, r, n) {
    let i = new WeakMap();
    function o(e) {
      const t = e.target;
      t.removeEventListener("dispose", o),
        r.remove(t.instanceMatrix),
        null !== t.instanceColor && r.remove(t.instanceColor);
    }
    return {
      update: function (s) {
        const a = n.render.frame,
          l = s.geometry,
          c = t.get(s, l);
        if (
          (i.get(c) !== a && (t.update(c), i.set(c, a)),
          s.isInstancedMesh &&
            (!1 === s.hasEventListener("dispose", o) &&
              s.addEventListener("dispose", o),
            i.get(s) !== a &&
              (r.update(s.instanceMatrix, e.ARRAY_BUFFER),
              null !== s.instanceColor &&
                r.update(s.instanceColor, e.ARRAY_BUFFER),
              i.set(s, a))),
          s.isSkinnedMesh)
        ) {
          const e = s.skeleton;
          i.get(e) !== a && (e.update(), i.set(e, a));
        }
        return c;
      },
      dispose: function () {
        i = new WeakMap();
      },
    };
  }
  class mi extends nt {
    constructor(e, t, r, n, i, o, s, a, l, c) {
      if ((c = void 0 !== c ? c : j) !== j && c !== W)
        throw new Error(
          "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
        );
      void 0 === r && c === j && (r = B),
        void 0 === r && c === W && (r = z),
        super(null, n, i, o, s, a, c, r, l),
        (this.isDepthTexture = !0),
        (this.image = { width: e, height: t }),
        (this.magFilter = void 0 !== s ? s : C),
        (this.minFilter = void 0 !== a ? a : C),
        (this.flipY = !1),
        (this.generateMipmaps = !1),
        (this.compareFunction = null);
    }
    copy(e) {
      return super.copy(e), (this.compareFunction = e.compareFunction), this;
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return (
        null !== this.compareFunction &&
          (t.compareFunction = this.compareFunction),
        t
      );
    }
  }
  const gi = new nt(),
    _i = new mi(1, 1);
  _i.compareFunction = 515;
  const vi = new at(),
    yi = new lt(),
    bi = new Sn(),
    xi = [],
    wi = [],
    Si = new Float32Array(16),
    Ei = new Float32Array(9),
    Mi = new Float32Array(4);
  function Ti(e, t, r) {
    const n = e[0];
    if (n <= 0 || n > 0) return e;
    const i = t * r;
    let o = xi[i];
    if ((void 0 === o && ((o = new Float32Array(i)), (xi[i] = o)), 0 !== t)) {
      n.toArray(o, 0);
      for (let n = 1, i = 0; n !== t; ++n) (i += r), e[n].toArray(o, i);
    }
    return o;
  }
  function Ai(e, t) {
    if (e.length !== t.length) return !1;
    for (let r = 0, n = e.length; r < n; r++) if (e[r] !== t[r]) return !1;
    return !0;
  }
  function Ri(e, t) {
    for (let r = 0, n = t.length; r < n; r++) e[r] = t[r];
  }
  function Pi(e, t) {
    let r = wi[t];
    void 0 === r && ((r = new Int32Array(t)), (wi[t] = r));
    for (let n = 0; n !== t; ++n) r[n] = e.allocateTextureUnit();
    return r;
  }
  function Ci(e, t) {
    const r = this.cache;
    r[0] !== t && (e.uniform1f(this.addr, t), (r[0] = t));
  }
  function Ii(e, t) {
    const r = this.cache;
    if (void 0 !== t.x)
      (r[0] === t.x && r[1] === t.y) ||
        (e.uniform2f(this.addr, t.x, t.y), (r[0] = t.x), (r[1] = t.y));
    else {
      if (Ai(r, t)) return;
      e.uniform2fv(this.addr, t), Ri(r, t);
    }
  }
  function Li(e, t) {
    const r = this.cache;
    if (void 0 !== t.x)
      (r[0] === t.x && r[1] === t.y && r[2] === t.z) ||
        (e.uniform3f(this.addr, t.x, t.y, t.z),
        (r[0] = t.x),
        (r[1] = t.y),
        (r[2] = t.z));
    else if (void 0 !== t.r)
      (r[0] === t.r && r[1] === t.g && r[2] === t.b) ||
        (e.uniform3f(this.addr, t.r, t.g, t.b),
        (r[0] = t.r),
        (r[1] = t.g),
        (r[2] = t.b));
    else {
      if (Ai(r, t)) return;
      e.uniform3fv(this.addr, t), Ri(r, t);
    }
  }
  function Oi(e, t) {
    const r = this.cache;
    if (void 0 !== t.x)
      (r[0] === t.x && r[1] === t.y && r[2] === t.z && r[3] === t.w) ||
        (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
        (r[0] = t.x),
        (r[1] = t.y),
        (r[2] = t.z),
        (r[3] = t.w));
    else {
      if (Ai(r, t)) return;
      e.uniform4fv(this.addr, t), Ri(r, t);
    }
  }
  function Ni(e, t) {
    const r = this.cache,
      n = t.elements;
    if (void 0 === n) {
      if (Ai(r, t)) return;
      e.uniformMatrix2fv(this.addr, !1, t), Ri(r, t);
    } else {
      if (Ai(r, n)) return;
      Mi.set(n), e.uniformMatrix2fv(this.addr, !1, Mi), Ri(r, n);
    }
  }
  function Ui(e, t) {
    const r = this.cache,
      n = t.elements;
    if (void 0 === n) {
      if (Ai(r, t)) return;
      e.uniformMatrix3fv(this.addr, !1, t), Ri(r, t);
    } else {
      if (Ai(r, n)) return;
      Ei.set(n), e.uniformMatrix3fv(this.addr, !1, Ei), Ri(r, n);
    }
  }
  function Di(e, t) {
    const r = this.cache,
      n = t.elements;
    if (void 0 === n) {
      if (Ai(r, t)) return;
      e.uniformMatrix4fv(this.addr, !1, t), Ri(r, t);
    } else {
      if (Ai(r, n)) return;
      Si.set(n), e.uniformMatrix4fv(this.addr, !1, Si), Ri(r, n);
    }
  }
  function ki(e, t) {
    const r = this.cache;
    r[0] !== t && (e.uniform1i(this.addr, t), (r[0] = t));
  }
  function Bi(e, t) {
    const r = this.cache;
    if (void 0 !== t.x)
      (r[0] === t.x && r[1] === t.y) ||
        (e.uniform2i(this.addr, t.x, t.y), (r[0] = t.x), (r[1] = t.y));
    else {
      if (Ai(r, t)) return;
      e.uniform2iv(this.addr, t), Ri(r, t);
    }
  }
  function Fi(e, t) {
    const r = this.cache;
    if (void 0 !== t.x)
      (r[0] === t.x && r[1] === t.y && r[2] === t.z) ||
        (e.uniform3i(this.addr, t.x, t.y, t.z),
        (r[0] = t.x),
        (r[1] = t.y),
        (r[2] = t.z));
    else {
      if (Ai(r, t)) return;
      e.uniform3iv(this.addr, t), Ri(r, t);
    }
  }
  function Hi(e, t) {
    const r = this.cache;
    if (void 0 !== t.x)
      (r[0] === t.x && r[1] === t.y && r[2] === t.z && r[3] === t.w) ||
        (e.uniform4i(this.addr, t.x, t.y, t.z, t.w),
        (r[0] = t.x),
        (r[1] = t.y),
        (r[2] = t.z),
        (r[3] = t.w));
    else {
      if (Ai(r, t)) return;
      e.uniform4iv(this.addr, t), Ri(r, t);
    }
  }
  function zi(e, t) {
    const r = this.cache;
    r[0] !== t && (e.uniform1ui(this.addr, t), (r[0] = t));
  }
  function Vi(e, t) {
    const r = this.cache;
    if (void 0 !== t.x)
      (r[0] === t.x && r[1] === t.y) ||
        (e.uniform2ui(this.addr, t.x, t.y), (r[0] = t.x), (r[1] = t.y));
    else {
      if (Ai(r, t)) return;
      e.uniform2uiv(this.addr, t), Ri(r, t);
    }
  }
  function ji(e, t) {
    const r = this.cache;
    if (void 0 !== t.x)
      (r[0] === t.x && r[1] === t.y && r[2] === t.z) ||
        (e.uniform3ui(this.addr, t.x, t.y, t.z),
        (r[0] = t.x),
        (r[1] = t.y),
        (r[2] = t.z));
    else {
      if (Ai(r, t)) return;
      e.uniform3uiv(this.addr, t), Ri(r, t);
    }
  }
  function Wi(e, t) {
    const r = this.cache;
    if (void 0 !== t.x)
      (r[0] === t.x && r[1] === t.y && r[2] === t.z && r[3] === t.w) ||
        (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
        (r[0] = t.x),
        (r[1] = t.y),
        (r[2] = t.z),
        (r[3] = t.w));
    else {
      if (Ai(r, t)) return;
      e.uniform4uiv(this.addr, t), Ri(r, t);
    }
  }
  function Gi(e, t, r) {
    const n = this.cache,
      i = r.allocateTextureUnit();
    n[0] !== i && (e.uniform1i(this.addr, i), (n[0] = i));
    const o = this.type === e.SAMPLER_2D_SHADOW ? _i : gi;
    r.setTexture2D(t || o, i);
  }
  function Xi(e, t, r) {
    const n = this.cache,
      i = r.allocateTextureUnit();
    n[0] !== i && (e.uniform1i(this.addr, i), (n[0] = i)),
      r.setTexture3D(t || yi, i);
  }
  function qi(e, t, r) {
    const n = this.cache,
      i = r.allocateTextureUnit();
    n[0] !== i && (e.uniform1i(this.addr, i), (n[0] = i)),
      r.setTextureCube(t || bi, i);
  }
  function Yi(e, t, r) {
    const n = this.cache,
      i = r.allocateTextureUnit();
    n[0] !== i && (e.uniform1i(this.addr, i), (n[0] = i)),
      r.setTexture2DArray(t || vi, i);
  }
  function Ki(e, t) {
    e.uniform1fv(this.addr, t);
  }
  function $i(e, t) {
    const r = Ti(t, this.size, 2);
    e.uniform2fv(this.addr, r);
  }
  function Qi(e, t) {
    const r = Ti(t, this.size, 3);
    e.uniform3fv(this.addr, r);
  }
  function Ji(e, t) {
    const r = Ti(t, this.size, 4);
    e.uniform4fv(this.addr, r);
  }
  function Zi(e, t) {
    const r = Ti(t, this.size, 4);
    e.uniformMatrix2fv(this.addr, !1, r);
  }
  function eo(e, t) {
    const r = Ti(t, this.size, 9);
    e.uniformMatrix3fv(this.addr, !1, r);
  }
  function to(e, t) {
    const r = Ti(t, this.size, 16);
    e.uniformMatrix4fv(this.addr, !1, r);
  }
  function ro(e, t) {
    e.uniform1iv(this.addr, t);
  }
  function no(e, t) {
    e.uniform2iv(this.addr, t);
  }
  function io(e, t) {
    e.uniform3iv(this.addr, t);
  }
  function oo(e, t) {
    e.uniform4iv(this.addr, t);
  }
  function so(e, t) {
    e.uniform1uiv(this.addr, t);
  }
  function ao(e, t) {
    e.uniform2uiv(this.addr, t);
  }
  function lo(e, t) {
    e.uniform3uiv(this.addr, t);
  }
  function co(e, t) {
    e.uniform4uiv(this.addr, t);
  }
  function uo(e, t, r) {
    const n = this.cache,
      i = t.length,
      o = Pi(r, i);
    Ai(n, o) || (e.uniform1iv(this.addr, o), Ri(n, o));
    for (let e = 0; e !== i; ++e) r.setTexture2D(t[e] || gi, o[e]);
  }
  function ho(e, t, r) {
    const n = this.cache,
      i = t.length,
      o = Pi(r, i);
    Ai(n, o) || (e.uniform1iv(this.addr, o), Ri(n, o));
    for (let e = 0; e !== i; ++e) r.setTexture3D(t[e] || yi, o[e]);
  }
  function po(e, t, r) {
    const n = this.cache,
      i = t.length,
      o = Pi(r, i);
    Ai(n, o) || (e.uniform1iv(this.addr, o), Ri(n, o));
    for (let e = 0; e !== i; ++e) r.setTextureCube(t[e] || bi, o[e]);
  }
  function fo(e, t, r) {
    const n = this.cache,
      i = t.length,
      o = Pi(r, i);
    Ai(n, o) || (e.uniform1iv(this.addr, o), Ri(n, o));
    for (let e = 0; e !== i; ++e) r.setTexture2DArray(t[e] || vi, o[e]);
  }
  class mo {
    constructor(e, t, r) {
      (this.id = e),
        (this.addr = r),
        (this.cache = []),
        (this.type = t.type),
        (this.setValue = (function (e) {
          switch (e) {
            case 5126:
              return Ci;
            case 35664:
              return Ii;
            case 35665:
              return Li;
            case 35666:
              return Oi;
            case 35674:
              return Ni;
            case 35675:
              return Ui;
            case 35676:
              return Di;
            case 5124:
            case 35670:
              return ki;
            case 35667:
            case 35671:
              return Bi;
            case 35668:
            case 35672:
              return Fi;
            case 35669:
            case 35673:
              return Hi;
            case 5125:
              return zi;
            case 36294:
              return Vi;
            case 36295:
              return ji;
            case 36296:
              return Wi;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return Gi;
            case 35679:
            case 36299:
            case 36307:
              return Xi;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return qi;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return Yi;
          }
        })(t.type));
    }
  }
  class go {
    constructor(e, t, r) {
      (this.id = e),
        (this.addr = r),
        (this.cache = []),
        (this.type = t.type),
        (this.size = t.size),
        (this.setValue = (function (e) {
          switch (e) {
            case 5126:
              return Ki;
            case 35664:
              return $i;
            case 35665:
              return Qi;
            case 35666:
              return Ji;
            case 35674:
              return Zi;
            case 35675:
              return eo;
            case 35676:
              return to;
            case 5124:
            case 35670:
              return ro;
            case 35667:
            case 35671:
              return no;
            case 35668:
            case 35672:
              return io;
            case 35669:
            case 35673:
              return oo;
            case 5125:
              return so;
            case 36294:
              return ao;
            case 36295:
              return lo;
            case 36296:
              return co;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
              return uo;
            case 35679:
            case 36299:
            case 36307:
              return ho;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
              return po;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
              return fo;
          }
        })(t.type));
    }
  }
  class _o {
    constructor(e) {
      (this.id = e), (this.seq = []), (this.map = {});
    }
    setValue(e, t, r) {
      const n = this.seq;
      for (let i = 0, o = n.length; i !== o; ++i) {
        const o = n[i];
        o.setValue(e, t[o.id], r);
      }
    }
  }
  const vo = /(\w+)(\])?(\[|\.)?/g;
  function yo(e, t) {
    e.seq.push(t), (e.map[t.id] = t);
  }
  function bo(e, t, r) {
    const n = e.name,
      i = n.length;
    for (vo.lastIndex = 0; ; ) {
      const o = vo.exec(n),
        s = vo.lastIndex;
      let a = o[1];
      const l = "]" === o[2],
        c = o[3];
      if ((l && (a |= 0), void 0 === c || ("[" === c && s + 2 === i))) {
        yo(r, void 0 === c ? new mo(a, e, t) : new go(a, e, t));
        break;
      }
      {
        let e = r.map[a];
        void 0 === e && ((e = new _o(a)), yo(r, e)), (r = e);
      }
    }
  }
  class xo {
    constructor(e, t) {
      (this.seq = []), (this.map = {});
      const r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
      for (let n = 0; n < r; ++n) {
        const r = e.getActiveUniform(t, n);
        bo(r, e.getUniformLocation(t, r.name), this);
      }
    }
    setValue(e, t, r, n) {
      const i = this.map[t];
      void 0 !== i && i.setValue(e, r, n);
    }
    setOptional(e, t, r) {
      const n = t[r];
      void 0 !== n && this.setValue(e, r, n);
    }
    static upload(e, t, r, n) {
      for (let i = 0, o = t.length; i !== o; ++i) {
        const o = t[i],
          s = r[o.id];
        !1 !== s.needsUpdate && o.setValue(e, s.value, n);
      }
    }
    static seqWithValue(e, t) {
      const r = [];
      for (let n = 0, i = e.length; n !== i; ++n) {
        const i = e[n];
        i.id in t && r.push(i);
      }
      return r;
    }
  }
  function wo(e, t, r) {
    const n = e.createShader(t);
    return e.shaderSource(n, r), e.compileShader(n), n;
  }
  let So = 0;
  function Eo(e, t, r) {
    const n = e.getShaderParameter(t, e.COMPILE_STATUS),
      i = e.getShaderInfoLog(t).trim();
    if (n && "" === i) return "";
    const o = /ERROR: 0:(\d+)/.exec(i);
    if (o) {
      const n = parseInt(o[1]);
      return (
        r.toUpperCase() +
        "\n\n" +
        i +
        "\n\n" +
        (function (e, t) {
          const r = e.split("\n"),
            n = [],
            i = Math.max(t - 6, 0),
            o = Math.min(t + 6, r.length);
          for (let e = i; e < o; e++) {
            const i = e + 1;
            n.push(`${i === t ? ">" : " "} ${i}: ${r[e]}`);
          }
          return n.join("\n");
        })(e.getShaderSource(t), n)
      );
    }
    return i;
  }
  function Mo(e, t) {
    const r = (function (e) {
      const t = Ye.getPrimaries(Ye.workingColorSpace),
        r = Ye.getPrimaries(e);
      let n;
      switch (
        (t === r
          ? (n = "")
          : t === le && r === ae
          ? (n = "LinearDisplayP3ToLinearSRGB")
          : t === ae && r === le && (n = "LinearSRGBToLinearDisplayP3"),
        e)
      ) {
        case re:
        case ie:
          return [n, "LinearTransferOETF"];
        case te:
        case ne:
          return [n, "sRGBTransferOETF"];
        default:
          return (
            console.warn("THREE.WebGLProgram: Unsupported color space:", e),
            [n, "LinearTransferOETF"]
          );
      }
    })(t);
    return `vec4 ${e}( vec4 value ) { return ${r[0]}( ${r[1]}( value ) ); }`;
  }
  function To(e, t) {
    let r;
    switch (t) {
      case 1:
        r = "Linear";
        break;
      case 2:
        r = "Reinhard";
        break;
      case 3:
        r = "OptimizedCineon";
        break;
      case 4:
        r = "ACESFilmic";
        break;
      case 6:
        r = "AgX";
        break;
      case 5:
        r = "Custom";
        break;
      default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
          (r = "Linear");
    }
    return (
      "vec3 " + e + "( vec3 color ) { return " + r + "ToneMapping( color ); }"
    );
  }
  function Ao(e) {
    return "" !== e;
  }
  function Ro(e, t) {
    const r =
      t.numSpotLightShadows +
      t.numSpotLightMaps -
      t.numSpotLightShadowsWithMaps;
    return e
      .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
      .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
      .replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps)
      .replace(/NUM_SPOT_LIGHT_COORDS/g, r)
      .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
      .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
      .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
      .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
      .replace(
        /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
        t.numSpotLightShadowsWithMaps
      )
      .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
      .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
  }
  function Po(e, t) {
    return e
      .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
      .replace(
        /UNION_CLIPPING_PLANES/g,
        t.numClippingPlanes - t.numClipIntersection
      );
  }
  const Co = /^[ \t]*#include +<([\w\d./]+)>/gm;
  function Io(e) {
    return e.replace(Co, Oo);
  }
  const Lo = new Map([
    ["encodings_fragment", "colorspace_fragment"],
    ["encodings_pars_fragment", "colorspace_pars_fragment"],
    ["output_fragment", "opaque_fragment"],
  ]);
  function Oo(e, t) {
    let r = Un[t];
    if (void 0 === r) {
      const e = Lo.get(t);
      if (void 0 === e) throw new Error("Can not resolve #include <" + t + ">");
      (r = Un[e]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          t,
          e
        );
    }
    return Io(r);
  }
  const No =
    /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
  function Uo(e) {
    return e.replace(No, Do);
  }
  function Do(e, t, r, n) {
    let i = "";
    for (let e = parseInt(t); e < parseInt(r); e++)
      i += n
        .replace(/\[\s*i\s*\]/g, "[ " + e + " ]")
        .replace(/UNROLLED_LOOP_INDEX/g, e);
    return i;
  }
  function ko(e) {
    let t =
      "precision " +
      e.precision +
      " float;\nprecision " +
      e.precision +
      " int;";
    return (
      "highp" === e.precision
        ? (t += "\n#define HIGH_PRECISION")
        : "mediump" === e.precision
        ? (t += "\n#define MEDIUM_PRECISION")
        : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
      t
    );
  }
  function Bo(e, t, r, n) {
    const i = e.getContext(),
      o = r.defines;
    let s = r.vertexShader,
      a = r.fragmentShader;
    const l = (function (e) {
        let t = "SHADOWMAP_TYPE_BASIC";
        return (
          1 === e.shadowMapType
            ? (t = "SHADOWMAP_TYPE_PCF")
            : 2 === e.shadowMapType
            ? (t = "SHADOWMAP_TYPE_PCF_SOFT")
            : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"),
          t
        );
      })(r),
      c = (function (e) {
        let t = "ENVMAP_TYPE_CUBE";
        if (e.envMap)
          switch (e.envMapMode) {
            case E:
            case M:
              t = "ENVMAP_TYPE_CUBE";
              break;
            case T:
              t = "ENVMAP_TYPE_CUBE_UV";
          }
        return t;
      })(r),
      u = (function (e) {
        let t = "ENVMAP_MODE_REFLECTION";
        return (
          e.envMap && e.envMapMode === M && (t = "ENVMAP_MODE_REFRACTION"), t
        );
      })(r),
      h = (function (e) {
        let t = "ENVMAP_BLENDING_NONE";
        if (e.envMap)
          switch (e.combine) {
            case 0:
              t = "ENVMAP_BLENDING_MULTIPLY";
              break;
            case 1:
              t = "ENVMAP_BLENDING_MIX";
              break;
            case 2:
              t = "ENVMAP_BLENDING_ADD";
          }
        return t;
      })(r),
      d = (function (e) {
        const t = e.envMapCubeUVHeight;
        if (null === t) return null;
        const r = Math.log2(t) - 2,
          n = 1 / t;
        return {
          texelWidth: 1 / (3 * Math.max(Math.pow(2, r), 112)),
          texelHeight: n,
          maxMip: r,
        };
      })(r),
      p = r.isWebGL2
        ? ""
        : (function (e) {
            return [
              e.extensionDerivatives ||
              e.envMapCubeUVHeight ||
              e.bumpMap ||
              e.normalMapTangentSpace ||
              e.clearcoatNormalMap ||
              e.flatShading ||
              "physical" === e.shaderID
                ? "#extension GL_OES_standard_derivatives : enable"
                : "",
              (e.extensionFragDepth || e.logarithmicDepthBuffer) &&
              e.rendererExtensionFragDepth
                ? "#extension GL_EXT_frag_depth : enable"
                : "",
              e.extensionDrawBuffers && e.rendererExtensionDrawBuffers
                ? "#extension GL_EXT_draw_buffers : require"
                : "",
              (e.extensionShaderTextureLOD || e.envMap || e.transmission) &&
              e.rendererExtensionShaderTextureLod
                ? "#extension GL_EXT_shader_texture_lod : enable"
                : "",
            ]
              .filter(Ao)
              .join("\n");
          })(r),
      f = (function (e) {
        return [
          e.extensionClipCullDistance
            ? "#extension GL_ANGLE_clip_cull_distance : require"
            : "",
        ]
          .filter(Ao)
          .join("\n");
      })(r),
      m = (function (e) {
        const t = [];
        for (const r in e) {
          const n = e[r];
          !1 !== n && t.push("#define " + r + " " + n);
        }
        return t.join("\n");
      })(o),
      g = i.createProgram();
    let _,
      v,
      y = r.glslVersion ? "#version " + r.glslVersion + "\n" : "";
    r.isRawShaderMaterial
      ? ((_ = [
          "#define SHADER_TYPE " + r.shaderType,
          "#define SHADER_NAME " + r.shaderName,
          m,
        ]
          .filter(Ao)
          .join("\n")),
        _.length > 0 && (_ += "\n"),
        (v = [
          p,
          "#define SHADER_TYPE " + r.shaderType,
          "#define SHADER_NAME " + r.shaderName,
          m,
        ]
          .filter(Ao)
          .join("\n")),
        v.length > 0 && (v += "\n"))
      : ((_ = [
          ko(r),
          "#define SHADER_TYPE " + r.shaderType,
          "#define SHADER_NAME " + r.shaderName,
          m,
          r.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
          r.batching ? "#define USE_BATCHING" : "",
          r.instancing ? "#define USE_INSTANCING" : "",
          r.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
          r.useFog && r.fog ? "#define USE_FOG" : "",
          r.useFog && r.fogExp2 ? "#define FOG_EXP2" : "",
          r.map ? "#define USE_MAP" : "",
          r.envMap ? "#define USE_ENVMAP" : "",
          r.envMap ? "#define " + u : "",
          r.lightMap ? "#define USE_LIGHTMAP" : "",
          r.aoMap ? "#define USE_AOMAP" : "",
          r.bumpMap ? "#define USE_BUMPMAP" : "",
          r.normalMap ? "#define USE_NORMALMAP" : "",
          r.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
          r.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
          r.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
          r.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          r.anisotropy ? "#define USE_ANISOTROPY" : "",
          r.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
          r.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          r.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          r.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          r.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          r.iridescenceThicknessMap
            ? "#define USE_IRIDESCENCE_THICKNESSMAP"
            : "",
          r.specularMap ? "#define USE_SPECULARMAP" : "",
          r.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
          r.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
          r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          r.metalnessMap ? "#define USE_METALNESSMAP" : "",
          r.alphaMap ? "#define USE_ALPHAMAP" : "",
          r.alphaHash ? "#define USE_ALPHAHASH" : "",
          r.transmission ? "#define USE_TRANSMISSION" : "",
          r.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          r.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          r.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
          r.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
          r.mapUv ? "#define MAP_UV " + r.mapUv : "",
          r.alphaMapUv ? "#define ALPHAMAP_UV " + r.alphaMapUv : "",
          r.lightMapUv ? "#define LIGHTMAP_UV " + r.lightMapUv : "",
          r.aoMapUv ? "#define AOMAP_UV " + r.aoMapUv : "",
          r.emissiveMapUv ? "#define EMISSIVEMAP_UV " + r.emissiveMapUv : "",
          r.bumpMapUv ? "#define BUMPMAP_UV " + r.bumpMapUv : "",
          r.normalMapUv ? "#define NORMALMAP_UV " + r.normalMapUv : "",
          r.displacementMapUv
            ? "#define DISPLACEMENTMAP_UV " + r.displacementMapUv
            : "",
          r.metalnessMapUv ? "#define METALNESSMAP_UV " + r.metalnessMapUv : "",
          r.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + r.roughnessMapUv : "",
          r.anisotropyMapUv
            ? "#define ANISOTROPYMAP_UV " + r.anisotropyMapUv
            : "",
          r.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + r.clearcoatMapUv : "",
          r.clearcoatNormalMapUv
            ? "#define CLEARCOAT_NORMALMAP_UV " + r.clearcoatNormalMapUv
            : "",
          r.clearcoatRoughnessMapUv
            ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + r.clearcoatRoughnessMapUv
            : "",
          r.iridescenceMapUv
            ? "#define IRIDESCENCEMAP_UV " + r.iridescenceMapUv
            : "",
          r.iridescenceThicknessMapUv
            ? "#define IRIDESCENCE_THICKNESSMAP_UV " +
              r.iridescenceThicknessMapUv
            : "",
          r.sheenColorMapUv
            ? "#define SHEEN_COLORMAP_UV " + r.sheenColorMapUv
            : "",
          r.sheenRoughnessMapUv
            ? "#define SHEEN_ROUGHNESSMAP_UV " + r.sheenRoughnessMapUv
            : "",
          r.specularMapUv ? "#define SPECULARMAP_UV " + r.specularMapUv : "",
          r.specularColorMapUv
            ? "#define SPECULAR_COLORMAP_UV " + r.specularColorMapUv
            : "",
          r.specularIntensityMapUv
            ? "#define SPECULAR_INTENSITYMAP_UV " + r.specularIntensityMapUv
            : "",
          r.transmissionMapUv
            ? "#define TRANSMISSIONMAP_UV " + r.transmissionMapUv
            : "",
          r.thicknessMapUv ? "#define THICKNESSMAP_UV " + r.thicknessMapUv : "",
          r.vertexTangents && !1 === r.flatShading ? "#define USE_TANGENT" : "",
          r.vertexColors ? "#define USE_COLOR" : "",
          r.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          r.vertexUv1s ? "#define USE_UV1" : "",
          r.vertexUv2s ? "#define USE_UV2" : "",
          r.vertexUv3s ? "#define USE_UV3" : "",
          r.pointsUvs ? "#define USE_POINTS_UV" : "",
          r.flatShading ? "#define FLAT_SHADED" : "",
          r.skinning ? "#define USE_SKINNING" : "",
          r.morphTargets ? "#define USE_MORPHTARGETS" : "",
          r.morphNormals && !1 === r.flatShading
            ? "#define USE_MORPHNORMALS"
            : "",
          r.morphColors && r.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
          r.morphTargetsCount > 0 && r.isWebGL2
            ? "#define MORPHTARGETS_TEXTURE"
            : "",
          r.morphTargetsCount > 0 && r.isWebGL2
            ? "#define MORPHTARGETS_TEXTURE_STRIDE " + r.morphTextureStride
            : "",
          r.morphTargetsCount > 0 && r.isWebGL2
            ? "#define MORPHTARGETS_COUNT " + r.morphTargetsCount
            : "",
          r.doubleSided ? "#define DOUBLE_SIDED" : "",
          r.flipSided ? "#define FLIP_SIDED" : "",
          r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          r.shadowMapEnabled ? "#define " + l : "",
          r.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
          r.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
          r.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
          r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          r.logarithmicDepthBuffer && r.rendererExtensionFragDepth
            ? "#define USE_LOGDEPTHBUF_EXT"
            : "",
          "uniform mat4 modelMatrix;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",
          "uniform mat4 viewMatrix;",
          "uniform mat3 normalMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          "#ifdef USE_INSTANCING",
          "\tattribute mat4 instanceMatrix;",
          "#endif",
          "#ifdef USE_INSTANCING_COLOR",
          "\tattribute vec3 instanceColor;",
          "#endif",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec2 uv;",
          "#ifdef USE_UV1",
          "\tattribute vec2 uv1;",
          "#endif",
          "#ifdef USE_UV2",
          "\tattribute vec2 uv2;",
          "#endif",
          "#ifdef USE_UV3",
          "\tattribute vec2 uv3;",
          "#endif",
          "#ifdef USE_TANGENT",
          "\tattribute vec4 tangent;",
          "#endif",
          "#if defined( USE_COLOR_ALPHA )",
          "\tattribute vec4 color;",
          "#elif defined( USE_COLOR )",
          "\tattribute vec3 color;",
          "#endif",
          "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
          "\tattribute vec3 morphTarget0;",
          "\tattribute vec3 morphTarget1;",
          "\tattribute vec3 morphTarget2;",
          "\tattribute vec3 morphTarget3;",
          "\t#ifdef USE_MORPHNORMALS",
          "\t\tattribute vec3 morphNormal0;",
          "\t\tattribute vec3 morphNormal1;",
          "\t\tattribute vec3 morphNormal2;",
          "\t\tattribute vec3 morphNormal3;",
          "\t#else",
          "\t\tattribute vec3 morphTarget4;",
          "\t\tattribute vec3 morphTarget5;",
          "\t\tattribute vec3 morphTarget6;",
          "\t\tattribute vec3 morphTarget7;",
          "\t#endif",
          "#endif",
          "#ifdef USE_SKINNING",
          "\tattribute vec4 skinIndex;",
          "\tattribute vec4 skinWeight;",
          "#endif",
          "\n",
        ]
          .filter(Ao)
          .join("\n")),
        (v = [
          p,
          ko(r),
          "#define SHADER_TYPE " + r.shaderType,
          "#define SHADER_NAME " + r.shaderName,
          m,
          r.useFog && r.fog ? "#define USE_FOG" : "",
          r.useFog && r.fogExp2 ? "#define FOG_EXP2" : "",
          r.map ? "#define USE_MAP" : "",
          r.matcap ? "#define USE_MATCAP" : "",
          r.envMap ? "#define USE_ENVMAP" : "",
          r.envMap ? "#define " + c : "",
          r.envMap ? "#define " + u : "",
          r.envMap ? "#define " + h : "",
          d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
          d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
          d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
          r.lightMap ? "#define USE_LIGHTMAP" : "",
          r.aoMap ? "#define USE_AOMAP" : "",
          r.bumpMap ? "#define USE_BUMPMAP" : "",
          r.normalMap ? "#define USE_NORMALMAP" : "",
          r.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
          r.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
          r.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          r.anisotropy ? "#define USE_ANISOTROPY" : "",
          r.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
          r.clearcoat ? "#define USE_CLEARCOAT" : "",
          r.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          r.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          r.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          r.iridescence ? "#define USE_IRIDESCENCE" : "",
          r.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          r.iridescenceThicknessMap
            ? "#define USE_IRIDESCENCE_THICKNESSMAP"
            : "",
          r.specularMap ? "#define USE_SPECULARMAP" : "",
          r.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
          r.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
          r.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          r.metalnessMap ? "#define USE_METALNESSMAP" : "",
          r.alphaMap ? "#define USE_ALPHAMAP" : "",
          r.alphaTest ? "#define USE_ALPHATEST" : "",
          r.alphaHash ? "#define USE_ALPHAHASH" : "",
          r.sheen ? "#define USE_SHEEN" : "",
          r.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
          r.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
          r.transmission ? "#define USE_TRANSMISSION" : "",
          r.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          r.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          r.vertexTangents && !1 === r.flatShading ? "#define USE_TANGENT" : "",
          r.vertexColors || r.instancingColor ? "#define USE_COLOR" : "",
          r.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          r.vertexUv1s ? "#define USE_UV1" : "",
          r.vertexUv2s ? "#define USE_UV2" : "",
          r.vertexUv3s ? "#define USE_UV3" : "",
          r.pointsUvs ? "#define USE_POINTS_UV" : "",
          r.gradientMap ? "#define USE_GRADIENTMAP" : "",
          r.flatShading ? "#define FLAT_SHADED" : "",
          r.doubleSided ? "#define DOUBLE_SIDED" : "",
          r.flipSided ? "#define FLIP_SIDED" : "",
          r.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          r.shadowMapEnabled ? "#define " + l : "",
          r.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
          r.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
          r.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
          r.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
          r.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          r.logarithmicDepthBuffer && r.rendererExtensionFragDepth
            ? "#define USE_LOGDEPTHBUF_EXT"
            : "",
          "uniform mat4 viewMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          0 !== r.toneMapping ? "#define TONE_MAPPING" : "",
          0 !== r.toneMapping ? Un.tonemapping_pars_fragment : "",
          0 !== r.toneMapping ? To("toneMapping", r.toneMapping) : "",
          r.dithering ? "#define DITHERING" : "",
          r.opaque ? "#define OPAQUE" : "",
          Un.colorspace_pars_fragment,
          Mo("linearToOutputTexel", r.outputColorSpace),
          r.useDepthPacking ? "#define DEPTH_PACKING " + r.depthPacking : "",
          "\n",
        ]
          .filter(Ao)
          .join("\n"))),
      (s = Io(s)),
      (s = Ro(s, r)),
      (s = Po(s, r)),
      (a = Io(a)),
      (a = Ro(a, r)),
      (a = Po(a, r)),
      (s = Uo(s)),
      (a = Uo(a)),
      r.isWebGL2 &&
        !0 !== r.isRawShaderMaterial &&
        ((y = "#version 300 es\n"),
        (_ =
          [
            f,
            "precision mediump sampler2DArray;",
            "#define attribute in",
            "#define varying out",
            "#define texture2D texture",
          ].join("\n") +
          "\n" +
          _),
        (v =
          [
            "precision mediump sampler2DArray;",
            "#define varying in",
            r.glslVersion === ye
              ? ""
              : "layout(location = 0) out highp vec4 pc_fragColor;",
            r.glslVersion === ye ? "" : "#define gl_FragColor pc_fragColor",
            "#define gl_FragDepthEXT gl_FragDepth",
            "#define texture2D texture",
            "#define textureCube texture",
            "#define texture2DProj textureProj",
            "#define texture2DLodEXT textureLod",
            "#define texture2DProjLodEXT textureProjLod",
            "#define textureCubeLodEXT textureLod",
            "#define texture2DGradEXT textureGrad",
            "#define texture2DProjGradEXT textureProjGrad",
            "#define textureCubeGradEXT textureGrad",
          ].join("\n") +
          "\n" +
          v));
    const b = y + _ + s,
      x = y + v + a,
      w = wo(i, i.VERTEX_SHADER, b),
      S = wo(i, i.FRAGMENT_SHADER, x);
    function A(t) {
      if (e.debug.checkShaderErrors) {
        const r = i.getProgramInfoLog(g).trim(),
          n = i.getShaderInfoLog(w).trim(),
          o = i.getShaderInfoLog(S).trim();
        let s = !0,
          a = !0;
        if (!1 === i.getProgramParameter(g, i.LINK_STATUS))
          if (((s = !1), "function" == typeof e.debug.onShaderError))
            e.debug.onShaderError(i, g, w, S);
          else {
            const e = Eo(i, w, "vertex"),
              t = Eo(i, S, "fragment");
            console.error(
              "THREE.WebGLProgram: Shader Error " +
                i.getError() +
                " - VALIDATE_STATUS " +
                i.getProgramParameter(g, i.VALIDATE_STATUS) +
                "\n\nProgram Info Log: " +
                r +
                "\n" +
                e +
                "\n" +
                t
            );
          }
        else
          "" !== r
            ? console.warn("THREE.WebGLProgram: Program Info Log:", r)
            : ("" !== n && "" !== o) || (a = !1);
        a &&
          (t.diagnostics = {
            runnable: s,
            programLog: r,
            vertexShader: { log: n, prefix: _ },
            fragmentShader: { log: o, prefix: v },
          });
      }
      i.deleteShader(w),
        i.deleteShader(S),
        (R = new xo(i, g)),
        (P = (function (e, t) {
          const r = {},
            n = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
          for (let i = 0; i < n; i++) {
            const n = e.getActiveAttrib(t, i),
              o = n.name;
            let s = 1;
            n.type === e.FLOAT_MAT2 && (s = 2),
              n.type === e.FLOAT_MAT3 && (s = 3),
              n.type === e.FLOAT_MAT4 && (s = 4),
              (r[o] = {
                type: n.type,
                location: e.getAttribLocation(t, o),
                locationSize: s,
              });
          }
          return r;
        })(i, g));
    }
    let R, P;
    i.attachShader(g, w),
      i.attachShader(g, S),
      void 0 !== r.index0AttributeName
        ? i.bindAttribLocation(g, 0, r.index0AttributeName)
        : !0 === r.morphTargets && i.bindAttribLocation(g, 0, "position"),
      i.linkProgram(g),
      (this.getUniforms = function () {
        return void 0 === R && A(this), R;
      }),
      (this.getAttributes = function () {
        return void 0 === P && A(this), P;
      });
    let C = !1 === r.rendererExtensionParallelShaderCompile;
    return (
      (this.isReady = function () {
        return !1 === C && (C = i.getProgramParameter(g, 37297)), C;
      }),
      (this.destroy = function () {
        n.releaseStatesOfProgram(this),
          i.deleteProgram(g),
          (this.program = void 0);
      }),
      (this.type = r.shaderType),
      (this.name = r.shaderName),
      (this.id = So++),
      (this.cacheKey = t),
      (this.usedTimes = 1),
      (this.program = g),
      (this.vertexShader = w),
      (this.fragmentShader = S),
      this
    );
  }
  let Fo = 0;
  class Ho {
    constructor() {
      (this.shaderCache = new Map()), (this.materialCache = new Map());
    }
    update(e) {
      const t = e.vertexShader,
        r = e.fragmentShader,
        n = this._getShaderStage(t),
        i = this._getShaderStage(r),
        o = this._getShaderCacheForMaterial(e);
      return (
        !1 === o.has(n) && (o.add(n), n.usedTimes++),
        !1 === o.has(i) && (o.add(i), i.usedTimes++),
        this
      );
    }
    remove(e) {
      const t = this.materialCache.get(e);
      for (const e of t)
        e.usedTimes--, 0 === e.usedTimes && this.shaderCache.delete(e.code);
      return this.materialCache.delete(e), this;
    }
    getVertexShaderID(e) {
      return this._getShaderStage(e.vertexShader).id;
    }
    getFragmentShaderID(e) {
      return this._getShaderStage(e.fragmentShader).id;
    }
    dispose() {
      this.shaderCache.clear(), this.materialCache.clear();
    }
    _getShaderCacheForMaterial(e) {
      const t = this.materialCache;
      let r = t.get(e);
      return void 0 === r && ((r = new Set()), t.set(e, r)), r;
    }
    _getShaderStage(e) {
      const t = this.shaderCache;
      let r = t.get(e);
      return void 0 === r && ((r = new zo(e)), t.set(e, r)), r;
    }
  }
  class zo {
    constructor(e) {
      (this.id = Fo++), (this.code = e), (this.usedTimes = 0);
    }
  }
  function Vo(e, t, r, n, i, o, s) {
    const a = new Qt(),
      l = new Ho(),
      c = [],
      u = i.isWebGL2,
      h = i.logarithmicDepthBuffer,
      d = i.vertexTextures;
    let p = i.precision;
    const f = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite",
    };
    function m(e) {
      return 0 === e ? "uv" : `uv${e}`;
    }
    return {
      getParameters: function (o, a, c, g, _) {
        const v = g.fog,
          y = _.geometry,
          b = o.isMeshStandardMaterial ? g.environment : null,
          x = (o.isMeshStandardMaterial ? r : t).get(o.envMap || b),
          w = x && x.mapping === T ? x.image.height : null,
          S = f[o.type];
        null !== o.precision &&
          ((p = i.getMaxPrecision(o.precision)),
          p !== o.precision &&
            console.warn(
              "THREE.WebGLProgram.getParameters:",
              o.precision,
              "not supported, using",
              p,
              "instead."
            ));
        const E =
            y.morphAttributes.position ||
            y.morphAttributes.normal ||
            y.morphAttributes.color,
          M = void 0 !== E ? E.length : 0;
        let A,
          R,
          P,
          C,
          I = 0;
        if (
          (void 0 !== y.morphAttributes.position && (I = 1),
          void 0 !== y.morphAttributes.normal && (I = 2),
          void 0 !== y.morphAttributes.color && (I = 3),
          S)
        ) {
          const e = kn[S];
          (A = e.vertexShader), (R = e.fragmentShader);
        } else
          (A = o.vertexShader),
            (R = o.fragmentShader),
            l.update(o),
            (P = l.getVertexShaderID(o)),
            (C = l.getFragmentShaderID(o));
        const L = e.getRenderTarget(),
          O = !0 === _.isInstancedMesh,
          N = !0 === _.isBatchedMesh,
          U = !!o.map,
          D = !!o.matcap,
          k = !!x,
          B = !!o.aoMap,
          F = !!o.lightMap,
          H = !!o.bumpMap,
          z = !!o.normalMap,
          V = !!o.displacementMap,
          j = !!o.emissiveMap,
          W = !!o.metalnessMap,
          G = !!o.roughnessMap,
          X = o.anisotropy > 0,
          q = o.clearcoat > 0,
          Y = o.iridescence > 0,
          K = o.sheen > 0,
          $ = o.transmission > 0,
          Q = X && !!o.anisotropyMap,
          J = q && !!o.clearcoatMap,
          Z = q && !!o.clearcoatNormalMap,
          ee = q && !!o.clearcoatRoughnessMap,
          te = Y && !!o.iridescenceMap,
          ne = Y && !!o.iridescenceThicknessMap,
          ie = K && !!o.sheenColorMap,
          oe = K && !!o.sheenRoughnessMap,
          ae = !!o.specularMap,
          le = !!o.specularColorMap,
          ce = !!o.specularIntensityMap,
          ue = $ && !!o.transmissionMap,
          he = $ && !!o.thicknessMap,
          de = !!o.gradientMap,
          pe = !!o.alphaMap,
          fe = o.alphaTest > 0,
          me = !!o.alphaHash,
          ge = !!o.extensions,
          _e = !!y.attributes.uv1,
          ve = !!y.attributes.uv2,
          ye = !!y.attributes.uv3;
        let be = 0;
        return (
          o.toneMapped &&
            ((null !== L && !0 !== L.isXRRenderTarget) || (be = e.toneMapping)),
          {
            isWebGL2: u,
            shaderID: S,
            shaderType: o.type,
            shaderName: o.name,
            vertexShader: A,
            fragmentShader: R,
            defines: o.defines,
            customVertexShaderID: P,
            customFragmentShaderID: C,
            isRawShaderMaterial: !0 === o.isRawShaderMaterial,
            glslVersion: o.glslVersion,
            precision: p,
            batching: N,
            instancing: O,
            instancingColor: O && null !== _.instanceColor,
            supportsVertexTextures: d,
            outputColorSpace:
              null === L
                ? e.outputColorSpace
                : !0 === L.isXRRenderTarget
                ? L.texture.colorSpace
                : re,
            map: U,
            matcap: D,
            envMap: k,
            envMapMode: k && x.mapping,
            envMapCubeUVHeight: w,
            aoMap: B,
            lightMap: F,
            bumpMap: H,
            normalMap: z,
            displacementMap: d && V,
            emissiveMap: j,
            normalMapObjectSpace: z && 1 === o.normalMapType,
            normalMapTangentSpace: z && 0 === o.normalMapType,
            metalnessMap: W,
            roughnessMap: G,
            anisotropy: X,
            anisotropyMap: Q,
            clearcoat: q,
            clearcoatMap: J,
            clearcoatNormalMap: Z,
            clearcoatRoughnessMap: ee,
            iridescence: Y,
            iridescenceMap: te,
            iridescenceThicknessMap: ne,
            sheen: K,
            sheenColorMap: ie,
            sheenRoughnessMap: oe,
            specularMap: ae,
            specularColorMap: le,
            specularIntensityMap: ce,
            transmission: $,
            transmissionMap: ue,
            thicknessMap: he,
            gradientMap: de,
            opaque: !1 === o.transparent && 1 === o.blending,
            alphaMap: pe,
            alphaTest: fe,
            alphaHash: me,
            combine: o.combine,
            mapUv: U && m(o.map.channel),
            aoMapUv: B && m(o.aoMap.channel),
            lightMapUv: F && m(o.lightMap.channel),
            bumpMapUv: H && m(o.bumpMap.channel),
            normalMapUv: z && m(o.normalMap.channel),
            displacementMapUv: V && m(o.displacementMap.channel),
            emissiveMapUv: j && m(o.emissiveMap.channel),
            metalnessMapUv: W && m(o.metalnessMap.channel),
            roughnessMapUv: G && m(o.roughnessMap.channel),
            anisotropyMapUv: Q && m(o.anisotropyMap.channel),
            clearcoatMapUv: J && m(o.clearcoatMap.channel),
            clearcoatNormalMapUv: Z && m(o.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: ee && m(o.clearcoatRoughnessMap.channel),
            iridescenceMapUv: te && m(o.iridescenceMap.channel),
            iridescenceThicknessMapUv:
              ne && m(o.iridescenceThicknessMap.channel),
            sheenColorMapUv: ie && m(o.sheenColorMap.channel),
            sheenRoughnessMapUv: oe && m(o.sheenRoughnessMap.channel),
            specularMapUv: ae && m(o.specularMap.channel),
            specularColorMapUv: le && m(o.specularColorMap.channel),
            specularIntensityMapUv: ce && m(o.specularIntensityMap.channel),
            transmissionMapUv: ue && m(o.transmissionMap.channel),
            thicknessMapUv: he && m(o.thicknessMap.channel),
            alphaMapUv: pe && m(o.alphaMap.channel),
            vertexTangents: !!y.attributes.tangent && (z || X),
            vertexColors: o.vertexColors,
            vertexAlphas:
              !0 === o.vertexColors &&
              !!y.attributes.color &&
              4 === y.attributes.color.itemSize,
            vertexUv1s: _e,
            vertexUv2s: ve,
            vertexUv3s: ye,
            pointsUvs: !0 === _.isPoints && !!y.attributes.uv && (U || pe),
            fog: !!v,
            useFog: !0 === o.fog,
            fogExp2: v && v.isFogExp2,
            flatShading: !0 === o.flatShading,
            sizeAttenuation: !0 === o.sizeAttenuation,
            logarithmicDepthBuffer: h,
            skinning: !0 === _.isSkinnedMesh,
            morphTargets: void 0 !== y.morphAttributes.position,
            morphNormals: void 0 !== y.morphAttributes.normal,
            morphColors: void 0 !== y.morphAttributes.color,
            morphTargetsCount: M,
            morphTextureStride: I,
            numDirLights: a.directional.length,
            numPointLights: a.point.length,
            numSpotLights: a.spot.length,
            numSpotLightMaps: a.spotLightMap.length,
            numRectAreaLights: a.rectArea.length,
            numHemiLights: a.hemi.length,
            numDirLightShadows: a.directionalShadowMap.length,
            numPointLightShadows: a.pointShadowMap.length,
            numSpotLightShadows: a.spotShadowMap.length,
            numSpotLightShadowsWithMaps: a.numSpotLightShadowsWithMaps,
            numLightProbes: a.numLightProbes,
            numClippingPlanes: s.numPlanes,
            numClipIntersection: s.numIntersection,
            dithering: o.dithering,
            shadowMapEnabled: e.shadowMap.enabled && c.length > 0,
            shadowMapType: e.shadowMap.type,
            toneMapping: be,
            useLegacyLights: e._useLegacyLights,
            decodeVideoTexture:
              U &&
              !0 === o.map.isVideoTexture &&
              Ye.getTransfer(o.map.colorSpace) === se,
            premultipliedAlpha: o.premultipliedAlpha,
            doubleSided: 2 === o.side,
            flipSided: 1 === o.side,
            useDepthPacking: o.depthPacking >= 0,
            depthPacking: o.depthPacking || 0,
            index0AttributeName: o.index0AttributeName,
            extensionDerivatives: ge && !0 === o.extensions.derivatives,
            extensionFragDepth: ge && !0 === o.extensions.fragDepth,
            extensionDrawBuffers: ge && !0 === o.extensions.drawBuffers,
            extensionShaderTextureLOD:
              ge && !0 === o.extensions.shaderTextureLOD,
            extensionClipCullDistance:
              ge &&
              o.extensions.clipCullDistance &&
              n.has("WEBGL_clip_cull_distance"),
            rendererExtensionFragDepth: u || n.has("EXT_frag_depth"),
            rendererExtensionDrawBuffers: u || n.has("WEBGL_draw_buffers"),
            rendererExtensionShaderTextureLod:
              u || n.has("EXT_shader_texture_lod"),
            rendererExtensionParallelShaderCompile: n.has(
              "KHR_parallel_shader_compile"
            ),
            customProgramCacheKey: o.customProgramCacheKey(),
          }
        );
      },
      getProgramCacheKey: function (t) {
        const r = [];
        if (
          (t.shaderID
            ? r.push(t.shaderID)
            : (r.push(t.customVertexShaderID),
              r.push(t.customFragmentShaderID)),
          void 0 !== t.defines)
        )
          for (const e in t.defines) r.push(e), r.push(t.defines[e]);
        return (
          !1 === t.isRawShaderMaterial &&
            ((function (e, t) {
              e.push(t.precision),
                e.push(t.outputColorSpace),
                e.push(t.envMapMode),
                e.push(t.envMapCubeUVHeight),
                e.push(t.mapUv),
                e.push(t.alphaMapUv),
                e.push(t.lightMapUv),
                e.push(t.aoMapUv),
                e.push(t.bumpMapUv),
                e.push(t.normalMapUv),
                e.push(t.displacementMapUv),
                e.push(t.emissiveMapUv),
                e.push(t.metalnessMapUv),
                e.push(t.roughnessMapUv),
                e.push(t.anisotropyMapUv),
                e.push(t.clearcoatMapUv),
                e.push(t.clearcoatNormalMapUv),
                e.push(t.clearcoatRoughnessMapUv),
                e.push(t.iridescenceMapUv),
                e.push(t.iridescenceThicknessMapUv),
                e.push(t.sheenColorMapUv),
                e.push(t.sheenRoughnessMapUv),
                e.push(t.specularMapUv),
                e.push(t.specularColorMapUv),
                e.push(t.specularIntensityMapUv),
                e.push(t.transmissionMapUv),
                e.push(t.thicknessMapUv),
                e.push(t.combine),
                e.push(t.fogExp2),
                e.push(t.sizeAttenuation),
                e.push(t.morphTargetsCount),
                e.push(t.morphAttributeCount),
                e.push(t.numDirLights),
                e.push(t.numPointLights),
                e.push(t.numSpotLights),
                e.push(t.numSpotLightMaps),
                e.push(t.numHemiLights),
                e.push(t.numRectAreaLights),
                e.push(t.numDirLightShadows),
                e.push(t.numPointLightShadows),
                e.push(t.numSpotLightShadows),
                e.push(t.numSpotLightShadowsWithMaps),
                e.push(t.numLightProbes),
                e.push(t.shadowMapType),
                e.push(t.toneMapping),
                e.push(t.numClippingPlanes),
                e.push(t.numClipIntersection),
                e.push(t.depthPacking);
            })(r, t),
            (function (e, t) {
              a.disableAll(),
                t.isWebGL2 && a.enable(0),
                t.supportsVertexTextures && a.enable(1),
                t.instancing && a.enable(2),
                t.instancingColor && a.enable(3),
                t.matcap && a.enable(4),
                t.envMap && a.enable(5),
                t.normalMapObjectSpace && a.enable(6),
                t.normalMapTangentSpace && a.enable(7),
                t.clearcoat && a.enable(8),
                t.iridescence && a.enable(9),
                t.alphaTest && a.enable(10),
                t.vertexColors && a.enable(11),
                t.vertexAlphas && a.enable(12),
                t.vertexUv1s && a.enable(13),
                t.vertexUv2s && a.enable(14),
                t.vertexUv3s && a.enable(15),
                t.vertexTangents && a.enable(16),
                t.anisotropy && a.enable(17),
                t.alphaHash && a.enable(18),
                t.batching && a.enable(19),
                e.push(a.mask),
                a.disableAll(),
                t.fog && a.enable(0),
                t.useFog && a.enable(1),
                t.flatShading && a.enable(2),
                t.logarithmicDepthBuffer && a.enable(3),
                t.skinning && a.enable(4),
                t.morphTargets && a.enable(5),
                t.morphNormals && a.enable(6),
                t.morphColors && a.enable(7),
                t.premultipliedAlpha && a.enable(8),
                t.shadowMapEnabled && a.enable(9),
                t.useLegacyLights && a.enable(10),
                t.doubleSided && a.enable(11),
                t.flipSided && a.enable(12),
                t.useDepthPacking && a.enable(13),
                t.dithering && a.enable(14),
                t.transmission && a.enable(15),
                t.sheen && a.enable(16),
                t.opaque && a.enable(17),
                t.pointsUvs && a.enable(18),
                t.decodeVideoTexture && a.enable(19),
                e.push(a.mask);
            })(r, t),
            r.push(e.outputColorSpace)),
          r.push(t.customProgramCacheKey),
          r.join()
        );
      },
      getUniforms: function (e) {
        const t = f[e.type];
        let r;
        if (t) {
          const e = kn[t];
          r = _n.clone(e.uniforms);
        } else r = e.uniforms;
        return r;
      },
      acquireProgram: function (t, r) {
        let n;
        for (let e = 0, t = c.length; e < t; e++) {
          const t = c[e];
          if (t.cacheKey === r) {
            (n = t), ++n.usedTimes;
            break;
          }
        }
        return void 0 === n && ((n = new Bo(e, r, t, o)), c.push(n)), n;
      },
      releaseProgram: function (e) {
        if (0 === --e.usedTimes) {
          const t = c.indexOf(e);
          (c[t] = c[c.length - 1]), c.pop(), e.destroy();
        }
      },
      releaseShaderCache: function (e) {
        l.remove(e);
      },
      programs: c,
      dispose: function () {
        l.dispose();
      },
    };
  }
  function jo() {
    let e = new WeakMap();
    return {
      get: function (t) {
        let r = e.get(t);
        return void 0 === r && ((r = {}), e.set(t, r)), r;
      },
      remove: function (t) {
        e.delete(t);
      },
      update: function (t, r, n) {
        e.get(t)[r] = n;
      },
      dispose: function () {
        e = new WeakMap();
      },
    };
  }
  function Wo(e, t) {
    return e.groupOrder !== t.groupOrder
      ? e.groupOrder - t.groupOrder
      : e.renderOrder !== t.renderOrder
      ? e.renderOrder - t.renderOrder
      : e.material.id !== t.material.id
      ? e.material.id - t.material.id
      : e.z !== t.z
      ? e.z - t.z
      : e.id - t.id;
  }
  function Go(e, t) {
    return e.groupOrder !== t.groupOrder
      ? e.groupOrder - t.groupOrder
      : e.renderOrder !== t.renderOrder
      ? e.renderOrder - t.renderOrder
      : e.z !== t.z
      ? t.z - e.z
      : e.id - t.id;
  }
  function Xo() {
    const e = [];
    let t = 0;
    const r = [],
      n = [],
      i = [];
    function o(r, n, i, o, s, a) {
      let l = e[t];
      return (
        void 0 === l
          ? ((l = {
              id: r.id,
              object: r,
              geometry: n,
              material: i,
              groupOrder: o,
              renderOrder: r.renderOrder,
              z: s,
              group: a,
            }),
            (e[t] = l))
          : ((l.id = r.id),
            (l.object = r),
            (l.geometry = n),
            (l.material = i),
            (l.groupOrder = o),
            (l.renderOrder = r.renderOrder),
            (l.z = s),
            (l.group = a)),
        t++,
        l
      );
    }
    return {
      opaque: r,
      transmissive: n,
      transparent: i,
      init: function () {
        (t = 0), (r.length = 0), (n.length = 0), (i.length = 0);
      },
      push: function (e, t, s, a, l, c) {
        const u = o(e, t, s, a, l, c);
        s.transmission > 0
          ? n.push(u)
          : !0 === s.transparent
          ? i.push(u)
          : r.push(u);
      },
      unshift: function (e, t, s, a, l, c) {
        const u = o(e, t, s, a, l, c);
        s.transmission > 0
          ? n.unshift(u)
          : !0 === s.transparent
          ? i.unshift(u)
          : r.unshift(u);
      },
      finish: function () {
        for (let r = t, n = e.length; r < n; r++) {
          const t = e[r];
          if (null === t.id) break;
          (t.id = null),
            (t.object = null),
            (t.geometry = null),
            (t.material = null),
            (t.group = null);
        }
      },
      sort: function (e, t) {
        r.length > 1 && r.sort(e || Wo),
          n.length > 1 && n.sort(t || Go),
          i.length > 1 && i.sort(t || Go);
      },
    };
  }
  function qo() {
    let e = new WeakMap();
    return {
      get: function (t, r) {
        const n = e.get(t);
        let i;
        return (
          void 0 === n
            ? ((i = new Xo()), e.set(t, [i]))
            : r >= n.length
            ? ((i = new Xo()), n.push(i))
            : (i = n[r]),
          i
        );
      },
      dispose: function () {
        e = new WeakMap();
      },
    };
  }
  function Yo() {
    const e = {};
    return {
      get: function (t) {
        if (void 0 !== e[t.id]) return e[t.id];
        let r;
        switch (t.type) {
          case "DirectionalLight":
            r = { direction: new ut(), color: new Rr() };
            break;
          case "SpotLight":
            r = {
              position: new ut(),
              direction: new ut(),
              color: new Rr(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0,
            };
            break;
          case "PointLight":
            r = { position: new ut(), color: new Rr(), distance: 0, decay: 0 };
            break;
          case "HemisphereLight":
            r = {
              direction: new ut(),
              skyColor: new Rr(),
              groundColor: new Rr(),
            };
            break;
          case "RectAreaLight":
            r = {
              color: new Rr(),
              position: new ut(),
              halfWidth: new ut(),
              halfHeight: new ut(),
            };
        }
        return (e[t.id] = r), r;
      },
    };
  }
  let Ko = 0;
  function $o(e, t) {
    return (
      (t.castShadow ? 2 : 0) -
      (e.castShadow ? 2 : 0) +
      (t.map ? 1 : 0) -
      (e.map ? 1 : 0)
    );
  }
  function Qo(e, t) {
    const r = new Yo(),
      n = (function () {
        const e = {};
        return {
          get: function (t) {
            if (void 0 !== e[t.id]) return e[t.id];
            let r;
            switch (t.type) {
              case "DirectionalLight":
              case "SpotLight":
                r = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new De(),
                };
                break;
              case "PointLight":
                r = {
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new De(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3,
                };
            }
            return (e[t.id] = r), r;
          },
        };
      })(),
      i = {
        version: 0,
        hash: {
          directionalLength: -1,
          pointLength: -1,
          spotLength: -1,
          rectAreaLength: -1,
          hemiLength: -1,
          numDirectionalShadows: -1,
          numPointShadows: -1,
          numSpotShadows: -1,
          numSpotMaps: -1,
          numLightProbes: -1,
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0,
      };
    for (let e = 0; e < 9; e++) i.probe.push(new ut());
    const o = new ut(),
      s = new Ht(),
      a = new Ht();
    return {
      setup: function (o, s) {
        let a = 0,
          l = 0,
          c = 0;
        for (let e = 0; e < 9; e++) i.probe[e].set(0, 0, 0);
        let u = 0,
          h = 0,
          d = 0,
          p = 0,
          f = 0,
          m = 0,
          g = 0,
          _ = 0,
          v = 0,
          y = 0,
          b = 0;
        o.sort($o);
        const x = !0 === s ? Math.PI : 1;
        for (let e = 0, t = o.length; e < t; e++) {
          const t = o[e],
            s = t.color,
            w = t.intensity,
            S = t.distance,
            E = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
          if (t.isAmbientLight)
            (a += s.r * w * x), (l += s.g * w * x), (c += s.b * w * x);
          else if (t.isLightProbe) {
            for (let e = 0; e < 9; e++)
              i.probe[e].addScaledVector(t.sh.coefficients[e], w);
            b++;
          } else if (t.isDirectionalLight) {
            const e = r.get(t);
            if (
              (e.color.copy(t.color).multiplyScalar(t.intensity * x),
              t.castShadow)
            ) {
              const e = t.shadow,
                r = n.get(t);
              (r.shadowBias = e.bias),
                (r.shadowNormalBias = e.normalBias),
                (r.shadowRadius = e.radius),
                (r.shadowMapSize = e.mapSize),
                (i.directionalShadow[u] = r),
                (i.directionalShadowMap[u] = E),
                (i.directionalShadowMatrix[u] = t.shadow.matrix),
                m++;
            }
            (i.directional[u] = e), u++;
          } else if (t.isSpotLight) {
            const e = r.get(t);
            e.position.setFromMatrixPosition(t.matrixWorld),
              e.color.copy(s).multiplyScalar(w * x),
              (e.distance = S),
              (e.coneCos = Math.cos(t.angle)),
              (e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra))),
              (e.decay = t.decay),
              (i.spot[d] = e);
            const o = t.shadow;
            if (
              (t.map &&
                ((i.spotLightMap[v] = t.map),
                v++,
                o.updateMatrices(t),
                t.castShadow && y++),
              (i.spotLightMatrix[d] = o.matrix),
              t.castShadow)
            ) {
              const e = n.get(t);
              (e.shadowBias = o.bias),
                (e.shadowNormalBias = o.normalBias),
                (e.shadowRadius = o.radius),
                (e.shadowMapSize = o.mapSize),
                (i.spotShadow[d] = e),
                (i.spotShadowMap[d] = E),
                _++;
            }
            d++;
          } else if (t.isRectAreaLight) {
            const e = r.get(t);
            e.color.copy(s).multiplyScalar(w),
              e.halfWidth.set(0.5 * t.width, 0, 0),
              e.halfHeight.set(0, 0.5 * t.height, 0),
              (i.rectArea[p] = e),
              p++;
          } else if (t.isPointLight) {
            const e = r.get(t);
            if (
              (e.color.copy(t.color).multiplyScalar(t.intensity * x),
              (e.distance = t.distance),
              (e.decay = t.decay),
              t.castShadow)
            ) {
              const e = t.shadow,
                r = n.get(t);
              (r.shadowBias = e.bias),
                (r.shadowNormalBias = e.normalBias),
                (r.shadowRadius = e.radius),
                (r.shadowMapSize = e.mapSize),
                (r.shadowCameraNear = e.camera.near),
                (r.shadowCameraFar = e.camera.far),
                (i.pointShadow[h] = r),
                (i.pointShadowMap[h] = E),
                (i.pointShadowMatrix[h] = t.shadow.matrix),
                g++;
            }
            (i.point[h] = e), h++;
          } else if (t.isHemisphereLight) {
            const e = r.get(t);
            e.skyColor.copy(t.color).multiplyScalar(w * x),
              e.groundColor.copy(t.groundColor).multiplyScalar(w * x),
              (i.hemi[f] = e),
              f++;
          }
        }
        p > 0 &&
          (t.isWebGL2
            ? !0 === e.has("OES_texture_float_linear")
              ? ((i.rectAreaLTC1 = Dn.LTC_FLOAT_1),
                (i.rectAreaLTC2 = Dn.LTC_FLOAT_2))
              : ((i.rectAreaLTC1 = Dn.LTC_HALF_1),
                (i.rectAreaLTC2 = Dn.LTC_HALF_2))
            : !0 === e.has("OES_texture_float_linear")
            ? ((i.rectAreaLTC1 = Dn.LTC_FLOAT_1),
              (i.rectAreaLTC2 = Dn.LTC_FLOAT_2))
            : !0 === e.has("OES_texture_half_float_linear")
            ? ((i.rectAreaLTC1 = Dn.LTC_HALF_1),
              (i.rectAreaLTC2 = Dn.LTC_HALF_2))
            : console.error(
                "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
              )),
          (i.ambient[0] = a),
          (i.ambient[1] = l),
          (i.ambient[2] = c);
        const w = i.hash;
        (w.directionalLength === u &&
          w.pointLength === h &&
          w.spotLength === d &&
          w.rectAreaLength === p &&
          w.hemiLength === f &&
          w.numDirectionalShadows === m &&
          w.numPointShadows === g &&
          w.numSpotShadows === _ &&
          w.numSpotMaps === v &&
          w.numLightProbes === b) ||
          ((i.directional.length = u),
          (i.spot.length = d),
          (i.rectArea.length = p),
          (i.point.length = h),
          (i.hemi.length = f),
          (i.directionalShadow.length = m),
          (i.directionalShadowMap.length = m),
          (i.pointShadow.length = g),
          (i.pointShadowMap.length = g),
          (i.spotShadow.length = _),
          (i.spotShadowMap.length = _),
          (i.directionalShadowMatrix.length = m),
          (i.pointShadowMatrix.length = g),
          (i.spotLightMatrix.length = _ + v - y),
          (i.spotLightMap.length = v),
          (i.numSpotLightShadowsWithMaps = y),
          (i.numLightProbes = b),
          (w.directionalLength = u),
          (w.pointLength = h),
          (w.spotLength = d),
          (w.rectAreaLength = p),
          (w.hemiLength = f),
          (w.numDirectionalShadows = m),
          (w.numPointShadows = g),
          (w.numSpotShadows = _),
          (w.numSpotMaps = v),
          (w.numLightProbes = b),
          (i.version = Ko++));
      },
      setupView: function (e, t) {
        let r = 0,
          n = 0,
          l = 0,
          c = 0,
          u = 0;
        const h = t.matrixWorldInverse;
        for (let t = 0, d = e.length; t < d; t++) {
          const d = e[t];
          if (d.isDirectionalLight) {
            const e = i.directional[r];
            e.direction.setFromMatrixPosition(d.matrixWorld),
              o.setFromMatrixPosition(d.target.matrixWorld),
              e.direction.sub(o),
              e.direction.transformDirection(h),
              r++;
          } else if (d.isSpotLight) {
            const e = i.spot[l];
            e.position.setFromMatrixPosition(d.matrixWorld),
              e.position.applyMatrix4(h),
              e.direction.setFromMatrixPosition(d.matrixWorld),
              o.setFromMatrixPosition(d.target.matrixWorld),
              e.direction.sub(o),
              e.direction.transformDirection(h),
              l++;
          } else if (d.isRectAreaLight) {
            const e = i.rectArea[c];
            e.position.setFromMatrixPosition(d.matrixWorld),
              e.position.applyMatrix4(h),
              a.identity(),
              s.copy(d.matrixWorld),
              s.premultiply(h),
              a.extractRotation(s),
              e.halfWidth.set(0.5 * d.width, 0, 0),
              e.halfHeight.set(0, 0.5 * d.height, 0),
              e.halfWidth.applyMatrix4(a),
              e.halfHeight.applyMatrix4(a),
              c++;
          } else if (d.isPointLight) {
            const e = i.point[n];
            e.position.setFromMatrixPosition(d.matrixWorld),
              e.position.applyMatrix4(h),
              n++;
          } else if (d.isHemisphereLight) {
            const e = i.hemi[u];
            e.direction.setFromMatrixPosition(d.matrixWorld),
              e.direction.transformDirection(h),
              u++;
          }
        }
      },
      state: i,
    };
  }
  function Jo(e, t) {
    const r = new Qo(e, t),
      n = [],
      i = [];
    return {
      init: function () {
        (n.length = 0), (i.length = 0);
      },
      state: { lightsArray: n, shadowsArray: i, lights: r },
      setupLights: function (e) {
        r.setup(n, e);
      },
      setupLightsView: function (e) {
        r.setupView(n, e);
      },
      pushLight: function (e) {
        n.push(e);
      },
      pushShadow: function (e) {
        i.push(e);
      },
    };
  }
  function Zo(e, t) {
    let r = new WeakMap();
    return {
      get: function (n, i = 0) {
        const o = r.get(n);
        let s;
        return (
          void 0 === o
            ? ((s = new Jo(e, t)), r.set(n, [s]))
            : i >= o.length
            ? ((s = new Jo(e, t)), o.push(s))
            : (s = o[i]),
          s
        );
      },
      dispose: function () {
        r = new WeakMap();
      },
    };
  }
  class es extends Ir {
    constructor(e) {
      super(),
        (this.isMeshDepthMaterial = !0),
        (this.type = "MeshDepthMaterial"),
        (this.depthPacking = 3200),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        this.setValues(e);
    }
    copy(e) {
      return (
        super.copy(e),
        (this.depthPacking = e.depthPacking),
        (this.map = e.map),
        (this.alphaMap = e.alphaMap),
        (this.displacementMap = e.displacementMap),
        (this.displacementScale = e.displacementScale),
        (this.displacementBias = e.displacementBias),
        (this.wireframe = e.wireframe),
        (this.wireframeLinewidth = e.wireframeLinewidth),
        this
      );
    }
  }
  class ts extends Ir {
    constructor(e) {
      super(),
        (this.isMeshDistanceMaterial = !0),
        (this.type = "MeshDistanceMaterial"),
        (this.map = null),
        (this.alphaMap = null),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        this.setValues(e);
    }
    copy(e) {
      return (
        super.copy(e),
        (this.map = e.map),
        (this.alphaMap = e.alphaMap),
        (this.displacementMap = e.displacementMap),
        (this.displacementScale = e.displacementScale),
        (this.displacementBias = e.displacementBias),
        this
      );
    }
  }
  function rs(e, t, o) {
    let s = new In();
    const a = new De(),
      l = new De(),
      c = new it(),
      u = new es({ depthPacking: 3201 }),
      h = new ts(),
      d = {},
      p = o.maxTextureSize,
      f = { [r]: 1, [n]: 0, [i]: 2 },
      m = new vn({
        defines: { VSM_SAMPLES: 8 },
        uniforms: {
          shadow_pass: { value: null },
          resolution: { value: new De() },
          radius: { value: 4 },
        },
        vertexShader:
          "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
        fragmentShader:
          "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
      }),
      g = m.clone();
    g.defines.HORIZONTAL_PASS = 1;
    const _ = new Xr();
    _.setAttribute(
      "position",
      new Ur(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
    );
    const v = new hn(_, m),
      y = this;
    (this.enabled = !1),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this.type = 1);
    let b = this.type;
    function x(r, n) {
      const i = t.update(v);
      m.defines.VSM_SAMPLES !== r.blurSamples &&
        ((m.defines.VSM_SAMPLES = r.blurSamples),
        (g.defines.VSM_SAMPLES = r.blurSamples),
        (m.needsUpdate = !0),
        (g.needsUpdate = !0)),
        null === r.mapPass && (r.mapPass = new st(a.x, a.y)),
        (m.uniforms.shadow_pass.value = r.map.texture),
        (m.uniforms.resolution.value = r.mapSize),
        (m.uniforms.radius.value = r.radius),
        e.setRenderTarget(r.mapPass),
        e.clear(),
        e.renderBufferDirect(n, null, i, m, v, null),
        (g.uniforms.shadow_pass.value = r.mapPass.texture),
        (g.uniforms.resolution.value = r.mapSize),
        (g.uniforms.radius.value = r.radius),
        e.setRenderTarget(r.map),
        e.clear(),
        e.renderBufferDirect(n, null, i, g, v, null);
    }
    function w(t, r, n, i) {
      let o = null;
      const s =
        !0 === n.isPointLight
          ? t.customDistanceMaterial
          : t.customDepthMaterial;
      if (void 0 !== s) o = s;
      else if (
        ((o = !0 === n.isPointLight ? h : u),
        (e.localClippingEnabled &&
          !0 === r.clipShadows &&
          Array.isArray(r.clippingPlanes) &&
          0 !== r.clippingPlanes.length) ||
          (r.displacementMap && 0 !== r.displacementScale) ||
          (r.alphaMap && r.alphaTest > 0) ||
          (r.map && r.alphaTest > 0))
      ) {
        const e = o.uuid,
          t = r.uuid;
        let n = d[e];
        void 0 === n && ((n = {}), (d[e] = n));
        let i = n[t];
        void 0 === i &&
          ((i = o.clone()), (n[t] = i), r.addEventListener("dispose", E)),
          (o = i);
      }
      return (
        (o.visible = r.visible),
        (o.wireframe = r.wireframe),
        (o.side =
          3 === i
            ? null !== r.shadowSide
              ? r.shadowSide
              : r.side
            : null !== r.shadowSide
            ? r.shadowSide
            : f[r.side]),
        (o.alphaMap = r.alphaMap),
        (o.alphaTest = r.alphaTest),
        (o.map = r.map),
        (o.clipShadows = r.clipShadows),
        (o.clippingPlanes = r.clippingPlanes),
        (o.clipIntersection = r.clipIntersection),
        (o.displacementMap = r.displacementMap),
        (o.displacementScale = r.displacementScale),
        (o.displacementBias = r.displacementBias),
        (o.wireframeLinewidth = r.wireframeLinewidth),
        (o.linewidth = r.linewidth),
        !0 === n.isPointLight &&
          !0 === o.isMeshDistanceMaterial &&
          (e.properties.get(o).light = n),
        o
      );
    }
    function S(r, n, i, o, a) {
      if (!1 === r.visible) return;
      if (
        r.layers.test(n.layers) &&
        (r.isMesh || r.isLine || r.isPoints) &&
        (r.castShadow || (r.receiveShadow && 3 === a)) &&
        (!r.frustumCulled || s.intersectsObject(r))
      ) {
        r.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, r.matrixWorld);
        const s = t.update(r),
          l = r.material;
        if (Array.isArray(l)) {
          const t = s.groups;
          for (let c = 0, u = t.length; c < u; c++) {
            const u = t[c],
              h = l[u.materialIndex];
            if (h && h.visible) {
              const t = w(r, h, o, a);
              r.onBeforeShadow(e, r, n, i, s, t, u),
                e.renderBufferDirect(i, null, s, t, r, u),
                r.onAfterShadow(e, r, n, i, s, t, u);
            }
          }
        } else if (l.visible) {
          const t = w(r, l, o, a);
          r.onBeforeShadow(e, r, n, i, s, t, null),
            e.renderBufferDirect(i, null, s, t, r, null),
            r.onAfterShadow(e, r, n, i, s, t, null);
        }
      }
      const l = r.children;
      for (let e = 0, t = l.length; e < t; e++) S(l[e], n, i, o, a);
    }
    function E(e) {
      e.target.removeEventListener("dispose", E);
      for (const t in d) {
        const r = d[t],
          n = e.target.uuid;
        n in r && (r[n].dispose(), delete r[n]);
      }
    }
    this.render = function (t, r, n) {
      if (!1 === y.enabled) return;
      if (!1 === y.autoUpdate && !1 === y.needsUpdate) return;
      if (0 === t.length) return;
      const i = e.getRenderTarget(),
        o = e.getActiveCubeFace(),
        u = e.getActiveMipmapLevel(),
        h = e.state;
      h.setBlending(0),
        h.buffers.color.setClear(1, 1, 1, 1),
        h.buffers.depth.setTest(!0),
        h.setScissorTest(!1);
      const d = 3 !== b && 3 === this.type,
        f = 3 === b && 3 !== this.type;
      for (let i = 0, o = t.length; i < o; i++) {
        const o = t[i],
          u = o.shadow;
        if (void 0 === u) {
          console.warn("THREE.WebGLShadowMap:", o, "has no shadow.");
          continue;
        }
        if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
        a.copy(u.mapSize);
        const m = u.getFrameExtents();
        if (
          (a.multiply(m),
          l.copy(u.mapSize),
          (a.x > p || a.y > p) &&
            (a.x > p &&
              ((l.x = Math.floor(p / m.x)),
              (a.x = l.x * m.x),
              (u.mapSize.x = l.x)),
            a.y > p &&
              ((l.y = Math.floor(p / m.y)),
              (a.y = l.y * m.y),
              (u.mapSize.y = l.y))),
          null === u.map || !0 === d || !0 === f)
        ) {
          const e = 3 !== this.type ? { minFilter: C, magFilter: C } : {};
          null !== u.map && u.map.dispose(),
            (u.map = new st(a.x, a.y, e)),
            (u.map.texture.name = o.name + ".shadowMap"),
            u.camera.updateProjectionMatrix();
        }
        e.setRenderTarget(u.map), e.clear();
        const g = u.getViewportCount();
        for (let e = 0; e < g; e++) {
          const t = u.getViewport(e);
          c.set(l.x * t.x, l.y * t.y, l.x * t.z, l.y * t.w),
            h.viewport(c),
            u.updateMatrices(o, e),
            (s = u.getFrustum()),
            S(r, n, u.camera, o, this.type);
        }
        !0 !== u.isPointLightShadow && 3 === this.type && x(u, n),
          (u.needsUpdate = !1);
      }
      (b = this.type), (y.needsUpdate = !1), e.setRenderTarget(i, o, u);
    };
  }
  function ns(e, t, r) {
    const n = r.isWebGL2,
      i = new (function () {
        let t = !1;
        const r = new it();
        let n = null;
        const i = new it(0, 0, 0, 0);
        return {
          setMask: function (r) {
            n === r || t || (e.colorMask(r, r, r, r), (n = r));
          },
          setLocked: function (e) {
            t = e;
          },
          setClear: function (t, n, o, s, a) {
            !0 === a && ((t *= s), (n *= s), (o *= s)),
              r.set(t, n, o, s),
              !1 === i.equals(r) && (e.clearColor(t, n, o, s), i.copy(r));
          },
          reset: function () {
            (t = !1), (n = null), i.set(-1, 0, 0, 0);
          },
        };
      })(),
      S = new (function () {
        let t = !1,
          r = null,
          n = null,
          i = null;
        return {
          setTest: function (t) {
            t ? se(e.DEPTH_TEST) : ae(e.DEPTH_TEST);
          },
          setMask: function (n) {
            r === n || t || (e.depthMask(n), (r = n));
          },
          setFunc: function (t) {
            if (n !== t) {
              switch (t) {
                case 0:
                  e.depthFunc(e.NEVER);
                  break;
                case 1:
                  e.depthFunc(e.ALWAYS);
                  break;
                case 2:
                  e.depthFunc(e.LESS);
                  break;
                case 3:
                default:
                  e.depthFunc(e.LEQUAL);
                  break;
                case 4:
                  e.depthFunc(e.EQUAL);
                  break;
                case 5:
                  e.depthFunc(e.GEQUAL);
                  break;
                case 6:
                  e.depthFunc(e.GREATER);
                  break;
                case 7:
                  e.depthFunc(e.NOTEQUAL);
              }
              n = t;
            }
          },
          setLocked: function (e) {
            t = e;
          },
          setClear: function (t) {
            i !== t && (e.clearDepth(t), (i = t));
          },
          reset: function () {
            (t = !1), (r = null), (n = null), (i = null);
          },
        };
      })(),
      E = new (function () {
        let t = !1,
          r = null,
          n = null,
          i = null,
          o = null,
          s = null,
          a = null,
          l = null,
          c = null;
        return {
          setTest: function (r) {
            t || (r ? se(e.STENCIL_TEST) : ae(e.STENCIL_TEST));
          },
          setMask: function (n) {
            r === n || t || (e.stencilMask(n), (r = n));
          },
          setFunc: function (t, r, s) {
            (n === t && i === r && o === s) ||
              (e.stencilFunc(t, r, s), (n = t), (i = r), (o = s));
          },
          setOp: function (t, r, n) {
            (s === t && a === r && l === n) ||
              (e.stencilOp(t, r, n), (s = t), (a = r), (l = n));
          },
          setLocked: function (e) {
            t = e;
          },
          setClear: function (t) {
            c !== t && (e.clearStencil(t), (c = t));
          },
          reset: function () {
            (t = !1),
              (r = null),
              (n = null),
              (i = null),
              (o = null),
              (s = null),
              (a = null),
              (l = null),
              (c = null);
          },
        };
      })(),
      M = new WeakMap(),
      T = new WeakMap();
    let A = {},
      R = {},
      P = new WeakMap(),
      C = [],
      I = null,
      L = !1,
      O = null,
      N = null,
      U = null,
      D = null,
      k = null,
      B = null,
      F = null,
      H = new Rr(0, 0, 0),
      z = 0,
      V = !1,
      j = null,
      W = null,
      G = null,
      X = null,
      q = null;
    const Y = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let K = !1,
      $ = 0;
    const Q = e.getParameter(e.VERSION);
    -1 !== Q.indexOf("WebGL")
      ? (($ = parseFloat(/^WebGL (\d)/.exec(Q)[1])), (K = $ >= 1))
      : -1 !== Q.indexOf("OpenGL ES") &&
        (($ = parseFloat(/^OpenGL ES (\d)/.exec(Q)[1])), (K = $ >= 2));
    let J = null,
      Z = {};
    const ee = e.getParameter(e.SCISSOR_BOX),
      te = e.getParameter(e.VIEWPORT),
      re = new it().fromArray(ee),
      ne = new it().fromArray(te);
    function ie(t, r, i, o) {
      const s = new Uint8Array(4),
        a = e.createTexture();
      e.bindTexture(t, a),
        e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST),
        e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
      for (let a = 0; a < i; a++)
        !n || (t !== e.TEXTURE_3D && t !== e.TEXTURE_2D_ARRAY)
          ? e.texImage2D(r + a, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, s)
          : e.texImage3D(r, 0, e.RGBA, 1, 1, o, 0, e.RGBA, e.UNSIGNED_BYTE, s);
      return a;
    }
    const oe = {};
    function se(t) {
      !0 !== A[t] && (e.enable(t), (A[t] = !0));
    }
    function ae(t) {
      !1 !== A[t] && (e.disable(t), (A[t] = !1));
    }
    (oe[e.TEXTURE_2D] = ie(e.TEXTURE_2D, e.TEXTURE_2D, 1)),
      (oe[e.TEXTURE_CUBE_MAP] = ie(
        e.TEXTURE_CUBE_MAP,
        e.TEXTURE_CUBE_MAP_POSITIVE_X,
        6
      )),
      n &&
        ((oe[e.TEXTURE_2D_ARRAY] = ie(
          e.TEXTURE_2D_ARRAY,
          e.TEXTURE_2D_ARRAY,
          1,
          1
        )),
        (oe[e.TEXTURE_3D] = ie(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1))),
      i.setClear(0, 0, 0, 1),
      S.setClear(1),
      E.setClear(0),
      se(e.DEPTH_TEST),
      S.setFunc(3),
      he(!1),
      de(1),
      se(e.CULL_FACE),
      ue(0);
    const le = {
      [o]: e.FUNC_ADD,
      [s]: e.FUNC_SUBTRACT,
      [a]: e.FUNC_REVERSE_SUBTRACT,
    };
    if (n) (le[103] = e.MIN), (le[104] = e.MAX);
    else {
      const e = t.get("EXT_blend_minmax");
      null !== e && ((le[103] = e.MIN_EXT), (le[104] = e.MAX_EXT));
    }
    const ce = {
      [l]: e.ZERO,
      [c]: e.ONE,
      [u]: e.SRC_COLOR,
      [d]: e.SRC_ALPHA,
      [v]: e.SRC_ALPHA_SATURATE,
      [g]: e.DST_COLOR,
      [f]: e.DST_ALPHA,
      [h]: e.ONE_MINUS_SRC_COLOR,
      [p]: e.ONE_MINUS_SRC_ALPHA,
      [_]: e.ONE_MINUS_DST_COLOR,
      [m]: e.ONE_MINUS_DST_ALPHA,
      [y]: e.CONSTANT_COLOR,
      [b]: e.ONE_MINUS_CONSTANT_COLOR,
      [x]: e.CONSTANT_ALPHA,
      [w]: e.ONE_MINUS_CONSTANT_ALPHA,
    };
    function ue(t, r, n, i, s, a, l, c, u, h) {
      if (0 !== t) {
        if ((!1 === L && (se(e.BLEND), (L = !0)), 5 === t))
          (s = s || r),
            (a = a || n),
            (l = l || i),
            (r === N && s === k) ||
              (e.blendEquationSeparate(le[r], le[s]), (N = r), (k = s)),
            (n === U && i === D && a === B && l === F) ||
              (e.blendFuncSeparate(ce[n], ce[i], ce[a], ce[l]),
              (U = n),
              (D = i),
              (B = a),
              (F = l)),
            (!1 !== c.equals(H) && u === z) ||
              (e.blendColor(c.r, c.g, c.b, u), H.copy(c), (z = u)),
            (O = t),
            (V = !1);
        else if (t !== O || h !== V) {
          if (
            ((N === o && k === o) ||
              (e.blendEquation(e.FUNC_ADD), (N = o), (k = o)),
            h)
          )
            switch (t) {
              case 1:
                e.blendFuncSeparate(
                  e.ONE,
                  e.ONE_MINUS_SRC_ALPHA,
                  e.ONE,
                  e.ONE_MINUS_SRC_ALPHA
                );
                break;
              case 2:
                e.blendFunc(e.ONE, e.ONE);
                break;
              case 3:
                e.blendFuncSeparate(
                  e.ZERO,
                  e.ONE_MINUS_SRC_COLOR,
                  e.ZERO,
                  e.ONE
                );
                break;
              case 4:
                e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", t);
            }
          else
            switch (t) {
              case 1:
                e.blendFuncSeparate(
                  e.SRC_ALPHA,
                  e.ONE_MINUS_SRC_ALPHA,
                  e.ONE,
                  e.ONE_MINUS_SRC_ALPHA
                );
                break;
              case 2:
                e.blendFunc(e.SRC_ALPHA, e.ONE);
                break;
              case 3:
                e.blendFuncSeparate(
                  e.ZERO,
                  e.ONE_MINUS_SRC_COLOR,
                  e.ZERO,
                  e.ONE
                );
                break;
              case 4:
                e.blendFunc(e.ZERO, e.SRC_COLOR);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", t);
            }
          (U = null),
            (D = null),
            (B = null),
            (F = null),
            H.set(0, 0, 0),
            (z = 0),
            (O = t),
            (V = h);
        }
      } else !0 === L && (ae(e.BLEND), (L = !1));
    }
    function he(t) {
      j !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), (j = t));
    }
    function de(t) {
      0 !== t
        ? (se(e.CULL_FACE),
          t !== W &&
            (1 === t
              ? e.cullFace(e.BACK)
              : 2 === t
              ? e.cullFace(e.FRONT)
              : e.cullFace(e.FRONT_AND_BACK)))
        : ae(e.CULL_FACE),
        (W = t);
    }
    function pe(t, r, n) {
      t
        ? (se(e.POLYGON_OFFSET_FILL),
          (X === r && q === n) || (e.polygonOffset(r, n), (X = r), (q = n)))
        : ae(e.POLYGON_OFFSET_FILL);
    }
    return {
      buffers: { color: i, depth: S, stencil: E },
      enable: se,
      disable: ae,
      bindFramebuffer: function (t, r) {
        return (
          R[t] !== r &&
          (e.bindFramebuffer(t, r),
          (R[t] = r),
          n &&
            (t === e.DRAW_FRAMEBUFFER && (R[e.FRAMEBUFFER] = r),
            t === e.FRAMEBUFFER && (R[e.DRAW_FRAMEBUFFER] = r)),
          !0)
        );
      },
      drawBuffers: function (n, i) {
        let o = C,
          s = !1;
        if (n)
          if (
            ((o = P.get(i)),
            void 0 === o && ((o = []), P.set(i, o)),
            n.isWebGLMultipleRenderTargets)
          ) {
            const t = n.texture;
            if (o.length !== t.length || o[0] !== e.COLOR_ATTACHMENT0) {
              for (let r = 0, n = t.length; r < n; r++)
                o[r] = e.COLOR_ATTACHMENT0 + r;
              (o.length = t.length), (s = !0);
            }
          } else
            o[0] !== e.COLOR_ATTACHMENT0 &&
              ((o[0] = e.COLOR_ATTACHMENT0), (s = !0));
        else o[0] !== e.BACK && ((o[0] = e.BACK), (s = !0));
        s &&
          (r.isWebGL2
            ? e.drawBuffers(o)
            : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(o));
      },
      useProgram: function (t) {
        return I !== t && (e.useProgram(t), (I = t), !0);
      },
      setBlending: ue,
      setMaterial: function (t, r) {
        2 === t.side ? ae(e.CULL_FACE) : se(e.CULL_FACE);
        let n = 1 === t.side;
        r && (n = !n),
          he(n),
          1 === t.blending && !1 === t.transparent
            ? ue(0)
            : ue(
                t.blending,
                t.blendEquation,
                t.blendSrc,
                t.blendDst,
                t.blendEquationAlpha,
                t.blendSrcAlpha,
                t.blendDstAlpha,
                t.blendColor,
                t.blendAlpha,
                t.premultipliedAlpha
              ),
          S.setFunc(t.depthFunc),
          S.setTest(t.depthTest),
          S.setMask(t.depthWrite),
          i.setMask(t.colorWrite);
        const o = t.stencilWrite;
        E.setTest(o),
          o &&
            (E.setMask(t.stencilWriteMask),
            E.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
            E.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
          pe(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
          !0 === t.alphaToCoverage
            ? se(e.SAMPLE_ALPHA_TO_COVERAGE)
            : ae(e.SAMPLE_ALPHA_TO_COVERAGE);
      },
      setFlipSided: he,
      setCullFace: de,
      setLineWidth: function (t) {
        t !== G && (K && e.lineWidth(t), (G = t));
      },
      setPolygonOffset: pe,
      setScissorTest: function (t) {
        t ? se(e.SCISSOR_TEST) : ae(e.SCISSOR_TEST);
      },
      activeTexture: function (t) {
        void 0 === t && (t = e.TEXTURE0 + Y - 1),
          J !== t && (e.activeTexture(t), (J = t));
      },
      bindTexture: function (t, r, n) {
        void 0 === n && (n = null === J ? e.TEXTURE0 + Y - 1 : J);
        let i = Z[n];
        void 0 === i && ((i = { type: void 0, texture: void 0 }), (Z[n] = i)),
          (i.type === t && i.texture === r) ||
            (J !== n && (e.activeTexture(n), (J = n)),
            e.bindTexture(t, r || oe[t]),
            (i.type = t),
            (i.texture = r));
      },
      unbindTexture: function () {
        const t = Z[J];
        void 0 !== t &&
          void 0 !== t.type &&
          (e.bindTexture(t.type, null),
          (t.type = void 0),
          (t.texture = void 0));
      },
      compressedTexImage2D: function () {
        try {
          e.compressedTexImage2D.apply(e, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      compressedTexImage3D: function () {
        try {
          e.compressedTexImage3D.apply(e, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      texImage2D: function () {
        try {
          e.texImage2D.apply(e, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      texImage3D: function () {
        try {
          e.texImage3D.apply(e, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      updateUBOMapping: function (t, r) {
        let n = T.get(r);
        void 0 === n && ((n = new WeakMap()), T.set(r, n));
        let i = n.get(t);
        void 0 === i && ((i = e.getUniformBlockIndex(r, t.name)), n.set(t, i));
      },
      uniformBlockBinding: function (t, r) {
        const n = T.get(r).get(t);
        M.get(r) !== n &&
          (e.uniformBlockBinding(r, n, t.__bindingPointIndex), M.set(r, n));
      },
      texStorage2D: function () {
        try {
          e.texStorage2D.apply(e, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      texStorage3D: function () {
        try {
          e.texStorage3D.apply(e, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      texSubImage2D: function () {
        try {
          e.texSubImage2D.apply(e, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      texSubImage3D: function () {
        try {
          e.texSubImage3D.apply(e, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      compressedTexSubImage2D: function () {
        try {
          e.compressedTexSubImage2D.apply(e, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      compressedTexSubImage3D: function () {
        try {
          e.compressedTexSubImage3D.apply(e, arguments);
        } catch (e) {
          console.error("THREE.WebGLState:", e);
        }
      },
      scissor: function (t) {
        !1 === re.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), re.copy(t));
      },
      viewport: function (t) {
        !1 === ne.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), ne.copy(t));
      },
      reset: function () {
        e.disable(e.BLEND),
          e.disable(e.CULL_FACE),
          e.disable(e.DEPTH_TEST),
          e.disable(e.POLYGON_OFFSET_FILL),
          e.disable(e.SCISSOR_TEST),
          e.disable(e.STENCIL_TEST),
          e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),
          e.blendEquation(e.FUNC_ADD),
          e.blendFunc(e.ONE, e.ZERO),
          e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO),
          e.blendColor(0, 0, 0, 0),
          e.colorMask(!0, !0, !0, !0),
          e.clearColor(0, 0, 0, 0),
          e.depthMask(!0),
          e.depthFunc(e.LESS),
          e.clearDepth(1),
          e.stencilMask(4294967295),
          e.stencilFunc(e.ALWAYS, 0, 4294967295),
          e.stencilOp(e.KEEP, e.KEEP, e.KEEP),
          e.clearStencil(0),
          e.cullFace(e.BACK),
          e.frontFace(e.CCW),
          e.polygonOffset(0, 0),
          e.activeTexture(e.TEXTURE0),
          e.bindFramebuffer(e.FRAMEBUFFER, null),
          !0 === n &&
            (e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
            e.bindFramebuffer(e.READ_FRAMEBUFFER, null)),
          e.useProgram(null),
          e.lineWidth(1),
          e.scissor(0, 0, e.canvas.width, e.canvas.height),
          e.viewport(0, 0, e.canvas.width, e.canvas.height),
          (A = {}),
          (J = null),
          (Z = {}),
          (R = {}),
          (P = new WeakMap()),
          (C = []),
          (I = null),
          (L = !1),
          (O = null),
          (N = null),
          (U = null),
          (D = null),
          (k = null),
          (B = null),
          (F = null),
          (H = new Rr(0, 0, 0)),
          (z = 0),
          (V = !1),
          (j = null),
          (W = null),
          (G = null),
          (X = null),
          (q = null),
          re.set(0, 0, e.canvas.width, e.canvas.height),
          ne.set(0, 0, e.canvas.width, e.canvas.height),
          i.reset(),
          S.reset(),
          E.reset();
      },
    };
  }
  function is(e, t, r, n, i, o, s) {
    const a = i.isWebGL2,
      l = t.has("WEBGL_multisampled_render_to_texture")
        ? t.get("WEBGL_multisampled_render_to_texture")
        : null,
      c =
        "undefined" != typeof navigator &&
        /OculusBrowser/g.test(navigator.userAgent),
      u = new WeakMap();
    let h;
    const d = new WeakMap();
    let p = !1;
    try {
      p =
        "undefined" != typeof OffscreenCanvas &&
        null !== new OffscreenCanvas(1, 1).getContext("2d");
    } catch (e) {}
    function f(e, t) {
      return p ? new OffscreenCanvas(e, t) : He("canvas");
    }
    function m(e, t, r, n) {
      let i = 1;
      if (
        ((e.width > n || e.height > n) && (i = n / Math.max(e.width, e.height)),
        i < 1 || !0 === t)
      ) {
        if (
          ("undefined" != typeof HTMLImageElement &&
            e instanceof HTMLImageElement) ||
          ("undefined" != typeof HTMLCanvasElement &&
            e instanceof HTMLCanvasElement) ||
          ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
        ) {
          const n = t ? Le : Math.floor,
            o = n(i * e.width),
            s = n(i * e.height);
          void 0 === h && (h = f(o, s));
          const a = r ? f(o, s) : h;
          return (
            (a.width = o),
            (a.height = s),
            a.getContext("2d").drawImage(e, 0, 0, o, s),
            console.warn(
              "THREE.WebGLRenderer: Texture has been resized from (" +
                e.width +
                "x" +
                e.height +
                ") to (" +
                o +
                "x" +
                s +
                ")."
            ),
            a
          );
        }
        return (
          "data" in e &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                e.width +
                "x" +
                e.height +
                ")."
            ),
          e
        );
      }
      return e;
    }
    function g(e) {
      return Ie(e.width) && Ie(e.height);
    }
    function _(e, t) {
      return e.generateMipmaps && t && e.minFilter !== C && e.minFilter !== O;
    }
    function v(t) {
      e.generateMipmap(t);
    }
    function y(r, n, i, o, s = !1) {
      if (!1 === a) return n;
      if (null !== r) {
        if (void 0 !== e[r]) return e[r];
        console.warn(
          "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
            r +
            "'"
        );
      }
      let l = n;
      if (
        (n === e.RED &&
          (i === e.FLOAT && (l = e.R32F),
          i === e.HALF_FLOAT && (l = e.R16F),
          i === e.UNSIGNED_BYTE && (l = e.R8)),
        n === e.RED_INTEGER &&
          (i === e.UNSIGNED_BYTE && (l = e.R8UI),
          i === e.UNSIGNED_SHORT && (l = e.R16UI),
          i === e.UNSIGNED_INT && (l = e.R32UI),
          i === e.BYTE && (l = e.R8I),
          i === e.SHORT && (l = e.R16I),
          i === e.INT && (l = e.R32I)),
        n === e.RG &&
          (i === e.FLOAT && (l = e.RG32F),
          i === e.HALF_FLOAT && (l = e.RG16F),
          i === e.UNSIGNED_BYTE && (l = e.RG8)),
        n === e.RGBA)
      ) {
        const t = s ? oe : Ye.getTransfer(o);
        i === e.FLOAT && (l = e.RGBA32F),
          i === e.HALF_FLOAT && (l = e.RGBA16F),
          i === e.UNSIGNED_BYTE && (l = t === se ? e.SRGB8_ALPHA8 : e.RGBA8),
          i === e.UNSIGNED_SHORT_4_4_4_4 && (l = e.RGBA4),
          i === e.UNSIGNED_SHORT_5_5_5_1 && (l = e.RGB5_A1);
      }
      return (
        (l !== e.R16F &&
          l !== e.R32F &&
          l !== e.RG16F &&
          l !== e.RG32F &&
          l !== e.RGBA16F &&
          l !== e.RGBA32F) ||
          t.get("EXT_color_buffer_float"),
        l
      );
    }
    function b(e, t, r) {
      return !0 === _(e, r) ||
        (e.isFramebufferTexture && e.minFilter !== C && e.minFilter !== O)
        ? Math.log2(Math.max(t.width, t.height)) + 1
        : void 0 !== e.mipmaps && e.mipmaps.length > 0
        ? e.mipmaps.length
        : e.isCompressedTexture && Array.isArray(e.image)
        ? t.mipmaps.length
        : 1;
    }
    function x(t) {
      return t === C || t === I || t === L ? e.NEAREST : e.LINEAR;
    }
    function w(e) {
      const t = e.target;
      t.removeEventListener("dispose", w),
        (function (e) {
          const t = n.get(e);
          if (void 0 === t.__webglInit) return;
          const r = e.source,
            i = d.get(r);
          if (i) {
            const n = i[t.__cacheKey];
            n.usedTimes--,
              0 === n.usedTimes && E(e),
              0 === Object.keys(i).length && d.delete(r);
          }
          n.remove(e);
        })(t),
        t.isVideoTexture && u.delete(t);
    }
    function S(t) {
      const r = t.target;
      r.removeEventListener("dispose", S),
        (function (t) {
          const r = t.texture,
            i = n.get(t),
            o = n.get(r);
          if (
            (void 0 !== o.__webglTexture &&
              (e.deleteTexture(o.__webglTexture), s.memory.textures--),
            t.depthTexture && t.depthTexture.dispose(),
            t.isWebGLCubeRenderTarget)
          )
            for (let t = 0; t < 6; t++) {
              if (Array.isArray(i.__webglFramebuffer[t]))
                for (let r = 0; r < i.__webglFramebuffer[t].length; r++)
                  e.deleteFramebuffer(i.__webglFramebuffer[t][r]);
              else e.deleteFramebuffer(i.__webglFramebuffer[t]);
              i.__webglDepthbuffer &&
                e.deleteRenderbuffer(i.__webglDepthbuffer[t]);
            }
          else {
            if (Array.isArray(i.__webglFramebuffer))
              for (let t = 0; t < i.__webglFramebuffer.length; t++)
                e.deleteFramebuffer(i.__webglFramebuffer[t]);
            else e.deleteFramebuffer(i.__webglFramebuffer);
            if (
              (i.__webglDepthbuffer &&
                e.deleteRenderbuffer(i.__webglDepthbuffer),
              i.__webglMultisampledFramebuffer &&
                e.deleteFramebuffer(i.__webglMultisampledFramebuffer),
              i.__webglColorRenderbuffer)
            )
              for (let t = 0; t < i.__webglColorRenderbuffer.length; t++)
                i.__webglColorRenderbuffer[t] &&
                  e.deleteRenderbuffer(i.__webglColorRenderbuffer[t]);
            i.__webglDepthRenderbuffer &&
              e.deleteRenderbuffer(i.__webglDepthRenderbuffer);
          }
          if (t.isWebGLMultipleRenderTargets)
            for (let t = 0, i = r.length; t < i; t++) {
              const i = n.get(r[t]);
              i.__webglTexture &&
                (e.deleteTexture(i.__webglTexture), s.memory.textures--),
                n.remove(r[t]);
            }
          n.remove(r), n.remove(t);
        })(r);
    }
    function E(t) {
      const r = n.get(t);
      e.deleteTexture(r.__webglTexture);
      const i = t.source;
      delete d.get(i)[r.__cacheKey], s.memory.textures--;
    }
    let M = 0;
    function T(t, i) {
      const o = n.get(t);
      if (
        (t.isVideoTexture &&
          (function (e) {
            const t = s.render.frame;
            u.get(e) !== t && (u.set(e, t), e.update());
          })(t),
        !1 === t.isRenderTargetTexture &&
          t.version > 0 &&
          o.__version !== t.version)
      ) {
        const e = t.image;
        if (null === e)
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but no image data found."
          );
        else {
          if (!1 !== e.complete) return void $(o, t, i);
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
          );
        }
      }
      r.bindTexture(e.TEXTURE_2D, o.__webglTexture, e.TEXTURE0 + i);
    }
    const G = { [A]: e.REPEAT, [R]: e.CLAMP_TO_EDGE, [P]: e.MIRRORED_REPEAT },
      X = {
        [C]: e.NEAREST,
        [I]: e.NEAREST_MIPMAP_NEAREST,
        [L]: e.NEAREST_MIPMAP_LINEAR,
        [O]: e.LINEAR,
        [N]: e.LINEAR_MIPMAP_NEAREST,
        [U]: e.LINEAR_MIPMAP_LINEAR,
      },
      q = {
        [ue]: e.NEVER,
        [_e]: e.ALWAYS,
        [he]: e.LESS,
        [pe]: e.LEQUAL,
        [de]: e.EQUAL,
        [ge]: e.GEQUAL,
        [fe]: e.GREATER,
        [me]: e.NOTEQUAL,
      };
    function Y(r, o, s) {
      if (
        (s
          ? (e.texParameteri(r, e.TEXTURE_WRAP_S, G[o.wrapS]),
            e.texParameteri(r, e.TEXTURE_WRAP_T, G[o.wrapT]),
            (r !== e.TEXTURE_3D && r !== e.TEXTURE_2D_ARRAY) ||
              e.texParameteri(r, e.TEXTURE_WRAP_R, G[o.wrapR]),
            e.texParameteri(r, e.TEXTURE_MAG_FILTER, X[o.magFilter]),
            e.texParameteri(r, e.TEXTURE_MIN_FILTER, X[o.minFilter]))
          : (e.texParameteri(r, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
            e.texParameteri(r, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
            (r !== e.TEXTURE_3D && r !== e.TEXTURE_2D_ARRAY) ||
              e.texParameteri(r, e.TEXTURE_WRAP_R, e.CLAMP_TO_EDGE),
            (o.wrapS === R && o.wrapT === R) ||
              console.warn(
                "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
              ),
            e.texParameteri(r, e.TEXTURE_MAG_FILTER, x(o.magFilter)),
            e.texParameteri(r, e.TEXTURE_MIN_FILTER, x(o.minFilter)),
            o.minFilter !== C &&
              o.minFilter !== O &&
              console.warn(
                "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
              )),
        o.compareFunction &&
          (e.texParameteri(r, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE),
          e.texParameteri(r, e.TEXTURE_COMPARE_FUNC, q[o.compareFunction])),
        !0 === t.has("EXT_texture_filter_anisotropic"))
      ) {
        const s = t.get("EXT_texture_filter_anisotropic");
        if (o.magFilter === C) return;
        if (o.minFilter !== L && o.minFilter !== U) return;
        if (o.type === F && !1 === t.has("OES_texture_float_linear")) return;
        if (
          !1 === a &&
          o.type === H &&
          !1 === t.has("OES_texture_half_float_linear")
        )
          return;
        (o.anisotropy > 1 || n.get(o).__currentAnisotropy) &&
          (e.texParameterf(
            r,
            s.TEXTURE_MAX_ANISOTROPY_EXT,
            Math.min(o.anisotropy, i.getMaxAnisotropy())
          ),
          (n.get(o).__currentAnisotropy = o.anisotropy));
      }
    }
    function K(t, r) {
      let n = !1;
      void 0 === t.__webglInit &&
        ((t.__webglInit = !0), r.addEventListener("dispose", w));
      const i = r.source;
      let o = d.get(i);
      void 0 === o && ((o = {}), d.set(i, o));
      const a = (function (e) {
        const t = [];
        return (
          t.push(e.wrapS),
          t.push(e.wrapT),
          t.push(e.wrapR || 0),
          t.push(e.magFilter),
          t.push(e.minFilter),
          t.push(e.anisotropy),
          t.push(e.internalFormat),
          t.push(e.format),
          t.push(e.type),
          t.push(e.generateMipmaps),
          t.push(e.premultiplyAlpha),
          t.push(e.flipY),
          t.push(e.unpackAlignment),
          t.push(e.colorSpace),
          t.join()
        );
      })(r);
      if (a !== t.__cacheKey) {
        void 0 === o[a] &&
          ((o[a] = { texture: e.createTexture(), usedTimes: 0 }),
          s.memory.textures++,
          (n = !0)),
          o[a].usedTimes++;
        const i = o[t.__cacheKey];
        void 0 !== i &&
          (o[t.__cacheKey].usedTimes--, 0 === i.usedTimes && E(r)),
          (t.__cacheKey = a),
          (t.__webglTexture = o[a].texture);
      }
      return n;
    }
    function $(t, s, l) {
      let c = e.TEXTURE_2D;
      (s.isDataArrayTexture || s.isCompressedArrayTexture) &&
        (c = e.TEXTURE_2D_ARRAY),
        s.isData3DTexture && (c = e.TEXTURE_3D);
      const u = K(t, s),
        h = s.source;
      r.bindTexture(c, t.__webglTexture, e.TEXTURE0 + l);
      const d = n.get(h);
      if (h.version !== d.__version || !0 === u) {
        r.activeTexture(e.TEXTURE0 + l);
        const t = Ye.getPrimaries(Ye.workingColorSpace),
          n = s.colorSpace === ee ? null : Ye.getPrimaries(s.colorSpace),
          p = s.colorSpace === ee || t === n ? e.NONE : e.BROWSER_DEFAULT_WEBGL;
        e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, s.flipY),
          e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.premultiplyAlpha),
          e.pixelStorei(e.UNPACK_ALIGNMENT, s.unpackAlignment),
          e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, p);
        const f =
          (function (e) {
            return (
              !a &&
              (e.wrapS !== R ||
                e.wrapT !== R ||
                (e.minFilter !== C && e.minFilter !== O))
            );
          })(s) && !1 === g(s.image);
        let x = m(s.image, f, !1, i.maxTextureSize);
        x = ie(s, x);
        const w = g(x) || a,
          S = o.convert(s.format, s.colorSpace);
        let E,
          M = o.convert(s.type),
          T = y(s.internalFormat, S, M, s.colorSpace, s.isVideoTexture);
        Y(c, s, w);
        const A = s.mipmaps,
          P = a && !0 !== s.isVideoTexture && 36196 !== T,
          I = void 0 === d.__version || !0 === u,
          L = b(s, x, w);
        if (s.isDepthTexture)
          (T = e.DEPTH_COMPONENT),
            a
              ? (T =
                  s.type === F
                    ? e.DEPTH_COMPONENT32F
                    : s.type === B
                    ? e.DEPTH_COMPONENT24
                    : s.type === z
                    ? e.DEPTH24_STENCIL8
                    : e.DEPTH_COMPONENT16)
              : s.type === F &&
                console.error(
                  "WebGLRenderer: Floating point depth texture requires WebGL2."
                ),
            s.format === j &&
              T === e.DEPTH_COMPONENT &&
              s.type !== k &&
              s.type !== B &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
              ),
              (s.type = B),
              (M = o.convert(s.type))),
            s.format === W &&
              T === e.DEPTH_COMPONENT &&
              ((T = e.DEPTH_STENCIL),
              s.type !== z &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                ),
                (s.type = z),
                (M = o.convert(s.type)))),
            I &&
              (P
                ? r.texStorage2D(e.TEXTURE_2D, 1, T, x.width, x.height)
                : r.texImage2D(
                    e.TEXTURE_2D,
                    0,
                    T,
                    x.width,
                    x.height,
                    0,
                    S,
                    M,
                    null
                  ));
        else if (s.isDataTexture)
          if (A.length > 0 && w) {
            P &&
              I &&
              r.texStorage2D(e.TEXTURE_2D, L, T, A[0].width, A[0].height);
            for (let t = 0, n = A.length; t < n; t++)
              (E = A[t]),
                P
                  ? r.texSubImage2D(
                      e.TEXTURE_2D,
                      t,
                      0,
                      0,
                      E.width,
                      E.height,
                      S,
                      M,
                      E.data
                    )
                  : r.texImage2D(
                      e.TEXTURE_2D,
                      t,
                      T,
                      E.width,
                      E.height,
                      0,
                      S,
                      M,
                      E.data
                    );
            s.generateMipmaps = !1;
          } else
            P
              ? (I && r.texStorage2D(e.TEXTURE_2D, L, T, x.width, x.height),
                r.texSubImage2D(
                  e.TEXTURE_2D,
                  0,
                  0,
                  0,
                  x.width,
                  x.height,
                  S,
                  M,
                  x.data
                ))
              : r.texImage2D(
                  e.TEXTURE_2D,
                  0,
                  T,
                  x.width,
                  x.height,
                  0,
                  S,
                  M,
                  x.data
                );
        else if (s.isCompressedTexture)
          if (s.isCompressedArrayTexture) {
            P &&
              I &&
              r.texStorage3D(
                e.TEXTURE_2D_ARRAY,
                L,
                T,
                A[0].width,
                A[0].height,
                x.depth
              );
            for (let t = 0, n = A.length; t < n; t++)
              (E = A[t]),
                s.format !== V
                  ? null !== S
                    ? P
                      ? r.compressedTexSubImage3D(
                          e.TEXTURE_2D_ARRAY,
                          t,
                          0,
                          0,
                          0,
                          E.width,
                          E.height,
                          x.depth,
                          S,
                          E.data,
                          0,
                          0
                        )
                      : r.compressedTexImage3D(
                          e.TEXTURE_2D_ARRAY,
                          t,
                          T,
                          E.width,
                          E.height,
                          x.depth,
                          0,
                          E.data,
                          0,
                          0
                        )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      )
                  : P
                  ? r.texSubImage3D(
                      e.TEXTURE_2D_ARRAY,
                      t,
                      0,
                      0,
                      0,
                      E.width,
                      E.height,
                      x.depth,
                      S,
                      M,
                      E.data
                    )
                  : r.texImage3D(
                      e.TEXTURE_2D_ARRAY,
                      t,
                      T,
                      E.width,
                      E.height,
                      x.depth,
                      0,
                      S,
                      M,
                      E.data
                    );
          } else {
            P &&
              I &&
              r.texStorage2D(e.TEXTURE_2D, L, T, A[0].width, A[0].height);
            for (let t = 0, n = A.length; t < n; t++)
              (E = A[t]),
                s.format !== V
                  ? null !== S
                    ? P
                      ? r.compressedTexSubImage2D(
                          e.TEXTURE_2D,
                          t,
                          0,
                          0,
                          E.width,
                          E.height,
                          S,
                          E.data
                        )
                      : r.compressedTexImage2D(
                          e.TEXTURE_2D,
                          t,
                          T,
                          E.width,
                          E.height,
                          0,
                          E.data
                        )
                    : console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      )
                  : P
                  ? r.texSubImage2D(
                      e.TEXTURE_2D,
                      t,
                      0,
                      0,
                      E.width,
                      E.height,
                      S,
                      M,
                      E.data
                    )
                  : r.texImage2D(
                      e.TEXTURE_2D,
                      t,
                      T,
                      E.width,
                      E.height,
                      0,
                      S,
                      M,
                      E.data
                    );
          }
        else if (s.isDataArrayTexture)
          P
            ? (I &&
                r.texStorage3D(
                  e.TEXTURE_2D_ARRAY,
                  L,
                  T,
                  x.width,
                  x.height,
                  x.depth
                ),
              r.texSubImage3D(
                e.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                x.width,
                x.height,
                x.depth,
                S,
                M,
                x.data
              ))
            : r.texImage3D(
                e.TEXTURE_2D_ARRAY,
                0,
                T,
                x.width,
                x.height,
                x.depth,
                0,
                S,
                M,
                x.data
              );
        else if (s.isData3DTexture)
          P
            ? (I &&
                r.texStorage3D(e.TEXTURE_3D, L, T, x.width, x.height, x.depth),
              r.texSubImage3D(
                e.TEXTURE_3D,
                0,
                0,
                0,
                0,
                x.width,
                x.height,
                x.depth,
                S,
                M,
                x.data
              ))
            : r.texImage3D(
                e.TEXTURE_3D,
                0,
                T,
                x.width,
                x.height,
                x.depth,
                0,
                S,
                M,
                x.data
              );
        else if (s.isFramebufferTexture) {
          if (I)
            if (P) r.texStorage2D(e.TEXTURE_2D, L, T, x.width, x.height);
            else {
              let t = x.width,
                n = x.height;
              for (let i = 0; i < L; i++)
                r.texImage2D(e.TEXTURE_2D, i, T, t, n, 0, S, M, null),
                  (t >>= 1),
                  (n >>= 1);
            }
        } else if (A.length > 0 && w) {
          P && I && r.texStorage2D(e.TEXTURE_2D, L, T, A[0].width, A[0].height);
          for (let t = 0, n = A.length; t < n; t++)
            (E = A[t]),
              P
                ? r.texSubImage2D(e.TEXTURE_2D, t, 0, 0, S, M, E)
                : r.texImage2D(e.TEXTURE_2D, t, T, S, M, E);
          s.generateMipmaps = !1;
        } else
          P
            ? (I && r.texStorage2D(e.TEXTURE_2D, L, T, x.width, x.height),
              r.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, S, M, x))
            : r.texImage2D(e.TEXTURE_2D, 0, T, S, M, x);
        _(s, w) && v(c), (d.__version = h.version), s.onUpdate && s.onUpdate(s);
      }
      t.__version = s.version;
    }
    function Q(t, i, s, a, c, u) {
      const h = o.convert(s.format, s.colorSpace),
        d = o.convert(s.type),
        p = y(s.internalFormat, h, d, s.colorSpace);
      if (!n.get(i).__hasExternalTextures) {
        const t = Math.max(1, i.width >> u),
          n = Math.max(1, i.height >> u);
        c === e.TEXTURE_3D || c === e.TEXTURE_2D_ARRAY
          ? r.texImage3D(c, u, p, t, n, i.depth, 0, h, d, null)
          : r.texImage2D(c, u, p, t, n, 0, h, d, null);
      }
      r.bindFramebuffer(e.FRAMEBUFFER, t),
        ne(i)
          ? l.framebufferTexture2DMultisampleEXT(
              e.FRAMEBUFFER,
              a,
              c,
              n.get(s).__webglTexture,
              0,
              te(i)
            )
          : (c === e.TEXTURE_2D ||
              (c >= e.TEXTURE_CUBE_MAP_POSITIVE_X &&
                c <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
            e.framebufferTexture2D(
              e.FRAMEBUFFER,
              a,
              c,
              n.get(s).__webglTexture,
              u
            ),
        r.bindFramebuffer(e.FRAMEBUFFER, null);
    }
    function J(t, r, n) {
      if (
        (e.bindRenderbuffer(e.RENDERBUFFER, t),
        r.depthBuffer && !r.stencilBuffer)
      ) {
        let i = !0 === a ? e.DEPTH_COMPONENT24 : e.DEPTH_COMPONENT16;
        if (n || ne(r)) {
          const t = r.depthTexture;
          t &&
            t.isDepthTexture &&
            (t.type === F
              ? (i = e.DEPTH_COMPONENT32F)
              : t.type === B && (i = e.DEPTH_COMPONENT24));
          const n = te(r);
          ne(r)
            ? l.renderbufferStorageMultisampleEXT(
                e.RENDERBUFFER,
                n,
                i,
                r.width,
                r.height
              )
            : e.renderbufferStorageMultisample(
                e.RENDERBUFFER,
                n,
                i,
                r.width,
                r.height
              );
        } else e.renderbufferStorage(e.RENDERBUFFER, i, r.width, r.height);
        e.framebufferRenderbuffer(
          e.FRAMEBUFFER,
          e.DEPTH_ATTACHMENT,
          e.RENDERBUFFER,
          t
        );
      } else if (r.depthBuffer && r.stencilBuffer) {
        const i = te(r);
        n && !1 === ne(r)
          ? e.renderbufferStorageMultisample(
              e.RENDERBUFFER,
              i,
              e.DEPTH24_STENCIL8,
              r.width,
              r.height
            )
          : ne(r)
          ? l.renderbufferStorageMultisampleEXT(
              e.RENDERBUFFER,
              i,
              e.DEPTH24_STENCIL8,
              r.width,
              r.height
            )
          : e.renderbufferStorage(
              e.RENDERBUFFER,
              e.DEPTH_STENCIL,
              r.width,
              r.height
            ),
          e.framebufferRenderbuffer(
            e.FRAMEBUFFER,
            e.DEPTH_STENCIL_ATTACHMENT,
            e.RENDERBUFFER,
            t
          );
      } else {
        const t =
          !0 === r.isWebGLMultipleRenderTargets ? r.texture : [r.texture];
        for (let i = 0; i < t.length; i++) {
          const s = t[i],
            a = o.convert(s.format, s.colorSpace),
            c = o.convert(s.type),
            u = y(s.internalFormat, a, c, s.colorSpace),
            h = te(r);
          n && !1 === ne(r)
            ? e.renderbufferStorageMultisample(
                e.RENDERBUFFER,
                h,
                u,
                r.width,
                r.height
              )
            : ne(r)
            ? l.renderbufferStorageMultisampleEXT(
                e.RENDERBUFFER,
                h,
                u,
                r.width,
                r.height
              )
            : e.renderbufferStorage(e.RENDERBUFFER, u, r.width, r.height);
        }
      }
      e.bindRenderbuffer(e.RENDERBUFFER, null);
    }
    function Z(t) {
      const i = n.get(t),
        o = !0 === t.isWebGLCubeRenderTarget;
      if (t.depthTexture && !i.__autoAllocateDepthBuffer) {
        if (o)
          throw new Error(
            "target.depthTexture not supported in Cube render targets"
          );
        !(function (t, i) {
          if (i && i.isWebGLCubeRenderTarget)
            throw new Error(
              "Depth Texture with cube render targets is not supported"
            );
          if (
            (r.bindFramebuffer(e.FRAMEBUFFER, t),
            !i.depthTexture || !i.depthTexture.isDepthTexture)
          )
            throw new Error(
              "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
            );
          (n.get(i.depthTexture).__webglTexture &&
            i.depthTexture.image.width === i.width &&
            i.depthTexture.image.height === i.height) ||
            ((i.depthTexture.image.width = i.width),
            (i.depthTexture.image.height = i.height),
            (i.depthTexture.needsUpdate = !0)),
            T(i.depthTexture, 0);
          const o = n.get(i.depthTexture).__webglTexture,
            s = te(i);
          if (i.depthTexture.format === j)
            ne(i)
              ? l.framebufferTexture2DMultisampleEXT(
                  e.FRAMEBUFFER,
                  e.DEPTH_ATTACHMENT,
                  e.TEXTURE_2D,
                  o,
                  0,
                  s
                )
              : e.framebufferTexture2D(
                  e.FRAMEBUFFER,
                  e.DEPTH_ATTACHMENT,
                  e.TEXTURE_2D,
                  o,
                  0
                );
          else {
            if (i.depthTexture.format !== W)
              throw new Error("Unknown depthTexture format");
            ne(i)
              ? l.framebufferTexture2DMultisampleEXT(
                  e.FRAMEBUFFER,
                  e.DEPTH_STENCIL_ATTACHMENT,
                  e.TEXTURE_2D,
                  o,
                  0,
                  s
                )
              : e.framebufferTexture2D(
                  e.FRAMEBUFFER,
                  e.DEPTH_STENCIL_ATTACHMENT,
                  e.TEXTURE_2D,
                  o,
                  0
                );
          }
        })(i.__webglFramebuffer, t);
      } else if (o) {
        i.__webglDepthbuffer = [];
        for (let n = 0; n < 6; n++)
          r.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer[n]),
            (i.__webglDepthbuffer[n] = e.createRenderbuffer()),
            J(i.__webglDepthbuffer[n], t, !1);
      } else
        r.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer),
          (i.__webglDepthbuffer = e.createRenderbuffer()),
          J(i.__webglDepthbuffer, t, !1);
      r.bindFramebuffer(e.FRAMEBUFFER, null);
    }
    function te(e) {
      return Math.min(i.maxSamples, e.samples);
    }
    function ne(e) {
      const r = n.get(e);
      return (
        a &&
        e.samples > 0 &&
        !0 === t.has("WEBGL_multisampled_render_to_texture") &&
        !1 !== r.__useRenderToTexture
      );
    }
    function ie(e, r) {
      const n = e.colorSpace,
        i = e.format,
        o = e.type;
      return (
        !0 === e.isCompressedTexture ||
          !0 === e.isVideoTexture ||
          e.format === be ||
          (n !== re &&
            n !== ee &&
            (Ye.getTransfer(n) === se
              ? !1 === a
                ? !0 === t.has("EXT_sRGB") && i === V
                  ? ((e.format = be),
                    (e.minFilter = O),
                    (e.generateMipmaps = !1))
                  : (r = Je.sRGBToLinear(r))
                : (i === V && o === D) ||
                  console.warn(
                    "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                  )
              : console.error(
                  "THREE.WebGLTextures: Unsupported texture color space:",
                  n
                ))),
        r
      );
    }
    (this.allocateTextureUnit = function () {
      const e = M;
      return (
        e >= i.maxTextures &&
          console.warn(
            "THREE.WebGLTextures: Trying to use " +
              e +
              " texture units while this GPU supports only " +
              i.maxTextures
          ),
        (M += 1),
        e
      );
    }),
      (this.resetTextureUnits = function () {
        M = 0;
      }),
      (this.setTexture2D = T),
      (this.setTexture2DArray = function (t, i) {
        const o = n.get(t);
        t.version > 0 && o.__version !== t.version
          ? $(o, t, i)
          : r.bindTexture(e.TEXTURE_2D_ARRAY, o.__webglTexture, e.TEXTURE0 + i);
      }),
      (this.setTexture3D = function (t, i) {
        const o = n.get(t);
        t.version > 0 && o.__version !== t.version
          ? $(o, t, i)
          : r.bindTexture(e.TEXTURE_3D, o.__webglTexture, e.TEXTURE0 + i);
      }),
      (this.setTextureCube = function (t, s) {
        const l = n.get(t);
        t.version > 0 && l.__version !== t.version
          ? (function (t, s, l) {
              if (6 !== s.image.length) return;
              const c = K(t, s),
                u = s.source;
              r.bindTexture(
                e.TEXTURE_CUBE_MAP,
                t.__webglTexture,
                e.TEXTURE0 + l
              );
              const h = n.get(u);
              if (u.version !== h.__version || !0 === c) {
                r.activeTexture(e.TEXTURE0 + l);
                const t = Ye.getPrimaries(Ye.workingColorSpace),
                  n =
                    s.colorSpace === ee ? null : Ye.getPrimaries(s.colorSpace),
                  d =
                    s.colorSpace === ee || t === n
                      ? e.NONE
                      : e.BROWSER_DEFAULT_WEBGL;
                e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, s.flipY),
                  e.pixelStorei(
                    e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                    s.premultiplyAlpha
                  ),
                  e.pixelStorei(e.UNPACK_ALIGNMENT, s.unpackAlignment),
                  e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
                const p =
                    s.isCompressedTexture || s.image[0].isCompressedTexture,
                  f = s.image[0] && s.image[0].isDataTexture,
                  x = [];
                for (let e = 0; e < 6; e++)
                  (x[e] =
                    p || f
                      ? f
                        ? s.image[e].image
                        : s.image[e]
                      : m(s.image[e], !1, !0, i.maxCubemapSize)),
                    (x[e] = ie(s, x[e]));
                const w = x[0],
                  S = g(w) || a,
                  E = o.convert(s.format, s.colorSpace),
                  M = o.convert(s.type),
                  T = y(s.internalFormat, E, M, s.colorSpace),
                  A = a && !0 !== s.isVideoTexture,
                  R = void 0 === h.__version || !0 === c;
                let P,
                  C = b(s, w, S);
                if ((Y(e.TEXTURE_CUBE_MAP, s, S), p)) {
                  A &&
                    R &&
                    r.texStorage2D(e.TEXTURE_CUBE_MAP, C, T, w.width, w.height);
                  for (let t = 0; t < 6; t++) {
                    P = x[t].mipmaps;
                    for (let n = 0; n < P.length; n++) {
                      const i = P[n];
                      s.format !== V
                        ? null !== E
                          ? A
                            ? r.compressedTexSubImage2D(
                                e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                n,
                                0,
                                0,
                                i.width,
                                i.height,
                                E,
                                i.data
                              )
                            : r.compressedTexImage2D(
                                e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                n,
                                T,
                                i.width,
                                i.height,
                                0,
                                i.data
                              )
                          : console.warn(
                              "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                            )
                        : A
                        ? r.texSubImage2D(
                            e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                            n,
                            0,
                            0,
                            i.width,
                            i.height,
                            E,
                            M,
                            i.data
                          )
                        : r.texImage2D(
                            e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                            n,
                            T,
                            i.width,
                            i.height,
                            0,
                            E,
                            M,
                            i.data
                          );
                    }
                  }
                } else {
                  (P = s.mipmaps),
                    A &&
                      R &&
                      (P.length > 0 && C++,
                      r.texStorage2D(
                        e.TEXTURE_CUBE_MAP,
                        C,
                        T,
                        x[0].width,
                        x[0].height
                      ));
                  for (let t = 0; t < 6; t++)
                    if (f) {
                      A
                        ? r.texSubImage2D(
                            e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                            0,
                            0,
                            0,
                            x[t].width,
                            x[t].height,
                            E,
                            M,
                            x[t].data
                          )
                        : r.texImage2D(
                            e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                            0,
                            T,
                            x[t].width,
                            x[t].height,
                            0,
                            E,
                            M,
                            x[t].data
                          );
                      for (let n = 0; n < P.length; n++) {
                        const i = P[n].image[t].image;
                        A
                          ? r.texSubImage2D(
                              e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                              n + 1,
                              0,
                              0,
                              i.width,
                              i.height,
                              E,
                              M,
                              i.data
                            )
                          : r.texImage2D(
                              e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                              n + 1,
                              T,
                              i.width,
                              i.height,
                              0,
                              E,
                              M,
                              i.data
                            );
                      }
                    } else {
                      A
                        ? r.texSubImage2D(
                            e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                            0,
                            0,
                            0,
                            E,
                            M,
                            x[t]
                          )
                        : r.texImage2D(
                            e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                            0,
                            T,
                            E,
                            M,
                            x[t]
                          );
                      for (let n = 0; n < P.length; n++) {
                        const i = P[n];
                        A
                          ? r.texSubImage2D(
                              e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                              n + 1,
                              0,
                              0,
                              E,
                              M,
                              i.image[t]
                            )
                          : r.texImage2D(
                              e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                              n + 1,
                              T,
                              E,
                              M,
                              i.image[t]
                            );
                      }
                    }
                }
                _(s, S) && v(e.TEXTURE_CUBE_MAP),
                  (h.__version = u.version),
                  s.onUpdate && s.onUpdate(s);
              }
              t.__version = s.version;
            })(l, t, s)
          : r.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture, e.TEXTURE0 + s);
      }),
      (this.rebindTextures = function (t, r, i) {
        const o = n.get(t);
        void 0 !== r &&
          Q(
            o.__webglFramebuffer,
            t,
            t.texture,
            e.COLOR_ATTACHMENT0,
            e.TEXTURE_2D,
            0
          ),
          void 0 !== i && Z(t);
      }),
      (this.setupRenderTarget = function (t) {
        const l = t.texture,
          c = n.get(t),
          u = n.get(l);
        t.addEventListener("dispose", S),
          !0 !== t.isWebGLMultipleRenderTargets &&
            (void 0 === u.__webglTexture &&
              (u.__webglTexture = e.createTexture()),
            (u.__version = l.version),
            s.memory.textures++);
        const h = !0 === t.isWebGLCubeRenderTarget,
          d = !0 === t.isWebGLMultipleRenderTargets,
          p = g(t) || a;
        if (h) {
          c.__webglFramebuffer = [];
          for (let t = 0; t < 6; t++)
            if (a && l.mipmaps && l.mipmaps.length > 0) {
              c.__webglFramebuffer[t] = [];
              for (let r = 0; r < l.mipmaps.length; r++)
                c.__webglFramebuffer[t][r] = e.createFramebuffer();
            } else c.__webglFramebuffer[t] = e.createFramebuffer();
        } else {
          if (a && l.mipmaps && l.mipmaps.length > 0) {
            c.__webglFramebuffer = [];
            for (let t = 0; t < l.mipmaps.length; t++)
              c.__webglFramebuffer[t] = e.createFramebuffer();
          } else c.__webglFramebuffer = e.createFramebuffer();
          if (d)
            if (i.drawBuffers) {
              const r = t.texture;
              for (let t = 0, i = r.length; t < i; t++) {
                const i = n.get(r[t]);
                void 0 === i.__webglTexture &&
                  ((i.__webglTexture = e.createTexture()), s.memory.textures++);
              }
            } else
              console.warn(
                "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
              );
          if (a && t.samples > 0 && !1 === ne(t)) {
            const n = d ? l : [l];
            (c.__webglMultisampledFramebuffer = e.createFramebuffer()),
              (c.__webglColorRenderbuffer = []),
              r.bindFramebuffer(
                e.FRAMEBUFFER,
                c.__webglMultisampledFramebuffer
              );
            for (let r = 0; r < n.length; r++) {
              const i = n[r];
              (c.__webglColorRenderbuffer[r] = e.createRenderbuffer()),
                e.bindRenderbuffer(
                  e.RENDERBUFFER,
                  c.__webglColorRenderbuffer[r]
                );
              const s = o.convert(i.format, i.colorSpace),
                a = o.convert(i.type),
                l = y(
                  i.internalFormat,
                  s,
                  a,
                  i.colorSpace,
                  !0 === t.isXRRenderTarget
                ),
                u = te(t);
              e.renderbufferStorageMultisample(
                e.RENDERBUFFER,
                u,
                l,
                t.width,
                t.height
              ),
                e.framebufferRenderbuffer(
                  e.FRAMEBUFFER,
                  e.COLOR_ATTACHMENT0 + r,
                  e.RENDERBUFFER,
                  c.__webglColorRenderbuffer[r]
                );
            }
            e.bindRenderbuffer(e.RENDERBUFFER, null),
              t.depthBuffer &&
                ((c.__webglDepthRenderbuffer = e.createRenderbuffer()),
                J(c.__webglDepthRenderbuffer, t, !0)),
              r.bindFramebuffer(e.FRAMEBUFFER, null);
          }
        }
        if (h) {
          r.bindTexture(e.TEXTURE_CUBE_MAP, u.__webglTexture),
            Y(e.TEXTURE_CUBE_MAP, l, p);
          for (let r = 0; r < 6; r++)
            if (a && l.mipmaps && l.mipmaps.length > 0)
              for (let n = 0; n < l.mipmaps.length; n++)
                Q(
                  c.__webglFramebuffer[r][n],
                  t,
                  l,
                  e.COLOR_ATTACHMENT0,
                  e.TEXTURE_CUBE_MAP_POSITIVE_X + r,
                  n
                );
            else
              Q(
                c.__webglFramebuffer[r],
                t,
                l,
                e.COLOR_ATTACHMENT0,
                e.TEXTURE_CUBE_MAP_POSITIVE_X + r,
                0
              );
          _(l, p) && v(e.TEXTURE_CUBE_MAP), r.unbindTexture();
        } else if (d) {
          const i = t.texture;
          for (let o = 0, s = i.length; o < s; o++) {
            const s = i[o],
              a = n.get(s);
            r.bindTexture(e.TEXTURE_2D, a.__webglTexture),
              Y(e.TEXTURE_2D, s, p),
              Q(
                c.__webglFramebuffer,
                t,
                s,
                e.COLOR_ATTACHMENT0 + o,
                e.TEXTURE_2D,
                0
              ),
              _(s, p) && v(e.TEXTURE_2D);
          }
          r.unbindTexture();
        } else {
          let n = e.TEXTURE_2D;
          if (
            ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) &&
              (a
                ? (n = t.isWebGL3DRenderTarget
                    ? e.TEXTURE_3D
                    : e.TEXTURE_2D_ARRAY)
                : console.error(
                    "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
                  )),
            r.bindTexture(n, u.__webglTexture),
            Y(n, l, p),
            a && l.mipmaps && l.mipmaps.length > 0)
          )
            for (let r = 0; r < l.mipmaps.length; r++)
              Q(c.__webglFramebuffer[r], t, l, e.COLOR_ATTACHMENT0, n, r);
          else Q(c.__webglFramebuffer, t, l, e.COLOR_ATTACHMENT0, n, 0);
          _(l, p) && v(n), r.unbindTexture();
        }
        t.depthBuffer && Z(t);
      }),
      (this.updateRenderTargetMipmap = function (t) {
        const i = g(t) || a,
          o = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
        for (let s = 0, a = o.length; s < a; s++) {
          const a = o[s];
          if (_(a, i)) {
            const i = t.isWebGLCubeRenderTarget
                ? e.TEXTURE_CUBE_MAP
                : e.TEXTURE_2D,
              o = n.get(a).__webglTexture;
            r.bindTexture(i, o), v(i), r.unbindTexture();
          }
        }
      }),
      (this.updateMultisampleRenderTarget = function (t) {
        if (a && t.samples > 0 && !1 === ne(t)) {
          const i = t.isWebGLMultipleRenderTargets ? t.texture : [t.texture],
            o = t.width,
            s = t.height;
          let a = e.COLOR_BUFFER_BIT;
          const l = [],
            u = t.stencilBuffer
              ? e.DEPTH_STENCIL_ATTACHMENT
              : e.DEPTH_ATTACHMENT,
            h = n.get(t),
            d = !0 === t.isWebGLMultipleRenderTargets;
          if (d)
            for (let t = 0; t < i.length; t++)
              r.bindFramebuffer(
                e.FRAMEBUFFER,
                h.__webglMultisampledFramebuffer
              ),
                e.framebufferRenderbuffer(
                  e.FRAMEBUFFER,
                  e.COLOR_ATTACHMENT0 + t,
                  e.RENDERBUFFER,
                  null
                ),
                r.bindFramebuffer(e.FRAMEBUFFER, h.__webglFramebuffer),
                e.framebufferTexture2D(
                  e.DRAW_FRAMEBUFFER,
                  e.COLOR_ATTACHMENT0 + t,
                  e.TEXTURE_2D,
                  null,
                  0
                );
          r.bindFramebuffer(
            e.READ_FRAMEBUFFER,
            h.__webglMultisampledFramebuffer
          ),
            r.bindFramebuffer(e.DRAW_FRAMEBUFFER, h.__webglFramebuffer);
          for (let r = 0; r < i.length; r++) {
            l.push(e.COLOR_ATTACHMENT0 + r), t.depthBuffer && l.push(u);
            const p = void 0 !== h.__ignoreDepthValues && h.__ignoreDepthValues;
            if (
              (!1 === p &&
                (t.depthBuffer && (a |= e.DEPTH_BUFFER_BIT),
                t.stencilBuffer && (a |= e.STENCIL_BUFFER_BIT)),
              d &&
                e.framebufferRenderbuffer(
                  e.READ_FRAMEBUFFER,
                  e.COLOR_ATTACHMENT0,
                  e.RENDERBUFFER,
                  h.__webglColorRenderbuffer[r]
                ),
              !0 === p &&
                (e.invalidateFramebuffer(e.READ_FRAMEBUFFER, [u]),
                e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [u])),
              d)
            ) {
              const t = n.get(i[r]).__webglTexture;
              e.framebufferTexture2D(
                e.DRAW_FRAMEBUFFER,
                e.COLOR_ATTACHMENT0,
                e.TEXTURE_2D,
                t,
                0
              );
            }
            e.blitFramebuffer(0, 0, o, s, 0, 0, o, s, a, e.NEAREST),
              c && e.invalidateFramebuffer(e.READ_FRAMEBUFFER, l);
          }
          if (
            (r.bindFramebuffer(e.READ_FRAMEBUFFER, null),
            r.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
            d)
          )
            for (let t = 0; t < i.length; t++) {
              r.bindFramebuffer(
                e.FRAMEBUFFER,
                h.__webglMultisampledFramebuffer
              ),
                e.framebufferRenderbuffer(
                  e.FRAMEBUFFER,
                  e.COLOR_ATTACHMENT0 + t,
                  e.RENDERBUFFER,
                  h.__webglColorRenderbuffer[t]
                );
              const o = n.get(i[t]).__webglTexture;
              r.bindFramebuffer(e.FRAMEBUFFER, h.__webglFramebuffer),
                e.framebufferTexture2D(
                  e.DRAW_FRAMEBUFFER,
                  e.COLOR_ATTACHMENT0 + t,
                  e.TEXTURE_2D,
                  o,
                  0
                );
            }
          r.bindFramebuffer(
            e.DRAW_FRAMEBUFFER,
            h.__webglMultisampledFramebuffer
          );
        }
      }),
      (this.setupDepthRenderbuffer = Z),
      (this.setupFrameBufferTexture = Q),
      (this.useMultisampledRTT = ne);
  }
  function os(e, t, r) {
    const n = r.isWebGL2;
    return {
      convert: function (r, i = "") {
        let o;
        const s = Ye.getTransfer(i);
        if (r === D) return e.UNSIGNED_BYTE;
        if (1017 === r) return e.UNSIGNED_SHORT_4_4_4_4;
        if (1018 === r) return e.UNSIGNED_SHORT_5_5_5_1;
        if (1010 === r) return e.BYTE;
        if (1011 === r) return e.SHORT;
        if (r === k) return e.UNSIGNED_SHORT;
        if (1013 === r) return e.INT;
        if (r === B) return e.UNSIGNED_INT;
        if (r === F) return e.FLOAT;
        if (r === H)
          return n
            ? e.HALF_FLOAT
            : ((o = t.get("OES_texture_half_float")),
              null !== o ? o.HALF_FLOAT_OES : null);
        if (1021 === r) return e.ALPHA;
        if (r === V) return e.RGBA;
        if (1024 === r) return e.LUMINANCE;
        if (1025 === r) return e.LUMINANCE_ALPHA;
        if (r === j) return e.DEPTH_COMPONENT;
        if (r === W) return e.DEPTH_STENCIL;
        if (r === be)
          return (o = t.get("EXT_sRGB")), null !== o ? o.SRGB_ALPHA_EXT : null;
        if (1028 === r) return e.RED;
        if (1029 === r) return e.RED_INTEGER;
        if (1030 === r) return e.RG;
        if (1031 === r) return e.RG_INTEGER;
        if (1033 === r) return e.RGBA_INTEGER;
        if (r === G || r === X || r === q || r === Y)
          if (s === se) {
            if (((o = t.get("WEBGL_compressed_texture_s3tc_srgb")), null === o))
              return null;
            if (r === G) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (r === X) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (r === q) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (r === Y) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else {
            if (((o = t.get("WEBGL_compressed_texture_s3tc")), null === o))
              return null;
            if (r === G) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (r === X) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (r === q) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (r === Y) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          }
        if (35840 === r || 35841 === r || 35842 === r || 35843 === r) {
          if (((o = t.get("WEBGL_compressed_texture_pvrtc")), null === o))
            return null;
          if (35840 === r) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (35841 === r) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (35842 === r) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (35843 === r) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        if (36196 === r)
          return (
            (o = t.get("WEBGL_compressed_texture_etc1")),
            null !== o ? o.COMPRESSED_RGB_ETC1_WEBGL : null
          );
        if (37492 === r || 37496 === r) {
          if (((o = t.get("WEBGL_compressed_texture_etc")), null === o))
            return null;
          if (37492 === r)
            return s === se ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
          if (37496 === r)
            return s === se
              ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
              : o.COMPRESSED_RGBA8_ETC2_EAC;
        }
        if (
          37808 === r ||
          37809 === r ||
          37810 === r ||
          37811 === r ||
          37812 === r ||
          37813 === r ||
          37814 === r ||
          37815 === r ||
          37816 === r ||
          37817 === r ||
          37818 === r ||
          37819 === r ||
          37820 === r ||
          37821 === r
        ) {
          if (((o = t.get("WEBGL_compressed_texture_astc")), null === o))
            return null;
          if (37808 === r)
            return s === se
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
              : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
          if (37809 === r)
            return s === se
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
              : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
          if (37810 === r)
            return s === se
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
              : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
          if (37811 === r)
            return s === se
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
              : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
          if (37812 === r)
            return s === se
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
              : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
          if (37813 === r)
            return s === se
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
              : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
          if (37814 === r)
            return s === se
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
              : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
          if (37815 === r)
            return s === se
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
              : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
          if (37816 === r)
            return s === se
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
              : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
          if (37817 === r)
            return s === se
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
              : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
          if (37818 === r)
            return s === se
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
              : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
          if (37819 === r)
            return s === se
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
              : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
          if (37820 === r)
            return s === se
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
              : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
          if (37821 === r)
            return s === se
              ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
              : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
        }
        if (r === K || 36494 === r || 36495 === r) {
          if (((o = t.get("EXT_texture_compression_bptc")), null === o))
            return null;
          if (r === K)
            return s === se
              ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
              : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
          if (36494 === r) return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
          if (36495 === r) return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
        }
        if (36283 === r || 36284 === r || 36285 === r || 36286 === r) {
          if (((o = t.get("EXT_texture_compression_rgtc")), null === o))
            return null;
          if (r === K) return o.COMPRESSED_RED_RGTC1_EXT;
          if (36284 === r) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
          if (36285 === r) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
          if (36286 === r) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
        }
        return r === z
          ? n
            ? e.UNSIGNED_INT_24_8
            : ((o = t.get("WEBGL_depth_texture")),
              null !== o ? o.UNSIGNED_INT_24_8_WEBGL : null)
          : void 0 !== e[r]
          ? e[r]
          : null;
      },
    };
  }
  class ss extends bn {
    constructor(e = []) {
      super(), (this.isArrayCamera = !0), (this.cameras = e);
    }
  }
  class as extends hr {
    constructor() {
      super(), (this.isGroup = !0), (this.type = "Group");
    }
  }
  const ls = { type: "move" };
  class cs {
    constructor() {
      (this._targetRay = null), (this._grip = null), (this._hand = null);
    }
    getHandSpace() {
      return (
        null === this._hand &&
          ((this._hand = new as()),
          (this._hand.matrixAutoUpdate = !1),
          (this._hand.visible = !1),
          (this._hand.joints = {}),
          (this._hand.inputState = { pinching: !1 })),
        this._hand
      );
    }
    getTargetRaySpace() {
      return (
        null === this._targetRay &&
          ((this._targetRay = new as()),
          (this._targetRay.matrixAutoUpdate = !1),
          (this._targetRay.visible = !1),
          (this._targetRay.hasLinearVelocity = !1),
          (this._targetRay.linearVelocity = new ut()),
          (this._targetRay.hasAngularVelocity = !1),
          (this._targetRay.angularVelocity = new ut())),
        this._targetRay
      );
    }
    getGripSpace() {
      return (
        null === this._grip &&
          ((this._grip = new as()),
          (this._grip.matrixAutoUpdate = !1),
          (this._grip.visible = !1),
          (this._grip.hasLinearVelocity = !1),
          (this._grip.linearVelocity = new ut()),
          (this._grip.hasAngularVelocity = !1),
          (this._grip.angularVelocity = new ut())),
        this._grip
      );
    }
    dispatchEvent(e) {
      return (
        null !== this._targetRay && this._targetRay.dispatchEvent(e),
        null !== this._grip && this._grip.dispatchEvent(e),
        null !== this._hand && this._hand.dispatchEvent(e),
        this
      );
    }
    connect(e) {
      if (e && e.hand) {
        const t = this._hand;
        if (t) for (const r of e.hand.values()) this._getHandJoint(t, r);
      }
      return this.dispatchEvent({ type: "connected", data: e }), this;
    }
    disconnect(e) {
      return (
        this.dispatchEvent({ type: "disconnected", data: e }),
        null !== this._targetRay && (this._targetRay.visible = !1),
        null !== this._grip && (this._grip.visible = !1),
        null !== this._hand && (this._hand.visible = !1),
        this
      );
    }
    update(e, t, r) {
      let n = null,
        i = null,
        o = null;
      const s = this._targetRay,
        a = this._grip,
        l = this._hand;
      if (e && "visible-blurred" !== t.session.visibilityState) {
        if (l && e.hand) {
          o = !0;
          for (const n of e.hand.values()) {
            const e = t.getJointPose(n, r),
              i = this._getHandJoint(l, n);
            null !== e &&
              (i.matrix.fromArray(e.transform.matrix),
              i.matrix.decompose(i.position, i.rotation, i.scale),
              (i.matrixWorldNeedsUpdate = !0),
              (i.jointRadius = e.radius)),
              (i.visible = null !== e);
          }
          const n = l.joints["index-finger-tip"],
            i = l.joints["thumb-tip"],
            s = n.position.distanceTo(i.position),
            a = 0.02,
            c = 0.005;
          l.inputState.pinching && s > a + c
            ? ((l.inputState.pinching = !1),
              this.dispatchEvent({
                type: "pinchend",
                handedness: e.handedness,
                target: this,
              }))
            : !l.inputState.pinching &&
              s <= a - c &&
              ((l.inputState.pinching = !0),
              this.dispatchEvent({
                type: "pinchstart",
                handedness: e.handedness,
                target: this,
              }));
        } else
          null !== a &&
            e.gripSpace &&
            ((i = t.getPose(e.gripSpace, r)),
            null !== i &&
              (a.matrix.fromArray(i.transform.matrix),
              a.matrix.decompose(a.position, a.rotation, a.scale),
              (a.matrixWorldNeedsUpdate = !0),
              i.linearVelocity
                ? ((a.hasLinearVelocity = !0),
                  a.linearVelocity.copy(i.linearVelocity))
                : (a.hasLinearVelocity = !1),
              i.angularVelocity
                ? ((a.hasAngularVelocity = !0),
                  a.angularVelocity.copy(i.angularVelocity))
                : (a.hasAngularVelocity = !1)));
        null !== s &&
          ((n = t.getPose(e.targetRaySpace, r)),
          null === n && null !== i && (n = i),
          null !== n &&
            (s.matrix.fromArray(n.transform.matrix),
            s.matrix.decompose(s.position, s.rotation, s.scale),
            (s.matrixWorldNeedsUpdate = !0),
            n.linearVelocity
              ? ((s.hasLinearVelocity = !0),
                s.linearVelocity.copy(n.linearVelocity))
              : (s.hasLinearVelocity = !1),
            n.angularVelocity
              ? ((s.hasAngularVelocity = !0),
                s.angularVelocity.copy(n.angularVelocity))
              : (s.hasAngularVelocity = !1),
            this.dispatchEvent(ls)));
      }
      return (
        null !== s && (s.visible = null !== n),
        null !== a && (a.visible = null !== i),
        null !== l && (l.visible = null !== o),
        this
      );
    }
    _getHandJoint(e, t) {
      if (void 0 === e.joints[t.jointName]) {
        const r = new as();
        (r.matrixAutoUpdate = !1),
          (r.visible = !1),
          (e.joints[t.jointName] = r),
          e.add(r);
      }
      return e.joints[t.jointName];
    }
  }
  class us extends Se {
    constructor(e, t) {
      super();
      const r = this;
      let n = null,
        i = 1,
        o = null,
        s = "local-floor",
        a = 1,
        l = null,
        c = null,
        u = null,
        h = null,
        d = null,
        p = null;
      const f = t.getContextAttributes();
      let m = null,
        g = null;
      const _ = [],
        v = [],
        y = new De();
      let b = null;
      const x = new bn();
      x.layers.enable(1), (x.viewport = new it());
      const w = new bn();
      w.layers.enable(2), (w.viewport = new it());
      const S = [x, w],
        E = new ss();
      E.layers.enable(1), E.layers.enable(2);
      let M = null,
        T = null;
      function A(e) {
        const t = v.indexOf(e.inputSource);
        if (-1 === t) return;
        const r = _[t];
        void 0 !== r &&
          (r.update(e.inputSource, e.frame, l || o),
          r.dispatchEvent({ type: e.type, data: e.inputSource }));
      }
      function R() {
        n.removeEventListener("select", A),
          n.removeEventListener("selectstart", A),
          n.removeEventListener("selectend", A),
          n.removeEventListener("squeeze", A),
          n.removeEventListener("squeezestart", A),
          n.removeEventListener("squeezeend", A),
          n.removeEventListener("end", R),
          n.removeEventListener("inputsourceschange", P);
        for (let e = 0; e < _.length; e++) {
          const t = v[e];
          null !== t && ((v[e] = null), _[e].disconnect(t));
        }
        (M = null),
          (T = null),
          e.setRenderTarget(m),
          (d = null),
          (h = null),
          (u = null),
          (n = null),
          (g = null),
          N.stop(),
          (r.isPresenting = !1),
          e.setPixelRatio(b),
          e.setSize(y.width, y.height, !1),
          r.dispatchEvent({ type: "sessionend" });
      }
      function P(e) {
        for (let t = 0; t < e.removed.length; t++) {
          const r = e.removed[t],
            n = v.indexOf(r);
          n >= 0 && ((v[n] = null), _[n].disconnect(r));
        }
        for (let t = 0; t < e.added.length; t++) {
          const r = e.added[t];
          let n = v.indexOf(r);
          if (-1 === n) {
            for (let e = 0; e < _.length; e++) {
              if (e >= v.length) {
                v.push(r), (n = e);
                break;
              }
              if (null === v[e]) {
                (v[e] = r), (n = e);
                break;
              }
            }
            if (-1 === n) break;
          }
          const i = _[n];
          i && i.connect(r);
        }
      }
      (this.cameraAutoUpdate = !0),
        (this.enabled = !1),
        (this.isPresenting = !1),
        (this.getController = function (e) {
          let t = _[e];
          return (
            void 0 === t && ((t = new cs()), (_[e] = t)), t.getTargetRaySpace()
          );
        }),
        (this.getControllerGrip = function (e) {
          let t = _[e];
          return void 0 === t && ((t = new cs()), (_[e] = t)), t.getGripSpace();
        }),
        (this.getHand = function (e) {
          let t = _[e];
          return void 0 === t && ((t = new cs()), (_[e] = t)), t.getHandSpace();
        }),
        (this.setFramebufferScaleFactor = function (e) {
          (i = e),
            !0 === r.isPresenting &&
              console.warn(
                "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
              );
        }),
        (this.setReferenceSpaceType = function (e) {
          (s = e),
            !0 === r.isPresenting &&
              console.warn(
                "THREE.WebXRManager: Cannot change reference space type while presenting."
              );
        }),
        (this.getReferenceSpace = function () {
          return l || o;
        }),
        (this.setReferenceSpace = function (e) {
          l = e;
        }),
        (this.getBaseLayer = function () {
          return null !== h ? h : d;
        }),
        (this.getBinding = function () {
          return u;
        }),
        (this.getFrame = function () {
          return p;
        }),
        (this.getSession = function () {
          return n;
        }),
        (this.setSession = async function (c) {
          if (((n = c), null !== n)) {
            if (
              ((m = e.getRenderTarget()),
              n.addEventListener("select", A),
              n.addEventListener("selectstart", A),
              n.addEventListener("selectend", A),
              n.addEventListener("squeeze", A),
              n.addEventListener("squeezestart", A),
              n.addEventListener("squeezeend", A),
              n.addEventListener("end", R),
              n.addEventListener("inputsourceschange", P),
              !0 !== f.xrCompatible && (await t.makeXRCompatible()),
              (b = e.getPixelRatio()),
              e.getSize(y),
              void 0 === n.renderState.layers || !1 === e.capabilities.isWebGL2)
            ) {
              const r = {
                antialias: void 0 !== n.renderState.layers || f.antialias,
                alpha: !0,
                depth: f.depth,
                stencil: f.stencil,
                framebufferScaleFactor: i,
              };
              (d = new XRWebGLLayer(n, t, r)),
                n.updateRenderState({ baseLayer: d }),
                e.setPixelRatio(1),
                e.setSize(d.framebufferWidth, d.framebufferHeight, !1),
                (g = new st(d.framebufferWidth, d.framebufferHeight, {
                  format: V,
                  type: D,
                  colorSpace: e.outputColorSpace,
                  stencilBuffer: f.stencil,
                }));
            } else {
              let r = null,
                o = null,
                s = null;
              f.depth &&
                ((s = f.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
                (r = f.stencil ? W : j),
                (o = f.stencil ? z : B));
              const a = {
                colorFormat: t.RGBA8,
                depthFormat: s,
                scaleFactor: i,
              };
              (u = new XRWebGLBinding(n, t)),
                (h = u.createProjectionLayer(a)),
                n.updateRenderState({ layers: [h] }),
                e.setPixelRatio(1),
                e.setSize(h.textureWidth, h.textureHeight, !1),
                (g = new st(h.textureWidth, h.textureHeight, {
                  format: V,
                  type: D,
                  depthTexture: new mi(
                    h.textureWidth,
                    h.textureHeight,
                    o,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    r
                  ),
                  stencilBuffer: f.stencil,
                  colorSpace: e.outputColorSpace,
                  samples: f.antialias ? 4 : 0,
                })),
                (e.properties.get(g).__ignoreDepthValues = h.ignoreDepthValues);
            }
            (g.isXRRenderTarget = !0),
              this.setFoveation(a),
              (l = null),
              (o = await n.requestReferenceSpace(s)),
              N.setContext(n),
              N.start(),
              (r.isPresenting = !0),
              r.dispatchEvent({ type: "sessionstart" });
          }
        }),
        (this.getEnvironmentBlendMode = function () {
          if (null !== n) return n.environmentBlendMode;
        });
      const C = new ut(),
        I = new ut();
      function L(e, t) {
        null === t
          ? e.matrixWorld.copy(e.matrix)
          : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
          e.matrixWorldInverse.copy(e.matrixWorld).invert();
      }
      (this.updateCamera = function (e) {
        if (null === n) return;
        (E.near = w.near = x.near = e.near),
          (E.far = w.far = x.far = e.far),
          (M === E.near && T === E.far) ||
            (n.updateRenderState({ depthNear: E.near, depthFar: E.far }),
            (M = E.near),
            (T = E.far));
        const t = e.parent,
          r = E.cameras;
        L(E, t);
        for (let e = 0; e < r.length; e++) L(r[e], t);
        2 === r.length
          ? (function (e, t, r) {
              C.setFromMatrixPosition(t.matrixWorld),
                I.setFromMatrixPosition(r.matrixWorld);
              const n = C.distanceTo(I),
                i = t.projectionMatrix.elements,
                o = r.projectionMatrix.elements,
                s = i[14] / (i[10] - 1),
                a = i[14] / (i[10] + 1),
                l = (i[9] + 1) / i[5],
                c = (i[9] - 1) / i[5],
                u = (i[8] - 1) / i[0],
                h = (o[8] + 1) / o[0],
                d = s * u,
                p = s * h,
                f = n / (-u + h),
                m = f * -u;
              t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                e.translateX(m),
                e.translateZ(f),
                e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                e.matrixWorldInverse.copy(e.matrixWorld).invert();
              const g = s + f,
                _ = a + f,
                v = d - m,
                y = p + (n - m),
                b = ((l * a) / _) * g,
                x = ((c * a) / _) * g;
              e.projectionMatrix.makePerspective(v, y, b, x, g, _),
                e.projectionMatrixInverse.copy(e.projectionMatrix).invert();
            })(E, x, w)
          : E.projectionMatrix.copy(x.projectionMatrix),
          (function (e, t, r) {
            null === r
              ? e.matrix.copy(t.matrixWorld)
              : (e.matrix.copy(r.matrixWorld),
                e.matrix.invert(),
                e.matrix.multiply(t.matrixWorld)),
              e.matrix.decompose(e.position, e.quaternion, e.scale),
              e.updateMatrixWorld(!0),
              e.projectionMatrix.copy(t.projectionMatrix),
              e.projectionMatrixInverse.copy(t.projectionMatrixInverse),
              e.isPerspectiveCamera &&
                ((e.fov =
                  2 * Te * Math.atan(1 / e.projectionMatrix.elements[5])),
                (e.zoom = 1));
          })(e, E, t);
      }),
        (this.getCamera = function () {
          return E;
        }),
        (this.getFoveation = function () {
          if (null !== h || null !== d) return a;
        }),
        (this.setFoveation = function (e) {
          (a = e),
            null !== h && (h.fixedFoveation = e),
            null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = e);
        });
      let O = null;
      const N = new Ln();
      N.setAnimationLoop(function (t, n) {
        if (((c = n.getViewerPose(l || o)), (p = n), null !== c)) {
          const t = c.views;
          null !== d &&
            (e.setRenderTargetFramebuffer(g, d.framebuffer),
            e.setRenderTarget(g));
          let r = !1;
          t.length !== E.cameras.length && ((E.cameras.length = 0), (r = !0));
          for (let n = 0; n < t.length; n++) {
            const i = t[n];
            let o = null;
            if (null !== d) o = d.getViewport(i);
            else {
              const t = u.getViewSubImage(h, i);
              (o = t.viewport),
                0 === n &&
                  (e.setRenderTargetTextures(
                    g,
                    t.colorTexture,
                    h.ignoreDepthValues ? void 0 : t.depthStencilTexture
                  ),
                  e.setRenderTarget(g));
            }
            let s = S[n];
            void 0 === s &&
              ((s = new bn()),
              s.layers.enable(n),
              (s.viewport = new it()),
              (S[n] = s)),
              s.matrix.fromArray(i.transform.matrix),
              s.matrix.decompose(s.position, s.quaternion, s.scale),
              s.projectionMatrix.fromArray(i.projectionMatrix),
              s.projectionMatrixInverse.copy(s.projectionMatrix).invert(),
              s.viewport.set(o.x, o.y, o.width, o.height),
              0 === n &&
                (E.matrix.copy(s.matrix),
                E.matrix.decompose(E.position, E.quaternion, E.scale)),
              !0 === r && E.cameras.push(s);
          }
        }
        for (let e = 0; e < _.length; e++) {
          const t = v[e],
            r = _[e];
          null !== t && void 0 !== r && r.update(t, n, l || o);
        }
        O && O(t, n),
          n.detectedPlanes &&
            r.dispatchEvent({ type: "planesdetected", data: n }),
          (p = null);
      }),
        (this.setAnimationLoop = function (e) {
          O = e;
        }),
        (this.dispose = function () {});
    }
  }
  function hs(e, t) {
    function r(e, t) {
      !0 === e.matrixAutoUpdate && e.updateMatrix(), t.value.copy(e.matrix);
    }
    function n(n, i) {
      (n.opacity.value = i.opacity),
        i.color && n.diffuse.value.copy(i.color),
        i.emissive &&
          n.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity),
        i.map && ((n.map.value = i.map), r(i.map, n.mapTransform)),
        i.alphaMap &&
          ((n.alphaMap.value = i.alphaMap), r(i.alphaMap, n.alphaMapTransform)),
        i.bumpMap &&
          ((n.bumpMap.value = i.bumpMap),
          r(i.bumpMap, n.bumpMapTransform),
          (n.bumpScale.value = i.bumpScale),
          1 === i.side && (n.bumpScale.value *= -1)),
        i.normalMap &&
          ((n.normalMap.value = i.normalMap),
          r(i.normalMap, n.normalMapTransform),
          n.normalScale.value.copy(i.normalScale),
          1 === i.side && n.normalScale.value.negate()),
        i.displacementMap &&
          ((n.displacementMap.value = i.displacementMap),
          r(i.displacementMap, n.displacementMapTransform),
          (n.displacementScale.value = i.displacementScale),
          (n.displacementBias.value = i.displacementBias)),
        i.emissiveMap &&
          ((n.emissiveMap.value = i.emissiveMap),
          r(i.emissiveMap, n.emissiveMapTransform)),
        i.specularMap &&
          ((n.specularMap.value = i.specularMap),
          r(i.specularMap, n.specularMapTransform)),
        i.alphaTest > 0 && (n.alphaTest.value = i.alphaTest);
      const o = t.get(i).envMap;
      if (
        (o &&
          ((n.envMap.value = o),
          (n.flipEnvMap.value =
            o.isCubeTexture && !1 === o.isRenderTargetTexture ? -1 : 1),
          (n.reflectivity.value = i.reflectivity),
          (n.ior.value = i.ior),
          (n.refractionRatio.value = i.refractionRatio)),
        i.lightMap)
      ) {
        n.lightMap.value = i.lightMap;
        const t = !0 === e._useLegacyLights ? Math.PI : 1;
        (n.lightMapIntensity.value = i.lightMapIntensity * t),
          r(i.lightMap, n.lightMapTransform);
      }
      i.aoMap &&
        ((n.aoMap.value = i.aoMap),
        (n.aoMapIntensity.value = i.aoMapIntensity),
        r(i.aoMap, n.aoMapTransform));
    }
    return {
      refreshFogUniforms: function (t, r) {
        r.color.getRGB(t.fogColor.value, gn(e)),
          r.isFog
            ? ((t.fogNear.value = r.near), (t.fogFar.value = r.far))
            : r.isFogExp2 && (t.fogDensity.value = r.density);
      },
      refreshMaterialUniforms: function (e, i, o, s, a) {
        i.isMeshBasicMaterial || i.isMeshLambertMaterial
          ? n(e, i)
          : i.isMeshToonMaterial
          ? (n(e, i),
            (function (e, t) {
              t.gradientMap && (e.gradientMap.value = t.gradientMap);
            })(e, i))
          : i.isMeshPhongMaterial
          ? (n(e, i),
            (function (e, t) {
              e.specular.value.copy(t.specular),
                (e.shininess.value = Math.max(t.shininess, 1e-4));
            })(e, i))
          : i.isMeshStandardMaterial
          ? (n(e, i),
            (function (e, n) {
              (e.metalness.value = n.metalness),
                n.metalnessMap &&
                  ((e.metalnessMap.value = n.metalnessMap),
                  r(n.metalnessMap, e.metalnessMapTransform)),
                (e.roughness.value = n.roughness),
                n.roughnessMap &&
                  ((e.roughnessMap.value = n.roughnessMap),
                  r(n.roughnessMap, e.roughnessMapTransform));
              t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity);
            })(e, i),
            i.isMeshPhysicalMaterial &&
              (function (e, t, n) {
                (e.ior.value = t.ior),
                  t.sheen > 0 &&
                    (e.sheenColor.value
                      .copy(t.sheenColor)
                      .multiplyScalar(t.sheen),
                    (e.sheenRoughness.value = t.sheenRoughness),
                    t.sheenColorMap &&
                      ((e.sheenColorMap.value = t.sheenColorMap),
                      r(t.sheenColorMap, e.sheenColorMapTransform)),
                    t.sheenRoughnessMap &&
                      ((e.sheenRoughnessMap.value = t.sheenRoughnessMap),
                      r(t.sheenRoughnessMap, e.sheenRoughnessMapTransform))),
                  t.clearcoat > 0 &&
                    ((e.clearcoat.value = t.clearcoat),
                    (e.clearcoatRoughness.value = t.clearcoatRoughness),
                    t.clearcoatMap &&
                      ((e.clearcoatMap.value = t.clearcoatMap),
                      r(t.clearcoatMap, e.clearcoatMapTransform)),
                    t.clearcoatRoughnessMap &&
                      ((e.clearcoatRoughnessMap.value =
                        t.clearcoatRoughnessMap),
                      r(
                        t.clearcoatRoughnessMap,
                        e.clearcoatRoughnessMapTransform
                      )),
                    t.clearcoatNormalMap &&
                      ((e.clearcoatNormalMap.value = t.clearcoatNormalMap),
                      r(t.clearcoatNormalMap, e.clearcoatNormalMapTransform),
                      e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),
                      1 === t.side && e.clearcoatNormalScale.value.negate())),
                  t.iridescence > 0 &&
                    ((e.iridescence.value = t.iridescence),
                    (e.iridescenceIOR.value = t.iridescenceIOR),
                    (e.iridescenceThicknessMinimum.value =
                      t.iridescenceThicknessRange[0]),
                    (e.iridescenceThicknessMaximum.value =
                      t.iridescenceThicknessRange[1]),
                    t.iridescenceMap &&
                      ((e.iridescenceMap.value = t.iridescenceMap),
                      r(t.iridescenceMap, e.iridescenceMapTransform)),
                    t.iridescenceThicknessMap &&
                      ((e.iridescenceThicknessMap.value =
                        t.iridescenceThicknessMap),
                      r(
                        t.iridescenceThicknessMap,
                        e.iridescenceThicknessMapTransform
                      ))),
                  t.transmission > 0 &&
                    ((e.transmission.value = t.transmission),
                    (e.transmissionSamplerMap.value = n.texture),
                    e.transmissionSamplerSize.value.set(n.width, n.height),
                    t.transmissionMap &&
                      ((e.transmissionMap.value = t.transmissionMap),
                      r(t.transmissionMap, e.transmissionMapTransform)),
                    (e.thickness.value = t.thickness),
                    t.thicknessMap &&
                      ((e.thicknessMap.value = t.thicknessMap),
                      r(t.thicknessMap, e.thicknessMapTransform)),
                    (e.attenuationDistance.value = t.attenuationDistance),
                    e.attenuationColor.value.copy(t.attenuationColor)),
                  t.anisotropy > 0 &&
                    (e.anisotropyVector.value.set(
                      t.anisotropy * Math.cos(t.anisotropyRotation),
                      t.anisotropy * Math.sin(t.anisotropyRotation)
                    ),
                    t.anisotropyMap &&
                      ((e.anisotropyMap.value = t.anisotropyMap),
                      r(t.anisotropyMap, e.anisotropyMapTransform))),
                  (e.specularIntensity.value = t.specularIntensity),
                  e.specularColor.value.copy(t.specularColor),
                  t.specularColorMap &&
                    ((e.specularColorMap.value = t.specularColorMap),
                    r(t.specularColorMap, e.specularColorMapTransform)),
                  t.specularIntensityMap &&
                    ((e.specularIntensityMap.value = t.specularIntensityMap),
                    r(t.specularIntensityMap, e.specularIntensityMapTransform));
              })(e, i, a))
          : i.isMeshMatcapMaterial
          ? (n(e, i),
            (function (e, t) {
              t.matcap && (e.matcap.value = t.matcap);
            })(e, i))
          : i.isMeshDepthMaterial
          ? n(e, i)
          : i.isMeshDistanceMaterial
          ? (n(e, i),
            (function (e, r) {
              const n = t.get(r).light;
              e.referencePosition.value.setFromMatrixPosition(n.matrixWorld),
                (e.nearDistance.value = n.shadow.camera.near),
                (e.farDistance.value = n.shadow.camera.far);
            })(e, i))
          : i.isMeshNormalMaterial
          ? n(e, i)
          : i.isLineBasicMaterial
          ? ((function (e, t) {
              e.diffuse.value.copy(t.color),
                (e.opacity.value = t.opacity),
                t.map && ((e.map.value = t.map), r(t.map, e.mapTransform));
            })(e, i),
            i.isLineDashedMaterial &&
              (function (e, t) {
                (e.dashSize.value = t.dashSize),
                  (e.totalSize.value = t.dashSize + t.gapSize),
                  (e.scale.value = t.scale);
              })(e, i))
          : i.isPointsMaterial
          ? (function (e, t, n, i) {
              e.diffuse.value.copy(t.color),
                (e.opacity.value = t.opacity),
                (e.size.value = t.size * n),
                (e.scale.value = 0.5 * i),
                t.map && ((e.map.value = t.map), r(t.map, e.uvTransform)),
                t.alphaMap &&
                  ((e.alphaMap.value = t.alphaMap),
                  r(t.alphaMap, e.alphaMapTransform)),
                t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
            })(e, i, o, s)
          : i.isSpriteMaterial
          ? (function (e, t) {
              e.diffuse.value.copy(t.color),
                (e.opacity.value = t.opacity),
                (e.rotation.value = t.rotation),
                t.map && ((e.map.value = t.map), r(t.map, e.mapTransform)),
                t.alphaMap &&
                  ((e.alphaMap.value = t.alphaMap),
                  r(t.alphaMap, e.alphaMapTransform)),
                t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
            })(e, i)
          : i.isShadowMaterial
          ? (e.color.value.copy(i.color), (e.opacity.value = i.opacity))
          : i.isShaderMaterial && (i.uniformsNeedUpdate = !1);
      },
    };
  }
  function ds(e, t, r, n) {
    let i = {},
      o = {},
      s = [];
    const a = r.isWebGL2 ? e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
    function l(e, t, r, n) {
      const i = e.value,
        o = t + "_" + r;
      if (void 0 === n[o])
        return (
          (n[o] =
            "number" == typeof i || "boolean" == typeof i ? i : i.clone()),
          !0
        );
      {
        const e = n[o];
        if ("number" == typeof i || "boolean" == typeof i) {
          if (e !== i) return (n[o] = i), !0;
        } else if (!1 === e.equals(i)) return e.copy(i), !0;
      }
      return !1;
    }
    function c(e) {
      const t = { boundary: 0, storage: 0 };
      return (
        "number" == typeof e || "boolean" == typeof e
          ? ((t.boundary = 4), (t.storage = 4))
          : e.isVector2
          ? ((t.boundary = 8), (t.storage = 8))
          : e.isVector3 || e.isColor
          ? ((t.boundary = 16), (t.storage = 12))
          : e.isVector4
          ? ((t.boundary = 16), (t.storage = 16))
          : e.isMatrix3
          ? ((t.boundary = 48), (t.storage = 48))
          : e.isMatrix4
          ? ((t.boundary = 64), (t.storage = 64))
          : e.isTexture
          ? console.warn(
              "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
            )
          : console.warn(
              "THREE.WebGLRenderer: Unsupported uniform value type.",
              e
            ),
        t
      );
    }
    function u(t) {
      const r = t.target;
      r.removeEventListener("dispose", u);
      const n = s.indexOf(r.__bindingPointIndex);
      s.splice(n, 1), e.deleteBuffer(i[r.id]), delete i[r.id], delete o[r.id];
    }
    return {
      bind: function (e, t) {
        const r = t.program;
        n.uniformBlockBinding(e, r);
      },
      update: function (r, h) {
        let d = i[r.id];
        void 0 === d &&
          ((function (e) {
            const t = e.uniforms;
            let r = 0;
            for (let e = 0, n = t.length; e < n; e++) {
              const n = Array.isArray(t[e]) ? t[e] : [t[e]];
              for (let e = 0, t = n.length; e < t; e++) {
                const t = n[e],
                  i = Array.isArray(t.value) ? t.value : [t.value];
                for (let e = 0, n = i.length; e < n; e++) {
                  const n = c(i[e]),
                    o = r % 16;
                  0 !== o && 16 - o < n.boundary && (r += 16 - o),
                    (t.__data = new Float32Array(
                      n.storage / Float32Array.BYTES_PER_ELEMENT
                    )),
                    (t.__offset = r),
                    (r += n.storage);
                }
              }
            }
            const n = r % 16;
            n > 0 && (r += 16 - n), (e.__size = r), (e.__cache = {});
          })(r),
          (d = (function (t) {
            const r = (function () {
              for (let e = 0; e < a; e++)
                if (-1 === s.indexOf(e)) return s.push(e), e;
              return (
                console.error(
                  "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
                ),
                0
              );
            })();
            t.__bindingPointIndex = r;
            const n = e.createBuffer(),
              i = t.__size,
              o = t.usage;
            return (
              e.bindBuffer(e.UNIFORM_BUFFER, n),
              e.bufferData(e.UNIFORM_BUFFER, i, o),
              e.bindBuffer(e.UNIFORM_BUFFER, null),
              e.bindBufferBase(e.UNIFORM_BUFFER, r, n),
              n
            );
          })(r)),
          (i[r.id] = d),
          r.addEventListener("dispose", u));
        const p = h.program;
        n.updateUBOMapping(r, p);
        const f = t.render.frame;
        o[r.id] !== f &&
          ((function (t) {
            const r = i[t.id],
              n = t.uniforms,
              o = t.__cache;
            e.bindBuffer(e.UNIFORM_BUFFER, r);
            for (let t = 0, r = n.length; t < r; t++) {
              const r = Array.isArray(n[t]) ? n[t] : [n[t]];
              for (let n = 0, i = r.length; n < i; n++) {
                const i = r[n];
                if (!0 === l(i, t, n, o)) {
                  const t = i.__offset,
                    r = Array.isArray(i.value) ? i.value : [i.value];
                  let n = 0;
                  for (let o = 0; o < r.length; o++) {
                    const s = r[o],
                      a = c(s);
                    "number" == typeof s || "boolean" == typeof s
                      ? ((i.__data[0] = s),
                        e.bufferSubData(e.UNIFORM_BUFFER, t + n, i.__data))
                      : s.isMatrix3
                      ? ((i.__data[0] = s.elements[0]),
                        (i.__data[1] = s.elements[1]),
                        (i.__data[2] = s.elements[2]),
                        (i.__data[3] = 0),
                        (i.__data[4] = s.elements[3]),
                        (i.__data[5] = s.elements[4]),
                        (i.__data[6] = s.elements[5]),
                        (i.__data[7] = 0),
                        (i.__data[8] = s.elements[6]),
                        (i.__data[9] = s.elements[7]),
                        (i.__data[10] = s.elements[8]),
                        (i.__data[11] = 0))
                      : (s.toArray(i.__data, n),
                        (n += a.storage / Float32Array.BYTES_PER_ELEMENT));
                  }
                  e.bufferSubData(e.UNIFORM_BUFFER, t, i.__data);
                }
              }
            }
            e.bindBuffer(e.UNIFORM_BUFFER, null);
          })(r),
          (o[r.id] = f));
      },
      dispose: function () {
        for (const t in i) e.deleteBuffer(i[t]);
        (s = []), (i = {}), (o = {});
      },
    };
  }
  class ps {
    constructor(e = {}) {
      const {
        canvas: r = ze(),
        context: n = null,
        depth: i = !0,
        stencil: o = !0,
        alpha: s = !1,
        antialias: a = !1,
        premultipliedAlpha: l = !0,
        preserveDrawingBuffer: c = !1,
        powerPreference: u = "default",
        failIfMajorPerformanceCaveat: h = !1,
      } = e;
      let d;
      (this.isWebGLRenderer = !0),
        (d = null !== n ? n.getContextAttributes().alpha : s);
      const p = new Uint32Array(4),
        f = new Int32Array(4);
      let m = null,
        g = null;
      const _ = [],
        v = [];
      (this.domElement = r),
        (this.debug = { checkShaderErrors: !0, onShaderError: null }),
        (this.autoClear = !0),
        (this.autoClearColor = !0),
        (this.autoClearDepth = !0),
        (this.autoClearStencil = !0),
        (this.sortObjects = !0),
        (this.clippingPlanes = []),
        (this.localClippingEnabled = !1),
        (this._outputColorSpace = te),
        (this._useLegacyLights = !1),
        (this.toneMapping = 0),
        (this.toneMappingExposure = 1);
      const y = this;
      let b = !1,
        x = 0,
        w = 0,
        S = null,
        E = -1,
        M = null;
      const T = new it(),
        A = new it();
      let R = null;
      const P = new Rr(0);
      let C = 0,
        I = r.width,
        L = r.height,
        O = 1,
        N = null,
        j = null;
      const W = new it(0, 0, I, L),
        G = new it(0, 0, I, L);
      let X = !1;
      const q = new In();
      let Y = !1,
        K = !1,
        $ = null;
      const Q = new Ht(),
        J = new De(),
        Z = new ut(),
        ee = {
          background: null,
          fog: null,
          environment: null,
          overrideMaterial: null,
          isScene: !0,
        };
      function ne() {
        return null === S ? O : 1;
      }
      let ie,
        oe,
        se,
        ae,
        le,
        ce,
        ue,
        he,
        de,
        pe,
        fe,
        me,
        ge,
        _e,
        ve,
        ye,
        be,
        xe,
        we,
        Se,
        Ee,
        Me,
        Te,
        Ae,
        Re = n;
      function Pe(e, t) {
        for (let n = 0; n < e.length; n++) {
          const i = e[n],
            o = r.getContext(i, t);
          if (null !== o) return o;
        }
        return null;
      }
      try {
        const e = {
          alpha: !0,
          depth: i,
          stencil: o,
          antialias: a,
          premultipliedAlpha: l,
          preserveDrawingBuffer: c,
          powerPreference: u,
          failIfMajorPerformanceCaveat: h,
        };
        if (
          ("setAttribute" in r &&
            r.setAttribute("data-engine", `three.js r${t}`),
          r.addEventListener("webglcontextlost", Oe, !1),
          r.addEventListener("webglcontextrestored", Ne, !1),
          r.addEventListener("webglcontextcreationerror", Ue, !1),
          null === Re)
        ) {
          const t = ["webgl2", "webgl", "experimental-webgl"];
          if (
            (!0 === y.isWebGL1Renderer && t.shift(),
            (Re = Pe(t, e)),
            null === Re)
          )
            throw Pe(t)
              ? new Error(
                  "Error creating WebGL context with your selected attributes."
                )
              : new Error("Error creating WebGL context.");
        }
        "undefined" != typeof WebGLRenderingContext &&
          Re instanceof WebGLRenderingContext &&
          console.warn(
            "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
          ),
          void 0 === Re.getShaderPrecisionFormat &&
            (Re.getShaderPrecisionFormat = function () {
              return { rangeMin: 1, rangeMax: 1, precision: 1 };
            });
      } catch (e) {
        throw (console.error("THREE.WebGLRenderer: " + e.message), e);
      }
      function Ce() {
        (ie = new ai(Re)),
          (oe = new Vn(Re, ie, e)),
          ie.init(oe),
          (Me = new os(Re, ie, oe)),
          (se = new ns(Re, ie, oe)),
          (ae = new ui(Re)),
          (le = new jo()),
          (ce = new is(Re, ie, se, le, oe, Me, ae)),
          (ue = new Wn(y)),
          (he = new si(y)),
          (de = new On(Re, oe)),
          (Te = new Hn(Re, ie, de, oe)),
          (pe = new li(Re, de, ae, Te)),
          (fe = new fi(Re, pe, de, ae)),
          (we = new pi(Re, oe, ce)),
          (ye = new jn(le)),
          (me = new Vo(y, ue, he, ie, oe, Te, ye)),
          (ge = new hs(y, le)),
          (_e = new qo()),
          (ve = new Zo(ie, oe)),
          (xe = new Fn(y, ue, he, se, fe, d, l)),
          (be = new rs(y, fe, oe)),
          (Ae = new ds(Re, ae, oe, se)),
          (Se = new zn(Re, ie, ae, oe)),
          (Ee = new ci(Re, ie, ae, oe)),
          (ae.programs = me.programs),
          (y.capabilities = oe),
          (y.extensions = ie),
          (y.properties = le),
          (y.renderLists = _e),
          (y.shadowMap = be),
          (y.state = se),
          (y.info = ae);
      }
      Ce();
      const Ie = new us(y, Re);
      function Oe(e) {
        e.preventDefault(),
          console.log("THREE.WebGLRenderer: Context Lost."),
          (b = !0);
      }
      function Ne() {
        console.log("THREE.WebGLRenderer: Context Restored."), (b = !1);
        const e = ae.autoReset,
          t = be.enabled,
          r = be.autoUpdate,
          n = be.needsUpdate,
          i = be.type;
        Ce(),
          (ae.autoReset = e),
          (be.enabled = t),
          (be.autoUpdate = r),
          (be.needsUpdate = n),
          (be.type = i);
      }
      function Ue(e) {
        console.error(
          "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
          e.statusMessage
        );
      }
      function ke(e) {
        const t = e.target;
        t.removeEventListener("dispose", ke),
          (function (e) {
            (function (e) {
              const t = le.get(e).programs;
              void 0 !== t &&
                (t.forEach(function (e) {
                  me.releaseProgram(e);
                }),
                e.isShaderMaterial && me.releaseShaderCache(e));
            })(e),
              le.remove(e);
          })(t);
      }
      function Be(e, t, r) {
        !0 === e.transparent && 2 === e.side && !1 === e.forceSinglePass
          ? ((e.side = 1),
            (e.needsUpdate = !0),
            Ye(e, t, r),
            (e.side = 0),
            (e.needsUpdate = !0),
            Ye(e, t, r),
            (e.side = 2))
          : Ye(e, t, r);
      }
      (this.xr = Ie),
        (this.getContext = function () {
          return Re;
        }),
        (this.getContextAttributes = function () {
          return Re.getContextAttributes();
        }),
        (this.forceContextLoss = function () {
          const e = ie.get("WEBGL_lose_context");
          e && e.loseContext();
        }),
        (this.forceContextRestore = function () {
          const e = ie.get("WEBGL_lose_context");
          e && e.restoreContext();
        }),
        (this.getPixelRatio = function () {
          return O;
        }),
        (this.setPixelRatio = function (e) {
          void 0 !== e && ((O = e), this.setSize(I, L, !1));
        }),
        (this.getSize = function (e) {
          return e.set(I, L);
        }),
        (this.setSize = function (e, t, n = !0) {
          Ie.isPresenting
            ? console.warn(
                "THREE.WebGLRenderer: Can't change size while VR device is presenting."
              )
            : ((I = e),
              (L = t),
              (r.width = Math.floor(e * O)),
              (r.height = Math.floor(t * O)),
              !0 === n &&
                ((r.style.width = e + "px"), (r.style.height = t + "px")),
              this.setViewport(0, 0, e, t));
        }),
        (this.getDrawingBufferSize = function (e) {
          return e.set(I * O, L * O).floor();
        }),
        (this.setDrawingBufferSize = function (e, t, n) {
          (I = e),
            (L = t),
            (O = n),
            (r.width = Math.floor(e * n)),
            (r.height = Math.floor(t * n)),
            this.setViewport(0, 0, e, t);
        }),
        (this.getCurrentViewport = function (e) {
          return e.copy(T);
        }),
        (this.getViewport = function (e) {
          return e.copy(W);
        }),
        (this.setViewport = function (e, t, r, n) {
          e.isVector4 ? W.set(e.x, e.y, e.z, e.w) : W.set(e, t, r, n),
            se.viewport(T.copy(W).multiplyScalar(O).floor());
        }),
        (this.getScissor = function (e) {
          return e.copy(G);
        }),
        (this.setScissor = function (e, t, r, n) {
          e.isVector4 ? G.set(e.x, e.y, e.z, e.w) : G.set(e, t, r, n),
            se.scissor(A.copy(G).multiplyScalar(O).floor());
        }),
        (this.getScissorTest = function () {
          return X;
        }),
        (this.setScissorTest = function (e) {
          se.setScissorTest((X = e));
        }),
        (this.setOpaqueSort = function (e) {
          N = e;
        }),
        (this.setTransparentSort = function (e) {
          j = e;
        }),
        (this.getClearColor = function (e) {
          return e.copy(xe.getClearColor());
        }),
        (this.setClearColor = function () {
          xe.setClearColor.apply(xe, arguments);
        }),
        (this.getClearAlpha = function () {
          return xe.getClearAlpha();
        }),
        (this.setClearAlpha = function () {
          xe.setClearAlpha.apply(xe, arguments);
        }),
        (this.clear = function (e = !0, t = !0, r = !0) {
          let n = 0;
          if (e) {
            let e = !1;
            if (null !== S) {
              const t = S.texture.format;
              e = 1033 === t || 1031 === t || 1029 === t;
            }
            if (e) {
              const e = S.texture.type,
                t =
                  e === D ||
                  e === B ||
                  e === k ||
                  e === z ||
                  1017 === e ||
                  1018 === e,
                r = xe.getClearColor(),
                n = xe.getClearAlpha(),
                i = r.r,
                o = r.g,
                s = r.b;
              t
                ? ((p[0] = i),
                  (p[1] = o),
                  (p[2] = s),
                  (p[3] = n),
                  Re.clearBufferuiv(Re.COLOR, 0, p))
                : ((f[0] = i),
                  (f[1] = o),
                  (f[2] = s),
                  (f[3] = n),
                  Re.clearBufferiv(Re.COLOR, 0, f));
            } else n |= Re.COLOR_BUFFER_BIT;
          }
          t && (n |= Re.DEPTH_BUFFER_BIT),
            r &&
              ((n |= Re.STENCIL_BUFFER_BIT),
              this.state.buffers.stencil.setMask(4294967295)),
            Re.clear(n);
        }),
        (this.clearColor = function () {
          this.clear(!0, !1, !1);
        }),
        (this.clearDepth = function () {
          this.clear(!1, !0, !1);
        }),
        (this.clearStencil = function () {
          this.clear(!1, !1, !0);
        }),
        (this.dispose = function () {
          r.removeEventListener("webglcontextlost", Oe, !1),
            r.removeEventListener("webglcontextrestored", Ne, !1),
            r.removeEventListener("webglcontextcreationerror", Ue, !1),
            _e.dispose(),
            ve.dispose(),
            le.dispose(),
            ue.dispose(),
            he.dispose(),
            fe.dispose(),
            Te.dispose(),
            Ae.dispose(),
            me.dispose(),
            Ie.dispose(),
            Ie.removeEventListener("sessionstart", He),
            Ie.removeEventListener("sessionend", Ve),
            $ && ($.dispose(), ($ = null)),
            je.stop();
        }),
        (this.renderBufferDirect = function (e, t, r, n, i, o) {
          null === t && (t = ee);
          const s = i.isMesh && i.matrixWorld.determinant() < 0,
            a = (function (e, t, r, n, i) {
              !0 !== t.isScene && (t = ee), ce.resetTextureUnits();
              const o = t.fog,
                s = n.isMeshStandardMaterial ? t.environment : null,
                a =
                  null === S
                    ? y.outputColorSpace
                    : !0 === S.isXRRenderTarget
                    ? S.texture.colorSpace
                    : re,
                l = (n.isMeshStandardMaterial ? he : ue).get(n.envMap || s),
                c =
                  !0 === n.vertexColors &&
                  !!r.attributes.color &&
                  4 === r.attributes.color.itemSize,
                u =
                  !!r.attributes.tangent && (!!n.normalMap || n.anisotropy > 0),
                h = !!r.morphAttributes.position,
                d = !!r.morphAttributes.normal,
                p = !!r.morphAttributes.color;
              let f = 0;
              n.toneMapped &&
                ((null !== S && !0 !== S.isXRRenderTarget) ||
                  (f = y.toneMapping));
              const m =
                  r.morphAttributes.position ||
                  r.morphAttributes.normal ||
                  r.morphAttributes.color,
                _ = void 0 !== m ? m.length : 0,
                v = le.get(n),
                b = g.state.lights;
              if (!0 === Y && (!0 === K || e !== M)) {
                const t = e === M && n.id === E;
                ye.setState(n, e, t);
              }
              let x = !1;
              n.version === v.__version
                ? (v.needsLights && v.lightsStateVersion !== b.state.version) ||
                  v.outputColorSpace !== a ||
                  (i.isBatchedMesh && !1 === v.batching)
                  ? (x = !0)
                  : i.isBatchedMesh || !0 !== v.batching
                  ? i.isInstancedMesh && !1 === v.instancing
                    ? (x = !0)
                    : i.isInstancedMesh || !0 !== v.instancing
                    ? i.isSkinnedMesh && !1 === v.skinning
                      ? (x = !0)
                      : i.isSkinnedMesh || !0 !== v.skinning
                      ? (i.isInstancedMesh &&
                          !0 === v.instancingColor &&
                          null === i.instanceColor) ||
                        (i.isInstancedMesh &&
                          !1 === v.instancingColor &&
                          null !== i.instanceColor) ||
                        v.envMap !== l ||
                        (!0 === n.fog && v.fog !== o)
                        ? (x = !0)
                        : void 0 === v.numClippingPlanes ||
                          (v.numClippingPlanes === ye.numPlanes &&
                            v.numIntersection === ye.numIntersection)
                        ? (v.vertexAlphas !== c ||
                            v.vertexTangents !== u ||
                            v.morphTargets !== h ||
                            v.morphNormals !== d ||
                            v.morphColors !== p ||
                            v.toneMapping !== f ||
                            (!0 === oe.isWebGL2 &&
                              v.morphTargetsCount !== _)) &&
                          (x = !0)
                        : (x = !0)
                      : (x = !0)
                    : (x = !0)
                  : (x = !0)
                : ((x = !0), (v.__version = n.version));
              let w = v.currentProgram;
              !0 === x && (w = Ye(n, t, i));
              let T = !1,
                A = !1,
                R = !1;
              const P = w.getUniforms(),
                C = v.uniforms;
              if (
                (se.useProgram(w.program) && ((T = !0), (A = !0), (R = !0)),
                n.id !== E && ((E = n.id), (A = !0)),
                T || M !== e)
              ) {
                P.setValue(Re, "projectionMatrix", e.projectionMatrix),
                  P.setValue(Re, "viewMatrix", e.matrixWorldInverse);
                const t = P.map.cameraPosition;
                void 0 !== t &&
                  t.setValue(Re, Z.setFromMatrixPosition(e.matrixWorld)),
                  oe.logarithmicDepthBuffer &&
                    P.setValue(
                      Re,
                      "logDepthBufFC",
                      2 / (Math.log(e.far + 1) / Math.LN2)
                    ),
                  (n.isMeshPhongMaterial ||
                    n.isMeshToonMaterial ||
                    n.isMeshLambertMaterial ||
                    n.isMeshBasicMaterial ||
                    n.isMeshStandardMaterial ||
                    n.isShaderMaterial) &&
                    P.setValue(
                      Re,
                      "isOrthographic",
                      !0 === e.isOrthographicCamera
                    ),
                  M !== e && ((M = e), (A = !0), (R = !0));
              }
              if (i.isSkinnedMesh) {
                P.setOptional(Re, i, "bindMatrix"),
                  P.setOptional(Re, i, "bindMatrixInverse");
                const e = i.skeleton;
                e &&
                  (oe.floatVertexTextures
                    ? (null === e.boneTexture && e.computeBoneTexture(),
                      P.setValue(Re, "boneTexture", e.boneTexture, ce))
                    : console.warn(
                        "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
                      ));
              }
              i.isBatchedMesh &&
                (P.setOptional(Re, i, "batchingTexture"),
                P.setValue(Re, "batchingTexture", i._matricesTexture, ce));
              const I = r.morphAttributes;
              var N, U;
              if (
                ((void 0 !== I.position ||
                  void 0 !== I.normal ||
                  (void 0 !== I.color && !0 === oe.isWebGL2)) &&
                  we.update(i, r, w),
                (A || v.receiveShadow !== i.receiveShadow) &&
                  ((v.receiveShadow = i.receiveShadow),
                  P.setValue(Re, "receiveShadow", i.receiveShadow)),
                n.isMeshGouraudMaterial &&
                  null !== n.envMap &&
                  ((C.envMap.value = l),
                  (C.flipEnvMap.value =
                    l.isCubeTexture && !1 === l.isRenderTargetTexture
                      ? -1
                      : 1)),
                A &&
                  (P.setValue(Re, "toneMappingExposure", y.toneMappingExposure),
                  v.needsLights &&
                    ((U = R),
                    ((N = C).ambientLightColor.needsUpdate = U),
                    (N.lightProbe.needsUpdate = U),
                    (N.directionalLights.needsUpdate = U),
                    (N.directionalLightShadows.needsUpdate = U),
                    (N.pointLights.needsUpdate = U),
                    (N.pointLightShadows.needsUpdate = U),
                    (N.spotLights.needsUpdate = U),
                    (N.spotLightShadows.needsUpdate = U),
                    (N.rectAreaLights.needsUpdate = U),
                    (N.hemisphereLights.needsUpdate = U)),
                  o && !0 === n.fog && ge.refreshFogUniforms(C, o),
                  ge.refreshMaterialUniforms(C, n, O, L, $),
                  xo.upload(Re, Ke(v), C, ce)),
                n.isShaderMaterial &&
                  !0 === n.uniformsNeedUpdate &&
                  (xo.upload(Re, Ke(v), C, ce), (n.uniformsNeedUpdate = !1)),
                n.isSpriteMaterial && P.setValue(Re, "center", i.center),
                P.setValue(Re, "modelViewMatrix", i.modelViewMatrix),
                P.setValue(Re, "normalMatrix", i.normalMatrix),
                P.setValue(Re, "modelMatrix", i.matrixWorld),
                n.isShaderMaterial || n.isRawShaderMaterial)
              ) {
                const e = n.uniformsGroups;
                for (let t = 0, r = e.length; t < r; t++)
                  if (oe.isWebGL2) {
                    const r = e[t];
                    Ae.update(r, w), Ae.bind(r, w);
                  } else
                    console.warn(
                      "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
                    );
              }
              return w;
            })(e, t, r, n, i);
          se.setMaterial(n, s);
          let l = r.index,
            c = 1;
          if (!0 === n.wireframe) {
            if (((l = pe.getWireframeAttribute(r)), void 0 === l)) return;
            c = 2;
          }
          const u = r.drawRange,
            h = r.attributes.position;
          let d = u.start * c,
            p = (u.start + u.count) * c;
          null !== o &&
            ((d = Math.max(d, o.start * c)),
            (p = Math.min(p, (o.start + o.count) * c))),
            null !== l
              ? ((d = Math.max(d, 0)), (p = Math.min(p, l.count)))
              : null != h && ((d = Math.max(d, 0)), (p = Math.min(p, h.count)));
          const f = p - d;
          if (f < 0 || f === 1 / 0) return;
          let m;
          Te.setup(i, n, a, r, l);
          let _ = Se;
          if (
            (null !== l && ((m = de.get(l)), (_ = Ee), _.setIndex(m)), i.isMesh)
          )
            !0 === n.wireframe
              ? (se.setLineWidth(n.wireframeLinewidth * ne()),
                _.setMode(Re.LINES))
              : _.setMode(Re.TRIANGLES);
          else if (i.isLine) {
            let e = n.linewidth;
            void 0 === e && (e = 1),
              se.setLineWidth(e * ne()),
              i.isLineSegments
                ? _.setMode(Re.LINES)
                : i.isLineLoop
                ? _.setMode(Re.LINE_LOOP)
                : _.setMode(Re.LINE_STRIP);
          } else
            i.isPoints
              ? _.setMode(Re.POINTS)
              : i.isSprite && _.setMode(Re.TRIANGLES);
          if (i.isBatchedMesh)
            _.renderMultiDraw(
              i._multiDrawStarts,
              i._multiDrawCounts,
              i._multiDrawCount
            );
          else if (i.isInstancedMesh) _.renderInstances(d, f, i.count);
          else if (r.isInstancedBufferGeometry) {
            const e =
                void 0 !== r._maxInstanceCount ? r._maxInstanceCount : 1 / 0,
              t = Math.min(r.instanceCount, e);
            _.renderInstances(d, f, t);
          } else _.render(d, f);
        }),
        (this.compile = function (e, t, r = null) {
          null === r && (r = e),
            (g = ve.get(r)),
            g.init(),
            v.push(g),
            r.traverseVisible(function (e) {
              e.isLight &&
                e.layers.test(t.layers) &&
                (g.pushLight(e), e.castShadow && g.pushShadow(e));
            }),
            e !== r &&
              e.traverseVisible(function (e) {
                e.isLight &&
                  e.layers.test(t.layers) &&
                  (g.pushLight(e), e.castShadow && g.pushShadow(e));
              }),
            g.setupLights(y._useLegacyLights);
          const n = new Set();
          return (
            e.traverse(function (e) {
              const t = e.material;
              if (t)
                if (Array.isArray(t))
                  for (let i = 0; i < t.length; i++) {
                    const o = t[i];
                    Be(o, r, e), n.add(o);
                  }
                else Be(t, r, e), n.add(t);
            }),
            v.pop(),
            (g = null),
            n
          );
        }),
        (this.compileAsync = function (e, t, r = null) {
          const n = this.compile(e, t, r);
          return new Promise((t) => {
            function r() {
              n.forEach(function (e) {
                le.get(e).currentProgram.isReady() && n.delete(e);
              }),
                0 !== n.size ? setTimeout(r, 10) : t(e);
            }
            null !== ie.get("KHR_parallel_shader_compile")
              ? r()
              : setTimeout(r, 10);
          });
        });
      let Fe = null;
      function He() {
        je.stop();
      }
      function Ve() {
        je.start();
      }
      const je = new Ln();
      function We(e, t, r, n) {
        if (!1 === e.visible) return;
        if (e.layers.test(t.layers))
          if (e.isGroup) r = e.renderOrder;
          else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
          else if (e.isLight) g.pushLight(e), e.castShadow && g.pushShadow(e);
          else if (e.isSprite) {
            if (!e.frustumCulled || q.intersectsSprite(e)) {
              n && Z.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Q);
              const t = fe.update(e),
                i = e.material;
              i.visible && m.push(e, t, i, r, Z.z, null);
            }
          } else if (
            (e.isMesh || e.isLine || e.isPoints) &&
            (!e.frustumCulled || q.intersectsObject(e))
          ) {
            const t = fe.update(e),
              i = e.material;
            if (
              (n &&
                (void 0 !== e.boundingSphere
                  ? (null === e.boundingSphere && e.computeBoundingSphere(),
                    Z.copy(e.boundingSphere.center))
                  : (null === t.boundingSphere && t.computeBoundingSphere(),
                    Z.copy(t.boundingSphere.center)),
                Z.applyMatrix4(e.matrixWorld).applyMatrix4(Q)),
              Array.isArray(i))
            ) {
              const n = t.groups;
              for (let o = 0, s = n.length; o < s; o++) {
                const s = n[o],
                  a = i[s.materialIndex];
                a && a.visible && m.push(e, t, a, r, Z.z, s);
              }
            } else i.visible && m.push(e, t, i, r, Z.z, null);
          }
        const i = e.children;
        for (let e = 0, o = i.length; e < o; e++) We(i[e], t, r, n);
      }
      function Ge(e, t, r, n) {
        const i = e.opaque,
          o = e.transmissive,
          s = e.transparent;
        g.setupLightsView(r),
          !0 === Y && ye.setGlobalState(y.clippingPlanes, r),
          o.length > 0 &&
            (function (e, t, r, n) {
              if (null !== (!0 === r.isScene ? r.overrideMaterial : null))
                return;
              const i = oe.isWebGL2;
              null === $ &&
                ($ = new st(1, 1, {
                  generateMipmaps: !0,
                  type: ie.has("EXT_color_buffer_half_float") ? H : D,
                  minFilter: U,
                  samples: i ? 4 : 0,
                })),
                y.getDrawingBufferSize(J),
                i ? $.setSize(J.x, J.y) : $.setSize(Le(J.x), Le(J.y));
              const o = y.getRenderTarget();
              y.setRenderTarget($),
                y.getClearColor(P),
                (C = y.getClearAlpha()),
                C < 1 && y.setClearColor(16777215, 0.5),
                y.clear();
              const s = y.toneMapping;
              (y.toneMapping = 0),
                Xe(e, r, n),
                ce.updateMultisampleRenderTarget($),
                ce.updateRenderTargetMipmap($);
              let a = !1;
              for (let e = 0, i = t.length; e < i; e++) {
                const i = t[e],
                  o = i.object,
                  s = i.geometry,
                  l = i.material,
                  c = i.group;
                if (2 === l.side && o.layers.test(n.layers)) {
                  const e = l.side;
                  (l.side = 1),
                    (l.needsUpdate = !0),
                    qe(o, r, n, s, l, c),
                    (l.side = e),
                    (l.needsUpdate = !0),
                    (a = !0);
                }
              }
              !0 === a &&
                (ce.updateMultisampleRenderTarget($),
                ce.updateRenderTargetMipmap($)),
                y.setRenderTarget(o),
                y.setClearColor(P, C),
                (y.toneMapping = s);
            })(i, o, t, r),
          n && se.viewport(T.copy(n)),
          i.length > 0 && Xe(i, t, r),
          o.length > 0 && Xe(o, t, r),
          s.length > 0 && Xe(s, t, r),
          se.buffers.depth.setTest(!0),
          se.buffers.depth.setMask(!0),
          se.buffers.color.setMask(!0),
          se.setPolygonOffset(!1);
      }
      function Xe(e, t, r) {
        const n = !0 === t.isScene ? t.overrideMaterial : null;
        for (let i = 0, o = e.length; i < o; i++) {
          const o = e[i],
            s = o.object,
            a = o.geometry,
            l = null === n ? o.material : n,
            c = o.group;
          s.layers.test(r.layers) && qe(s, t, r, a, l, c);
        }
      }
      function qe(e, t, r, n, i, o) {
        e.onBeforeRender(y, t, r, n, i, o),
          e.modelViewMatrix.multiplyMatrices(
            r.matrixWorldInverse,
            e.matrixWorld
          ),
          e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
          i.onBeforeRender(y, t, r, n, e, o),
          !0 === i.transparent && 2 === i.side && !1 === i.forceSinglePass
            ? ((i.side = 1),
              (i.needsUpdate = !0),
              y.renderBufferDirect(r, t, n, i, e, o),
              (i.side = 0),
              (i.needsUpdate = !0),
              y.renderBufferDirect(r, t, n, i, e, o),
              (i.side = 2))
            : y.renderBufferDirect(r, t, n, i, e, o),
          e.onAfterRender(y, t, r, n, i, o);
      }
      function Ye(e, t, r) {
        !0 !== t.isScene && (t = ee);
        const n = le.get(e),
          i = g.state.lights,
          o = g.state.shadowsArray,
          s = i.state.version,
          a = me.getParameters(e, i.state, o, t, r),
          l = me.getProgramCacheKey(a);
        let c = n.programs;
        (n.environment = e.isMeshStandardMaterial ? t.environment : null),
          (n.fog = t.fog),
          (n.envMap = (e.isMeshStandardMaterial ? he : ue).get(
            e.envMap || n.environment
          )),
          void 0 === c &&
            (e.addEventListener("dispose", ke),
            (c = new Map()),
            (n.programs = c));
        let u = c.get(l);
        if (void 0 !== u) {
          if (n.currentProgram === u && n.lightsStateVersion === s)
            return $e(e, a), u;
        } else
          (a.uniforms = me.getUniforms(e)),
            e.onBuild(r, a, y),
            e.onBeforeCompile(a, y),
            (u = me.acquireProgram(a, l)),
            c.set(l, u),
            (n.uniforms = a.uniforms);
        const h = n.uniforms;
        return (
          ((e.isShaderMaterial || e.isRawShaderMaterial) &&
            !0 !== e.clipping) ||
            (h.clippingPlanes = ye.uniform),
          $e(e, a),
          (n.needsLights = (function (e) {
            return (
              e.isMeshLambertMaterial ||
              e.isMeshToonMaterial ||
              e.isMeshPhongMaterial ||
              e.isMeshStandardMaterial ||
              e.isShadowMaterial ||
              (e.isShaderMaterial && !0 === e.lights)
            );
          })(e)),
          (n.lightsStateVersion = s),
          n.needsLights &&
            ((h.ambientLightColor.value = i.state.ambient),
            (h.lightProbe.value = i.state.probe),
            (h.directionalLights.value = i.state.directional),
            (h.directionalLightShadows.value = i.state.directionalShadow),
            (h.spotLights.value = i.state.spot),
            (h.spotLightShadows.value = i.state.spotShadow),
            (h.rectAreaLights.value = i.state.rectArea),
            (h.ltc_1.value = i.state.rectAreaLTC1),
            (h.ltc_2.value = i.state.rectAreaLTC2),
            (h.pointLights.value = i.state.point),
            (h.pointLightShadows.value = i.state.pointShadow),
            (h.hemisphereLights.value = i.state.hemi),
            (h.directionalShadowMap.value = i.state.directionalShadowMap),
            (h.directionalShadowMatrix.value = i.state.directionalShadowMatrix),
            (h.spotShadowMap.value = i.state.spotShadowMap),
            (h.spotLightMatrix.value = i.state.spotLightMatrix),
            (h.spotLightMap.value = i.state.spotLightMap),
            (h.pointShadowMap.value = i.state.pointShadowMap),
            (h.pointShadowMatrix.value = i.state.pointShadowMatrix)),
          (n.currentProgram = u),
          (n.uniformsList = null),
          u
        );
      }
      function Ke(e) {
        if (null === e.uniformsList) {
          const t = e.currentProgram.getUniforms();
          e.uniformsList = xo.seqWithValue(t.seq, e.uniforms);
        }
        return e.uniformsList;
      }
      function $e(e, t) {
        const r = le.get(e);
        (r.outputColorSpace = t.outputColorSpace),
          (r.batching = t.batching),
          (r.instancing = t.instancing),
          (r.instancingColor = t.instancingColor),
          (r.skinning = t.skinning),
          (r.morphTargets = t.morphTargets),
          (r.morphNormals = t.morphNormals),
          (r.morphColors = t.morphColors),
          (r.morphTargetsCount = t.morphTargetsCount),
          (r.numClippingPlanes = t.numClippingPlanes),
          (r.numIntersection = t.numClipIntersection),
          (r.vertexAlphas = t.vertexAlphas),
          (r.vertexTangents = t.vertexTangents),
          (r.toneMapping = t.toneMapping);
      }
      je.setAnimationLoop(function (e) {
        Fe && Fe(e);
      }),
        "undefined" != typeof self && je.setContext(self),
        (this.setAnimationLoop = function (e) {
          (Fe = e), Ie.setAnimationLoop(e), null === e ? je.stop() : je.start();
        }),
        Ie.addEventListener("sessionstart", He),
        Ie.addEventListener("sessionend", Ve),
        (this.render = function (e, t) {
          if (void 0 !== t && !0 !== t.isCamera)
            return void console.error(
              "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
            );
          if (!0 === b) return;
          !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
            null === t.parent &&
              !0 === t.matrixWorldAutoUpdate &&
              t.updateMatrixWorld(),
            !0 === Ie.enabled &&
              !0 === Ie.isPresenting &&
              (!0 === Ie.cameraAutoUpdate && Ie.updateCamera(t),
              (t = Ie.getCamera())),
            !0 === e.isScene && e.onBeforeRender(y, e, t, S),
            (g = ve.get(e, v.length)),
            g.init(),
            v.push(g),
            Q.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            q.setFromProjectionMatrix(Q),
            (K = this.localClippingEnabled),
            (Y = ye.init(this.clippingPlanes, K)),
            (m = _e.get(e, _.length)),
            m.init(),
            _.push(m),
            We(e, t, 0, y.sortObjects),
            m.finish(),
            !0 === y.sortObjects && m.sort(N, j),
            this.info.render.frame++,
            !0 === Y && ye.beginShadows();
          const r = g.state.shadowsArray;
          if (
            (be.render(r, e, t),
            !0 === Y && ye.endShadows(),
            !0 === this.info.autoReset && this.info.reset(),
            xe.render(m, e),
            g.setupLights(y._useLegacyLights),
            t.isArrayCamera)
          ) {
            const r = t.cameras;
            for (let t = 0, n = r.length; t < n; t++) {
              const n = r[t];
              Ge(m, e, n, n.viewport);
            }
          } else Ge(m, e, t);
          null !== S &&
            (ce.updateMultisampleRenderTarget(S),
            ce.updateRenderTargetMipmap(S)),
            !0 === e.isScene && e.onAfterRender(y, e, t),
            Te.resetDefaultState(),
            (E = -1),
            (M = null),
            v.pop(),
            (g = v.length > 0 ? v[v.length - 1] : null),
            _.pop(),
            (m = _.length > 0 ? _[_.length - 1] : null);
        }),
        (this.getActiveCubeFace = function () {
          return x;
        }),
        (this.getActiveMipmapLevel = function () {
          return w;
        }),
        (this.getRenderTarget = function () {
          return S;
        }),
        (this.setRenderTargetTextures = function (e, t, r) {
          (le.get(e.texture).__webglTexture = t),
            (le.get(e.depthTexture).__webglTexture = r);
          const n = le.get(e);
          (n.__hasExternalTextures = !0),
            n.__hasExternalTextures &&
              ((n.__autoAllocateDepthBuffer = void 0 === r),
              n.__autoAllocateDepthBuffer ||
                (!0 === ie.has("WEBGL_multisampled_render_to_texture") &&
                  (console.warn(
                    "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                  ),
                  (n.__useRenderToTexture = !1))));
        }),
        (this.setRenderTargetFramebuffer = function (e, t) {
          const r = le.get(e);
          (r.__webglFramebuffer = t),
            (r.__useDefaultFramebuffer = void 0 === t);
        }),
        (this.setRenderTarget = function (e, t = 0, r = 0) {
          (S = e), (x = t), (w = r);
          let n = !0,
            i = null,
            o = !1,
            s = !1;
          if (e) {
            const a = le.get(e);
            void 0 !== a.__useDefaultFramebuffer
              ? (se.bindFramebuffer(Re.FRAMEBUFFER, null), (n = !1))
              : void 0 === a.__webglFramebuffer
              ? ce.setupRenderTarget(e)
              : a.__hasExternalTextures &&
                ce.rebindTextures(
                  e,
                  le.get(e.texture).__webglTexture,
                  le.get(e.depthTexture).__webglTexture
                );
            const l = e.texture;
            (l.isData3DTexture ||
              l.isDataArrayTexture ||
              l.isCompressedArrayTexture) &&
              (s = !0);
            const c = le.get(e).__webglFramebuffer;
            e.isWebGLCubeRenderTarget
              ? ((i = Array.isArray(c[t]) ? c[t][r] : c[t]), (o = !0))
              : (i =
                  oe.isWebGL2 &&
                  e.samples > 0 &&
                  !1 === ce.useMultisampledRTT(e)
                    ? le.get(e).__webglMultisampledFramebuffer
                    : Array.isArray(c)
                    ? c[r]
                    : c),
              T.copy(e.viewport),
              A.copy(e.scissor),
              (R = e.scissorTest);
          } else
            T.copy(W).multiplyScalar(O).floor(),
              A.copy(G).multiplyScalar(O).floor(),
              (R = X);
          if (
            (se.bindFramebuffer(Re.FRAMEBUFFER, i) &&
              oe.drawBuffers &&
              n &&
              se.drawBuffers(e, i),
            se.viewport(T),
            se.scissor(A),
            se.setScissorTest(R),
            o)
          ) {
            const n = le.get(e.texture);
            Re.framebufferTexture2D(
              Re.FRAMEBUFFER,
              Re.COLOR_ATTACHMENT0,
              Re.TEXTURE_CUBE_MAP_POSITIVE_X + t,
              n.__webglTexture,
              r
            );
          } else if (s) {
            const n = le.get(e.texture),
              i = t || 0;
            Re.framebufferTextureLayer(
              Re.FRAMEBUFFER,
              Re.COLOR_ATTACHMENT0,
              n.__webglTexture,
              r || 0,
              i
            );
          }
          E = -1;
        }),
        (this.readRenderTargetPixels = function (e, t, r, n, i, o, s) {
          if (!e || !e.isWebGLRenderTarget)
            return void console.error(
              "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
            );
          let a = le.get(e).__webglFramebuffer;
          if ((e.isWebGLCubeRenderTarget && void 0 !== s && (a = a[s]), a)) {
            se.bindFramebuffer(Re.FRAMEBUFFER, a);
            try {
              const s = e.texture,
                a = s.format,
                l = s.type;
              if (
                a !== V &&
                Me.convert(a) !==
                  Re.getParameter(Re.IMPLEMENTATION_COLOR_READ_FORMAT)
              )
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                );
              const c =
                l === H &&
                (ie.has("EXT_color_buffer_half_float") ||
                  (oe.isWebGL2 && ie.has("EXT_color_buffer_float")));
              if (
                !(
                  l === D ||
                  Me.convert(l) ===
                    Re.getParameter(Re.IMPLEMENTATION_COLOR_READ_TYPE) ||
                  (l === F &&
                    (oe.isWebGL2 ||
                      ie.has("OES_texture_float") ||
                      ie.has("WEBGL_color_buffer_float"))) ||
                  c
                )
              )
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                );
              t >= 0 &&
                t <= e.width - n &&
                r >= 0 &&
                r <= e.height - i &&
                Re.readPixels(t, r, n, i, Me.convert(a), Me.convert(l), o);
            } finally {
              const e = null !== S ? le.get(S).__webglFramebuffer : null;
              se.bindFramebuffer(Re.FRAMEBUFFER, e);
            }
          }
        }),
        (this.copyFramebufferToTexture = function (e, t, r = 0) {
          const n = Math.pow(2, -r),
            i = Math.floor(t.image.width * n),
            o = Math.floor(t.image.height * n);
          ce.setTexture2D(t, 0),
            Re.copyTexSubImage2D(Re.TEXTURE_2D, r, 0, 0, e.x, e.y, i, o),
            se.unbindTexture();
        }),
        (this.copyTextureToTexture = function (e, t, r, n = 0) {
          const i = t.image.width,
            o = t.image.height,
            s = Me.convert(r.format),
            a = Me.convert(r.type);
          ce.setTexture2D(r, 0),
            Re.pixelStorei(Re.UNPACK_FLIP_Y_WEBGL, r.flipY),
            Re.pixelStorei(
              Re.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
              r.premultiplyAlpha
            ),
            Re.pixelStorei(Re.UNPACK_ALIGNMENT, r.unpackAlignment),
            t.isDataTexture
              ? Re.texSubImage2D(
                  Re.TEXTURE_2D,
                  n,
                  e.x,
                  e.y,
                  i,
                  o,
                  s,
                  a,
                  t.image.data
                )
              : t.isCompressedTexture
              ? Re.compressedTexSubImage2D(
                  Re.TEXTURE_2D,
                  n,
                  e.x,
                  e.y,
                  t.mipmaps[0].width,
                  t.mipmaps[0].height,
                  s,
                  t.mipmaps[0].data
                )
              : Re.texSubImage2D(Re.TEXTURE_2D, n, e.x, e.y, s, a, t.image),
            0 === n && r.generateMipmaps && Re.generateMipmap(Re.TEXTURE_2D),
            se.unbindTexture();
        }),
        (this.copyTextureToTexture3D = function (e, t, r, n, i = 0) {
          if (y.isWebGL1Renderer)
            return void console.warn(
              "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
            );
          const o = e.max.x - e.min.x + 1,
            s = e.max.y - e.min.y + 1,
            a = e.max.z - e.min.z + 1,
            l = Me.convert(n.format),
            c = Me.convert(n.type);
          let u;
          if (n.isData3DTexture) ce.setTexture3D(n, 0), (u = Re.TEXTURE_3D);
          else {
            if (!n.isDataArrayTexture && !n.isCompressedArrayTexture)
              return void console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
              );
            ce.setTexture2DArray(n, 0), (u = Re.TEXTURE_2D_ARRAY);
          }
          Re.pixelStorei(Re.UNPACK_FLIP_Y_WEBGL, n.flipY),
            Re.pixelStorei(
              Re.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
              n.premultiplyAlpha
            ),
            Re.pixelStorei(Re.UNPACK_ALIGNMENT, n.unpackAlignment);
          const h = Re.getParameter(Re.UNPACK_ROW_LENGTH),
            d = Re.getParameter(Re.UNPACK_IMAGE_HEIGHT),
            p = Re.getParameter(Re.UNPACK_SKIP_PIXELS),
            f = Re.getParameter(Re.UNPACK_SKIP_ROWS),
            m = Re.getParameter(Re.UNPACK_SKIP_IMAGES),
            g = r.isCompressedTexture ? r.mipmaps[i] : r.image;
          Re.pixelStorei(Re.UNPACK_ROW_LENGTH, g.width),
            Re.pixelStorei(Re.UNPACK_IMAGE_HEIGHT, g.height),
            Re.pixelStorei(Re.UNPACK_SKIP_PIXELS, e.min.x),
            Re.pixelStorei(Re.UNPACK_SKIP_ROWS, e.min.y),
            Re.pixelStorei(Re.UNPACK_SKIP_IMAGES, e.min.z),
            r.isDataTexture || r.isData3DTexture
              ? Re.texSubImage3D(u, i, t.x, t.y, t.z, o, s, a, l, c, g.data)
              : r.isCompressedArrayTexture
              ? (console.warn(
                  "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                ),
                Re.compressedTexSubImage3D(
                  u,
                  i,
                  t.x,
                  t.y,
                  t.z,
                  o,
                  s,
                  a,
                  l,
                  g.data
                ))
              : Re.texSubImage3D(u, i, t.x, t.y, t.z, o, s, a, l, c, g),
            Re.pixelStorei(Re.UNPACK_ROW_LENGTH, h),
            Re.pixelStorei(Re.UNPACK_IMAGE_HEIGHT, d),
            Re.pixelStorei(Re.UNPACK_SKIP_PIXELS, p),
            Re.pixelStorei(Re.UNPACK_SKIP_ROWS, f),
            Re.pixelStorei(Re.UNPACK_SKIP_IMAGES, m),
            0 === i && n.generateMipmaps && Re.generateMipmap(u),
            se.unbindTexture();
        }),
        (this.initTexture = function (e) {
          e.isCubeTexture
            ? ce.setTextureCube(e, 0)
            : e.isData3DTexture
            ? ce.setTexture3D(e, 0)
            : e.isDataArrayTexture || e.isCompressedArrayTexture
            ? ce.setTexture2DArray(e, 0)
            : ce.setTexture2D(e, 0),
            se.unbindTexture();
        }),
        (this.resetState = function () {
          (x = 0), (w = 0), (S = null), se.reset(), Te.reset();
        }),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this })
          );
    }
    get coordinateSystem() {
      return xe;
    }
    get outputColorSpace() {
      return this._outputColorSpace;
    }
    set outputColorSpace(e) {
      this._outputColorSpace = e;
      const t = this.getContext();
      (t.drawingBufferColorSpace = e === ne ? "display-p3" : "srgb"),
        (t.unpackColorSpace =
          Ye.workingColorSpace === ie ? "display-p3" : "srgb");
    }
    get outputEncoding() {
      return (
        console.warn(
          "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
        ),
        this.outputColorSpace === te ? Z : 3e3
      );
    }
    set outputEncoding(e) {
      console.warn(
        "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
      ),
        (this.outputColorSpace = e === Z ? te : re);
    }
    get useLegacyLights() {
      return (
        console.warn(
          "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
        ),
        this._useLegacyLights
      );
    }
    set useLegacyLights(e) {
      console.warn(
        "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
      ),
        (this._useLegacyLights = e);
    }
  }
  (class extends ps {}).prototype.isWebGL1Renderer = !0;
  class fs {
    constructor(e, t) {
      (this.isInterleavedBuffer = !0),
        (this.array = e),
        (this.stride = t),
        (this.count = void 0 !== e ? e.length / t : 0),
        (this.usage = ve),
        (this._updateRange = { offset: 0, count: -1 }),
        (this.updateRanges = []),
        (this.version = 0),
        (this.uuid = Ae());
    }
    onUploadCallback() {}
    set needsUpdate(e) {
      !0 === e && this.version++;
    }
    get updateRange() {
      return (
        console.warn(
          "THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
        ),
        this._updateRange
      );
    }
    setUsage(e) {
      return (this.usage = e), this;
    }
    addUpdateRange(e, t) {
      this.updateRanges.push({ start: e, count: t });
    }
    clearUpdateRanges() {
      this.updateRanges.length = 0;
    }
    copy(e) {
      return (
        (this.array = new e.array.constructor(e.array)),
        (this.count = e.count),
        (this.stride = e.stride),
        (this.usage = e.usage),
        this
      );
    }
    copyAt(e, t, r) {
      (e *= this.stride), (r *= t.stride);
      for (let n = 0, i = this.stride; n < i; n++)
        this.array[e + n] = t.array[r + n];
      return this;
    }
    set(e, t = 0) {
      return this.array.set(e, t), this;
    }
    clone(e) {
      void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
        void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Ae()),
        void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
          (e.arrayBuffers[this.array.buffer._uuid] =
            this.array.slice(0).buffer);
      const t = new this.array.constructor(
          e.arrayBuffers[this.array.buffer._uuid]
        ),
        r = new this.constructor(t, this.stride);
      return r.setUsage(this.usage), r;
    }
    onUpload(e) {
      return (this.onUploadCallback = e), this;
    }
    toJSON(e) {
      return (
        void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
        void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Ae()),
        void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
          (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
            new Uint32Array(this.array.buffer)
          )),
        {
          uuid: this.uuid,
          buffer: this.array.buffer._uuid,
          type: this.array.constructor.name,
          stride: this.stride,
        }
      );
    }
  }
  const ms = new ut();
  class gs {
    constructor(e, t, r, n = !1) {
      (this.isInterleavedBufferAttribute = !0),
        (this.name = ""),
        (this.data = e),
        (this.itemSize = t),
        (this.offset = r),
        (this.normalized = n);
    }
    get count() {
      return this.data.count;
    }
    get array() {
      return this.data.array;
    }
    set needsUpdate(e) {
      this.data.needsUpdate = e;
    }
    applyMatrix4(e) {
      for (let t = 0, r = this.data.count; t < r; t++)
        ms.fromBufferAttribute(this, t),
          ms.applyMatrix4(e),
          this.setXYZ(t, ms.x, ms.y, ms.z);
      return this;
    }
    applyNormalMatrix(e) {
      for (let t = 0, r = this.count; t < r; t++)
        ms.fromBufferAttribute(this, t),
          ms.applyNormalMatrix(e),
          this.setXYZ(t, ms.x, ms.y, ms.z);
      return this;
    }
    transformDirection(e) {
      for (let t = 0, r = this.count; t < r; t++)
        ms.fromBufferAttribute(this, t),
          ms.transformDirection(e),
          this.setXYZ(t, ms.x, ms.y, ms.z);
      return this;
    }
    setX(e, t) {
      return (
        this.normalized && (t = Ne(t, this.array)),
        (this.data.array[e * this.data.stride + this.offset] = t),
        this
      );
    }
    setY(e, t) {
      return (
        this.normalized && (t = Ne(t, this.array)),
        (this.data.array[e * this.data.stride + this.offset + 1] = t),
        this
      );
    }
    setZ(e, t) {
      return (
        this.normalized && (t = Ne(t, this.array)),
        (this.data.array[e * this.data.stride + this.offset + 2] = t),
        this
      );
    }
    setW(e, t) {
      return (
        this.normalized && (t = Ne(t, this.array)),
        (this.data.array[e * this.data.stride + this.offset + 3] = t),
        this
      );
    }
    getX(e) {
      let t = this.data.array[e * this.data.stride + this.offset];
      return this.normalized && (t = Oe(t, this.array)), t;
    }
    getY(e) {
      let t = this.data.array[e * this.data.stride + this.offset + 1];
      return this.normalized && (t = Oe(t, this.array)), t;
    }
    getZ(e) {
      let t = this.data.array[e * this.data.stride + this.offset + 2];
      return this.normalized && (t = Oe(t, this.array)), t;
    }
    getW(e) {
      let t = this.data.array[e * this.data.stride + this.offset + 3];
      return this.normalized && (t = Oe(t, this.array)), t;
    }
    setXY(e, t, r) {
      return (
        (e = e * this.data.stride + this.offset),
        this.normalized && ((t = Ne(t, this.array)), (r = Ne(r, this.array))),
        (this.data.array[e + 0] = t),
        (this.data.array[e + 1] = r),
        this
      );
    }
    setXYZ(e, t, r, n) {
      return (
        (e = e * this.data.stride + this.offset),
        this.normalized &&
          ((t = Ne(t, this.array)),
          (r = Ne(r, this.array)),
          (n = Ne(n, this.array))),
        (this.data.array[e + 0] = t),
        (this.data.array[e + 1] = r),
        (this.data.array[e + 2] = n),
        this
      );
    }
    setXYZW(e, t, r, n, i) {
      return (
        (e = e * this.data.stride + this.offset),
        this.normalized &&
          ((t = Ne(t, this.array)),
          (r = Ne(r, this.array)),
          (n = Ne(n, this.array)),
          (i = Ne(i, this.array))),
        (this.data.array[e + 0] = t),
        (this.data.array[e + 1] = r),
        (this.data.array[e + 2] = n),
        (this.data.array[e + 3] = i),
        this
      );
    }
    clone(e) {
      if (void 0 === e) {
        console.log(
          "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
        );
        const e = [];
        for (let t = 0; t < this.count; t++) {
          const r = t * this.data.stride + this.offset;
          for (let t = 0; t < this.itemSize; t++)
            e.push(this.data.array[r + t]);
        }
        return new Ur(
          new this.array.constructor(e),
          this.itemSize,
          this.normalized
        );
      }
      return (
        void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
        void 0 === e.interleavedBuffers[this.data.uuid] &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new gs(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
    }
    toJSON(e) {
      if (void 0 === e) {
        console.log(
          "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
        );
        const e = [];
        for (let t = 0; t < this.count; t++) {
          const r = t * this.data.stride + this.offset;
          for (let t = 0; t < this.itemSize; t++)
            e.push(this.data.array[r + t]);
        }
        return {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: e,
          normalized: this.normalized,
        };
      }
      return (
        void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
        void 0 === e.interleavedBuffers[this.data.uuid] &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
    }
  }
  const _s = new ut(),
    vs = new it(),
    ys = new it(),
    bs = new ut(),
    xs = new Ht(),
    ws = new ut(),
    Ss = new It(),
    Es = new Ht(),
    Ms = new Ft();
  class Ts extends hn {
    constructor(e, t) {
      super(e, t),
        (this.isSkinnedMesh = !0),
        (this.type = "SkinnedMesh"),
        (this.bindMode = S),
        (this.bindMatrix = new Ht()),
        (this.bindMatrixInverse = new Ht()),
        (this.boundingBox = null),
        (this.boundingSphere = null);
    }
    computeBoundingBox() {
      const e = this.geometry;
      null === this.boundingBox && (this.boundingBox = new pt()),
        this.boundingBox.makeEmpty();
      const t = e.getAttribute("position");
      for (let e = 0; e < t.count; e++)
        this.getVertexPosition(e, ws), this.boundingBox.expandByPoint(ws);
    }
    computeBoundingSphere() {
      const e = this.geometry;
      null === this.boundingSphere && (this.boundingSphere = new It()),
        this.boundingSphere.makeEmpty();
      const t = e.getAttribute("position");
      for (let e = 0; e < t.count; e++)
        this.getVertexPosition(e, ws), this.boundingSphere.expandByPoint(ws);
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        (this.bindMode = e.bindMode),
        this.bindMatrix.copy(e.bindMatrix),
        this.bindMatrixInverse.copy(e.bindMatrixInverse),
        (this.skeleton = e.skeleton),
        null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
        null !== e.boundingSphere &&
          (this.boundingSphere = e.boundingSphere.clone()),
        this
      );
    }
    raycast(e, t) {
      const r = this.material,
        n = this.matrixWorld;
      void 0 !== r &&
        (null === this.boundingSphere && this.computeBoundingSphere(),
        Ss.copy(this.boundingSphere),
        Ss.applyMatrix4(n),
        !1 !== e.ray.intersectsSphere(Ss) &&
          (Es.copy(n).invert(),
          Ms.copy(e.ray).applyMatrix4(Es),
          (null !== this.boundingBox &&
            !1 === Ms.intersectsBox(this.boundingBox)) ||
            this._computeIntersections(e, t, Ms)));
    }
    getVertexPosition(e, t) {
      return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
    }
    bind(e, t) {
      (this.skeleton = e),
        void 0 === t &&
          (this.updateMatrixWorld(!0),
          this.skeleton.calculateInverses(),
          (t = this.matrixWorld)),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert();
    }
    pose() {
      this.skeleton.pose();
    }
    normalizeSkinWeights() {
      const e = new it(),
        t = this.geometry.attributes.skinWeight;
      for (let r = 0, n = t.count; r < n; r++) {
        e.fromBufferAttribute(t, r);
        const n = 1 / e.manhattanLength();
        n !== 1 / 0 ? e.multiplyScalar(n) : e.set(1, 0, 0, 0),
          t.setXYZW(r, e.x, e.y, e.z, e.w);
      }
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e),
        this.bindMode === S
          ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
          : "detached" === this.bindMode
          ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
          : console.warn(
              "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
            );
    }
    applyBoneTransform(e, t) {
      const r = this.skeleton,
        n = this.geometry;
      vs.fromBufferAttribute(n.attributes.skinIndex, e),
        ys.fromBufferAttribute(n.attributes.skinWeight, e),
        _s.copy(t).applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
      for (let e = 0; e < 4; e++) {
        const n = ys.getComponent(e);
        if (0 !== n) {
          const i = vs.getComponent(e);
          xs.multiplyMatrices(r.bones[i].matrixWorld, r.boneInverses[i]),
            t.addScaledVector(bs.copy(_s).applyMatrix4(xs), n);
        }
      }
      return t.applyMatrix4(this.bindMatrixInverse);
    }
    boneTransform(e, t) {
      return (
        console.warn(
          "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."
        ),
        this.applyBoneTransform(e, t)
      );
    }
  }
  class As extends hr {
    constructor() {
      super(), (this.isBone = !0), (this.type = "Bone");
    }
  }
  class Rs extends nt {
    constructor(
      e = null,
      t = 1,
      r = 1,
      n,
      i,
      o,
      s,
      a,
      l = 1003,
      c = 1003,
      u,
      h
    ) {
      super(null, o, s, a, l, c, n, i, u, h),
        (this.isDataTexture = !0),
        (this.image = { data: e, width: t, height: r }),
        (this.generateMipmaps = !1),
        (this.flipY = !1),
        (this.unpackAlignment = 1);
    }
  }
  const Ps = new Ht(),
    Cs = new Ht();
  class Is {
    constructor(e = [], t = []) {
      (this.uuid = Ae()),
        (this.bones = e.slice(0)),
        (this.boneInverses = t),
        (this.boneMatrices = null),
        (this.boneTexture = null),
        this.init();
    }
    init() {
      const e = this.bones,
        t = this.boneInverses;
      if (
        ((this.boneMatrices = new Float32Array(16 * e.length)), 0 === t.length)
      )
        this.calculateInverses();
      else if (e.length !== t.length) {
        console.warn(
          "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
        ),
          (this.boneInverses = []);
        for (let e = 0, t = this.bones.length; e < t; e++)
          this.boneInverses.push(new Ht());
      }
    }
    calculateInverses() {
      this.boneInverses.length = 0;
      for (let e = 0, t = this.bones.length; e < t; e++) {
        const t = new Ht();
        this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
          this.boneInverses.push(t);
      }
    }
    pose() {
      for (let e = 0, t = this.bones.length; e < t; e++) {
        const t = this.bones[e];
        t && t.matrixWorld.copy(this.boneInverses[e]).invert();
      }
      for (let e = 0, t = this.bones.length; e < t; e++) {
        const t = this.bones[e];
        t &&
          (t.parent && t.parent.isBone
            ? (t.matrix.copy(t.parent.matrixWorld).invert(),
              t.matrix.multiply(t.matrixWorld))
            : t.matrix.copy(t.matrixWorld),
          t.matrix.decompose(t.position, t.quaternion, t.scale));
      }
    }
    update() {
      const e = this.bones,
        t = this.boneInverses,
        r = this.boneMatrices,
        n = this.boneTexture;
      for (let n = 0, i = e.length; n < i; n++) {
        const i = e[n] ? e[n].matrixWorld : Cs;
        Ps.multiplyMatrices(i, t[n]), Ps.toArray(r, 16 * n);
      }
      null !== n && (n.needsUpdate = !0);
    }
    clone() {
      return new Is(this.bones, this.boneInverses);
    }
    computeBoneTexture() {
      let e = Math.sqrt(4 * this.bones.length);
      (e = 4 * Math.ceil(e / 4)), (e = Math.max(e, 4));
      const t = new Float32Array(e * e * 4);
      t.set(this.boneMatrices);
      const r = new Rs(t, e, e, V, F);
      return (
        (r.needsUpdate = !0),
        (this.boneMatrices = t),
        (this.boneTexture = r),
        this
      );
    }
    getBoneByName(e) {
      for (let t = 0, r = this.bones.length; t < r; t++) {
        const r = this.bones[t];
        if (r.name === e) return r;
      }
    }
    dispose() {
      null !== this.boneTexture &&
        (this.boneTexture.dispose(), (this.boneTexture = null));
    }
    fromJSON(e, t) {
      this.uuid = e.uuid;
      for (let r = 0, n = e.bones.length; r < n; r++) {
        const n = e.bones[r];
        let i = t[n];
        void 0 === i &&
          (console.warn("THREE.Skeleton: No bone found with UUID:", n),
          (i = new As())),
          this.bones.push(i),
          this.boneInverses.push(new Ht().fromArray(e.boneInverses[r]));
      }
      return this.init(), this;
    }
    toJSON() {
      const e = {
        metadata: {
          version: 4.6,
          type: "Skeleton",
          generator: "Skeleton.toJSON",
        },
        bones: [],
        boneInverses: [],
      };
      e.uuid = this.uuid;
      const t = this.bones,
        r = this.boneInverses;
      for (let n = 0, i = t.length; n < i; n++) {
        const i = t[n];
        e.bones.push(i.uuid);
        const o = r[n];
        e.boneInverses.push(o.toArray());
      }
      return e;
    }
  }
  class Ls extends Ur {
    constructor(e, t, r, n = 1) {
      super(e, t, r),
        (this.isInstancedBufferAttribute = !0),
        (this.meshPerAttribute = n);
    }
    copy(e) {
      return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
    }
    toJSON() {
      const e = super.toJSON();
      return (
        (e.meshPerAttribute = this.meshPerAttribute),
        (e.isInstancedBufferAttribute = !0),
        e
      );
    }
  }
  const Os = new Ht(),
    Ns = new Ht(),
    Us = [],
    Ds = new pt(),
    ks = new Ht(),
    Bs = new hn(),
    Fs = new It();
  class Hs extends hn {
    constructor(e, t, r) {
      super(e, t),
        (this.isInstancedMesh = !0),
        (this.instanceMatrix = new Ls(new Float32Array(16 * r), 16)),
        (this.instanceColor = null),
        (this.count = r),
        (this.boundingBox = null),
        (this.boundingSphere = null);
      for (let e = 0; e < r; e++) this.setMatrixAt(e, ks);
    }
    computeBoundingBox() {
      const e = this.geometry,
        t = this.count;
      null === this.boundingBox && (this.boundingBox = new pt()),
        null === e.boundingBox && e.computeBoundingBox(),
        this.boundingBox.makeEmpty();
      for (let r = 0; r < t; r++)
        this.getMatrixAt(r, Os),
          Ds.copy(e.boundingBox).applyMatrix4(Os),
          this.boundingBox.union(Ds);
    }
    computeBoundingSphere() {
      const e = this.geometry,
        t = this.count;
      null === this.boundingSphere && (this.boundingSphere = new It()),
        null === e.boundingSphere && e.computeBoundingSphere(),
        this.boundingSphere.makeEmpty();
      for (let r = 0; r < t; r++)
        this.getMatrixAt(r, Os),
          Fs.copy(e.boundingSphere).applyMatrix4(Os),
          this.boundingSphere.union(Fs);
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        this.instanceMatrix.copy(e.instanceMatrix),
        null !== e.instanceColor &&
          (this.instanceColor = e.instanceColor.clone()),
        (this.count = e.count),
        null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
        null !== e.boundingSphere &&
          (this.boundingSphere = e.boundingSphere.clone()),
        this
      );
    }
    getColorAt(e, t) {
      t.fromArray(this.instanceColor.array, 3 * e);
    }
    getMatrixAt(e, t) {
      t.fromArray(this.instanceMatrix.array, 16 * e);
    }
    raycast(e, t) {
      const r = this.matrixWorld,
        n = this.count;
      if (
        ((Bs.geometry = this.geometry),
        (Bs.material = this.material),
        void 0 !== Bs.material &&
          (null === this.boundingSphere && this.computeBoundingSphere(),
          Fs.copy(this.boundingSphere),
          Fs.applyMatrix4(r),
          !1 !== e.ray.intersectsSphere(Fs)))
      )
        for (let i = 0; i < n; i++) {
          this.getMatrixAt(i, Os),
            Ns.multiplyMatrices(r, Os),
            (Bs.matrixWorld = Ns),
            Bs.raycast(e, Us);
          for (let e = 0, r = Us.length; e < r; e++) {
            const r = Us[e];
            (r.instanceId = i), (r.object = this), t.push(r);
          }
          Us.length = 0;
        }
    }
    setColorAt(e, t) {
      null === this.instanceColor &&
        (this.instanceColor = new Ls(
          new Float32Array(3 * this.instanceMatrix.count),
          3
        )),
        t.toArray(this.instanceColor.array, 3 * e);
    }
    setMatrixAt(e, t) {
      t.toArray(this.instanceMatrix.array, 16 * e);
    }
    updateMorphTargets() {}
    dispose() {
      this.dispatchEvent({ type: "dispose" });
    }
  }
  class zs extends Ir {
    constructor(e) {
      super(),
        (this.isLineBasicMaterial = !0),
        (this.type = "LineBasicMaterial"),
        (this.color = new Rr(16777215)),
        (this.map = null),
        (this.linewidth = 1),
        (this.linecap = "round"),
        (this.linejoin = "round"),
        (this.fog = !0),
        this.setValues(e);
    }
    copy(e) {
      return (
        super.copy(e),
        this.color.copy(e.color),
        (this.map = e.map),
        (this.linewidth = e.linewidth),
        (this.linecap = e.linecap),
        (this.linejoin = e.linejoin),
        (this.fog = e.fog),
        this
      );
    }
  }
  const Vs = new ut(),
    js = new ut(),
    Ws = new Ht(),
    Gs = new Ft(),
    Xs = new It();
  class qs extends hr {
    constructor(e = new Xr(), t = new zs()) {
      super(),
        (this.isLine = !0),
        (this.type = "Line"),
        (this.geometry = e),
        (this.material = t),
        this.updateMorphTargets();
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        (this.material = Array.isArray(e.material)
          ? e.material.slice()
          : e.material),
        (this.geometry = e.geometry),
        this
      );
    }
    computeLineDistances() {
      const e = this.geometry;
      if (null === e.index) {
        const t = e.attributes.position,
          r = [0];
        for (let e = 1, n = t.count; e < n; e++)
          Vs.fromBufferAttribute(t, e - 1),
            js.fromBufferAttribute(t, e),
            (r[e] = r[e - 1]),
            (r[e] += Vs.distanceTo(js));
        e.setAttribute("lineDistance", new Br(r, 1));
      } else
        console.warn(
          "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
        );
      return this;
    }
    raycast(e, t) {
      const r = this.geometry,
        n = this.matrixWorld,
        i = e.params.Line.threshold,
        o = r.drawRange;
      if (
        (null === r.boundingSphere && r.computeBoundingSphere(),
        Xs.copy(r.boundingSphere),
        Xs.applyMatrix4(n),
        (Xs.radius += i),
        !1 === e.ray.intersectsSphere(Xs))
      )
        return;
      Ws.copy(n).invert(), Gs.copy(e.ray).applyMatrix4(Ws);
      const s = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
        a = s * s,
        l = new ut(),
        c = new ut(),
        u = new ut(),
        h = new ut(),
        d = this.isLineSegments ? 2 : 1,
        p = r.index,
        f = r.attributes.position;
      if (null !== p)
        for (
          let r = Math.max(0, o.start),
            n = Math.min(p.count, o.start + o.count) - 1;
          r < n;
          r += d
        ) {
          const n = p.getX(r),
            i = p.getX(r + 1);
          if (
            (l.fromBufferAttribute(f, n),
            c.fromBufferAttribute(f, i),
            Gs.distanceSqToSegment(l, c, h, u) > a)
          )
            continue;
          h.applyMatrix4(this.matrixWorld);
          const o = e.ray.origin.distanceTo(h);
          o < e.near ||
            o > e.far ||
            t.push({
              distance: o,
              point: u.clone().applyMatrix4(this.matrixWorld),
              index: r,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      else
        for (
          let r = Math.max(0, o.start),
            n = Math.min(f.count, o.start + o.count) - 1;
          r < n;
          r += d
        ) {
          if (
            (l.fromBufferAttribute(f, r),
            c.fromBufferAttribute(f, r + 1),
            Gs.distanceSqToSegment(l, c, h, u) > a)
          )
            continue;
          h.applyMatrix4(this.matrixWorld);
          const n = e.ray.origin.distanceTo(h);
          n < e.near ||
            n > e.far ||
            t.push({
              distance: n,
              point: u.clone().applyMatrix4(this.matrixWorld),
              index: r,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
    }
    updateMorphTargets() {
      const e = this.geometry.morphAttributes,
        t = Object.keys(e);
      if (t.length > 0) {
        const r = e[t[0]];
        if (void 0 !== r) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let e = 0, t = r.length; e < t; e++) {
            const t = r[e].name || String(e);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[t] = e);
          }
        }
      }
    }
  }
  const Ys = new ut(),
    Ks = new ut();
  class $s extends qs {
    constructor(e, t) {
      super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
    }
    computeLineDistances() {
      const e = this.geometry;
      if (null === e.index) {
        const t = e.attributes.position,
          r = [];
        for (let e = 0, n = t.count; e < n; e += 2)
          Ys.fromBufferAttribute(t, e),
            Ks.fromBufferAttribute(t, e + 1),
            (r[e] = 0 === e ? 0 : r[e - 1]),
            (r[e + 1] = r[e] + Ys.distanceTo(Ks));
        e.setAttribute("lineDistance", new Br(r, 1));
      } else
        console.warn(
          "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
        );
      return this;
    }
  }
  class Qs extends qs {
    constructor(e, t) {
      super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
    }
  }
  class Js extends Ir {
    constructor(e) {
      super(),
        (this.isPointsMaterial = !0),
        (this.type = "PointsMaterial"),
        (this.color = new Rr(16777215)),
        (this.map = null),
        (this.alphaMap = null),
        (this.size = 1),
        (this.sizeAttenuation = !0),
        (this.fog = !0),
        this.setValues(e);
    }
    copy(e) {
      return (
        super.copy(e),
        this.color.copy(e.color),
        (this.map = e.map),
        (this.alphaMap = e.alphaMap),
        (this.size = e.size),
        (this.sizeAttenuation = e.sizeAttenuation),
        (this.fog = e.fog),
        this
      );
    }
  }
  const Zs = new Ht(),
    ea = new Ft(),
    ta = new It(),
    ra = new ut();
  class na extends hr {
    constructor(e = new Xr(), t = new Js()) {
      super(),
        (this.isPoints = !0),
        (this.type = "Points"),
        (this.geometry = e),
        (this.material = t),
        this.updateMorphTargets();
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        (this.material = Array.isArray(e.material)
          ? e.material.slice()
          : e.material),
        (this.geometry = e.geometry),
        this
      );
    }
    raycast(e, t) {
      const r = this.geometry,
        n = this.matrixWorld,
        i = e.params.Points.threshold,
        o = r.drawRange;
      if (
        (null === r.boundingSphere && r.computeBoundingSphere(),
        ta.copy(r.boundingSphere),
        ta.applyMatrix4(n),
        (ta.radius += i),
        !1 === e.ray.intersectsSphere(ta))
      )
        return;
      Zs.copy(n).invert(), ea.copy(e.ray).applyMatrix4(Zs);
      const s = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
        a = s * s,
        l = r.index,
        c = r.attributes.position;
      if (null !== l)
        for (
          let r = Math.max(0, o.start),
            i = Math.min(l.count, o.start + o.count);
          r < i;
          r++
        ) {
          const i = l.getX(r);
          ra.fromBufferAttribute(c, i), ia(ra, i, a, n, e, t, this);
        }
      else
        for (
          let r = Math.max(0, o.start),
            i = Math.min(c.count, o.start + o.count);
          r < i;
          r++
        )
          ra.fromBufferAttribute(c, r), ia(ra, r, a, n, e, t, this);
    }
    updateMorphTargets() {
      const e = this.geometry.morphAttributes,
        t = Object.keys(e);
      if (t.length > 0) {
        const r = e[t[0]];
        if (void 0 !== r) {
          (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
          for (let e = 0, t = r.length; e < t; e++) {
            const t = r[e].name || String(e);
            this.morphTargetInfluences.push(0),
              (this.morphTargetDictionary[t] = e);
          }
        }
      }
    }
  }
  function ia(e, t, r, n, i, o, s) {
    const a = ea.distanceSqToPoint(e);
    if (a < r) {
      const r = new ut();
      ea.closestPointToPoint(e, r), r.applyMatrix4(n);
      const l = i.ray.origin.distanceTo(r);
      if (l < i.near || l > i.far) return;
      o.push({
        distance: l,
        distanceToRay: Math.sqrt(a),
        point: r,
        index: t,
        face: null,
        object: s,
      });
    }
  }
  class oa extends Xr {
    constructor(
      e = 1,
      t = 32,
      r = 16,
      n = 0,
      i = 2 * Math.PI,
      o = 0,
      s = Math.PI
    ) {
      super(),
        (this.type = "SphereGeometry"),
        (this.parameters = {
          radius: e,
          widthSegments: t,
          heightSegments: r,
          phiStart: n,
          phiLength: i,
          thetaStart: o,
          thetaLength: s,
        }),
        (t = Math.max(3, Math.floor(t))),
        (r = Math.max(2, Math.floor(r)));
      const a = Math.min(o + s, Math.PI);
      let l = 0;
      const c = [],
        u = new ut(),
        h = new ut(),
        d = [],
        p = [],
        f = [],
        m = [];
      for (let d = 0; d <= r; d++) {
        const g = [],
          _ = d / r;
        let v = 0;
        0 === d && 0 === o
          ? (v = 0.5 / t)
          : d === r && a === Math.PI && (v = -0.5 / t);
        for (let r = 0; r <= t; r++) {
          const a = r / t;
          (u.x = -e * Math.cos(n + a * i) * Math.sin(o + _ * s)),
            (u.y = e * Math.cos(o + _ * s)),
            (u.z = e * Math.sin(n + a * i) * Math.sin(o + _ * s)),
            p.push(u.x, u.y, u.z),
            h.copy(u).normalize(),
            f.push(h.x, h.y, h.z),
            m.push(a + v, 1 - _),
            g.push(l++);
        }
        c.push(g);
      }
      for (let e = 0; e < r; e++)
        for (let n = 0; n < t; n++) {
          const t = c[e][n + 1],
            i = c[e][n],
            s = c[e + 1][n],
            l = c[e + 1][n + 1];
          (0 !== e || o > 0) && d.push(t, i, l),
            (e !== r - 1 || a < Math.PI) && d.push(i, s, l);
        }
      this.setIndex(d),
        this.setAttribute("position", new Br(p, 3)),
        this.setAttribute("normal", new Br(f, 3)),
        this.setAttribute("uv", new Br(m, 2));
    }
    copy(e) {
      return (
        super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
      );
    }
    static fromJSON(e) {
      return new oa(
        e.radius,
        e.widthSegments,
        e.heightSegments,
        e.phiStart,
        e.phiLength,
        e.thetaStart,
        e.thetaLength
      );
    }
  }
  class sa extends Ir {
    constructor(e) {
      super(),
        (this.isMeshStandardMaterial = !0),
        (this.defines = { STANDARD: "" }),
        (this.type = "MeshStandardMaterial"),
        (this.color = new Rr(16777215)),
        (this.roughness = 1),
        (this.metalness = 0),
        (this.map = null),
        (this.lightMap = null),
        (this.lightMapIntensity = 1),
        (this.aoMap = null),
        (this.aoMapIntensity = 1),
        (this.emissive = new Rr(0)),
        (this.emissiveIntensity = 1),
        (this.emissiveMap = null),
        (this.bumpMap = null),
        (this.bumpScale = 1),
        (this.normalMap = null),
        (this.normalMapType = 0),
        (this.normalScale = new De(1, 1)),
        (this.displacementMap = null),
        (this.displacementScale = 1),
        (this.displacementBias = 0),
        (this.roughnessMap = null),
        (this.metalnessMap = null),
        (this.alphaMap = null),
        (this.envMap = null),
        (this.envMapIntensity = 1),
        (this.wireframe = !1),
        (this.wireframeLinewidth = 1),
        (this.wireframeLinecap = "round"),
        (this.wireframeLinejoin = "round"),
        (this.flatShading = !1),
        (this.fog = !0),
        this.setValues(e);
    }
    copy(e) {
      return (
        super.copy(e),
        (this.defines = { STANDARD: "" }),
        this.color.copy(e.color),
        (this.roughness = e.roughness),
        (this.metalness = e.metalness),
        (this.map = e.map),
        (this.lightMap = e.lightMap),
        (this.lightMapIntensity = e.lightMapIntensity),
        (this.aoMap = e.aoMap),
        (this.aoMapIntensity = e.aoMapIntensity),
        this.emissive.copy(e.emissive),
        (this.emissiveMap = e.emissiveMap),
        (this.emissiveIntensity = e.emissiveIntensity),
        (this.bumpMap = e.bumpMap),
        (this.bumpScale = e.bumpScale),
        (this.normalMap = e.normalMap),
        (this.normalMapType = e.normalMapType),
        this.normalScale.copy(e.normalScale),
        (this.displacementMap = e.displacementMap),
        (this.displacementScale = e.displacementScale),
        (this.displacementBias = e.displacementBias),
        (this.roughnessMap = e.roughnessMap),
        (this.metalnessMap = e.metalnessMap),
        (this.alphaMap = e.alphaMap),
        (this.envMap = e.envMap),
        (this.envMapIntensity = e.envMapIntensity),
        (this.wireframe = e.wireframe),
        (this.wireframeLinewidth = e.wireframeLinewidth),
        (this.wireframeLinecap = e.wireframeLinecap),
        (this.wireframeLinejoin = e.wireframeLinejoin),
        (this.flatShading = e.flatShading),
        (this.fog = e.fog),
        this
      );
    }
  }
  class aa extends sa {
    constructor(e) {
      super(),
        (this.isMeshPhysicalMaterial = !0),
        (this.defines = { STANDARD: "", PHYSICAL: "" }),
        (this.type = "MeshPhysicalMaterial"),
        (this.anisotropyRotation = 0),
        (this.anisotropyMap = null),
        (this.clearcoatMap = null),
        (this.clearcoatRoughness = 0),
        (this.clearcoatRoughnessMap = null),
        (this.clearcoatNormalScale = new De(1, 1)),
        (this.clearcoatNormalMap = null),
        (this.ior = 1.5),
        Object.defineProperty(this, "reflectivity", {
          get: function () {
            return Re((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
          },
          set: function (e) {
            this.ior = (1 + 0.4 * e) / (1 - 0.4 * e);
          },
        }),
        (this.iridescenceMap = null),
        (this.iridescenceIOR = 1.3),
        (this.iridescenceThicknessRange = [100, 400]),
        (this.iridescenceThicknessMap = null),
        (this.sheenColor = new Rr(0)),
        (this.sheenColorMap = null),
        (this.sheenRoughness = 1),
        (this.sheenRoughnessMap = null),
        (this.transmissionMap = null),
        (this.thickness = 0),
        (this.thicknessMap = null),
        (this.attenuationDistance = 1 / 0),
        (this.attenuationColor = new Rr(1, 1, 1)),
        (this.specularIntensity = 1),
        (this.specularIntensityMap = null),
        (this.specularColor = new Rr(1, 1, 1)),
        (this.specularColorMap = null),
        (this._anisotropy = 0),
        (this._clearcoat = 0),
        (this._iridescence = 0),
        (this._sheen = 0),
        (this._transmission = 0),
        this.setValues(e);
    }
    get anisotropy() {
      return this._anisotropy;
    }
    set anisotropy(e) {
      this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
    }
    get clearcoat() {
      return this._clearcoat;
    }
    set clearcoat(e) {
      this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
    }
    get iridescence() {
      return this._iridescence;
    }
    set iridescence(e) {
      this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
    }
    get sheen() {
      return this._sheen;
    }
    set sheen(e) {
      this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
    }
    get transmission() {
      return this._transmission;
    }
    set transmission(e) {
      this._transmission > 0 != e > 0 && this.version++,
        (this._transmission = e);
    }
    copy(e) {
      return (
        super.copy(e),
        (this.defines = { STANDARD: "", PHYSICAL: "" }),
        (this.anisotropy = e.anisotropy),
        (this.anisotropyRotation = e.anisotropyRotation),
        (this.anisotropyMap = e.anisotropyMap),
        (this.clearcoat = e.clearcoat),
        (this.clearcoatMap = e.clearcoatMap),
        (this.clearcoatRoughness = e.clearcoatRoughness),
        (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
        (this.clearcoatNormalMap = e.clearcoatNormalMap),
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        (this.ior = e.ior),
        (this.iridescence = e.iridescence),
        (this.iridescenceMap = e.iridescenceMap),
        (this.iridescenceIOR = e.iridescenceIOR),
        (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
        (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
        (this.sheen = e.sheen),
        this.sheenColor.copy(e.sheenColor),
        (this.sheenColorMap = e.sheenColorMap),
        (this.sheenRoughness = e.sheenRoughness),
        (this.sheenRoughnessMap = e.sheenRoughnessMap),
        (this.transmission = e.transmission),
        (this.transmissionMap = e.transmissionMap),
        (this.thickness = e.thickness),
        (this.thicknessMap = e.thicknessMap),
        (this.attenuationDistance = e.attenuationDistance),
        this.attenuationColor.copy(e.attenuationColor),
        (this.specularIntensity = e.specularIntensity),
        (this.specularIntensityMap = e.specularIntensityMap),
        this.specularColor.copy(e.specularColor),
        (this.specularColorMap = e.specularColorMap),
        this
      );
    }
  }
  function la(e, t, r) {
    return !e || (!r && e.constructor === t)
      ? e
      : "number" == typeof t.BYTES_PER_ELEMENT
      ? new t(e)
      : Array.prototype.slice.call(e);
  }
  function ca(e) {
    const t = e.length,
      r = new Array(t);
    for (let e = 0; e !== t; ++e) r[e] = e;
    return (
      r.sort(function (t, r) {
        return e[t] - e[r];
      }),
      r
    );
  }
  function ua(e, t, r) {
    const n = e.length,
      i = new e.constructor(n);
    for (let o = 0, s = 0; s !== n; ++o) {
      const n = r[o] * t;
      for (let r = 0; r !== t; ++r) i[s++] = e[n + r];
    }
    return i;
  }
  function ha(e, t, r, n) {
    let i = 1,
      o = e[0];
    for (; void 0 !== o && void 0 === o[n]; ) o = e[i++];
    if (void 0 === o) return;
    let s = o[n];
    if (void 0 !== s)
      if (Array.isArray(s))
        do {
          (s = o[n]),
            void 0 !== s && (t.push(o.time), r.push.apply(r, s)),
            (o = e[i++]);
        } while (void 0 !== o);
      else if (void 0 !== s.toArray)
        do {
          (s = o[n]),
            void 0 !== s && (t.push(o.time), s.toArray(r, r.length)),
            (o = e[i++]);
        } while (void 0 !== o);
      else
        do {
          (s = o[n]), void 0 !== s && (t.push(o.time), r.push(s)), (o = e[i++]);
        } while (void 0 !== o);
  }
  class da {
    constructor(e, t, r, n) {
      (this.parameterPositions = e),
        (this._cachedIndex = 0),
        (this.resultBuffer = void 0 !== n ? n : new t.constructor(r)),
        (this.sampleValues = t),
        (this.valueSize = r),
        (this.settings = null),
        (this.DefaultSettings_ = {});
    }
    evaluate(e) {
      const t = this.parameterPositions;
      let r = this._cachedIndex,
        n = t[r],
        i = t[r - 1];
      e: {
        t: {
          let o;
          r: {
            n: if (!(e < n)) {
              for (let o = r + 2; ; ) {
                if (void 0 === n) {
                  if (e < i) break n;
                  return (
                    (r = t.length),
                    (this._cachedIndex = r),
                    this.copySampleValue_(r - 1)
                  );
                }
                if (r === o) break;
                if (((i = n), (n = t[++r]), e < n)) break t;
              }
              o = t.length;
              break r;
            }
            if (!(e >= i)) {
              const s = t[1];
              e < s && ((r = 2), (i = s));
              for (let o = r - 2; ; ) {
                if (void 0 === i)
                  return (this._cachedIndex = 0), this.copySampleValue_(0);
                if (r === o) break;
                if (((n = i), (i = t[--r - 1]), e >= i)) break t;
              }
              (o = r), (r = 0);
              break r;
            }
            break e;
          }
          for (; r < o; ) {
            const n = (r + o) >>> 1;
            e < t[n] ? (o = n) : (r = n + 1);
          }
          if (((n = t[r]), (i = t[r - 1]), void 0 === i))
            return (this._cachedIndex = 0), this.copySampleValue_(0);
          if (void 0 === n)
            return (
              (r = t.length),
              (this._cachedIndex = r),
              this.copySampleValue_(r - 1)
            );
        }
        (this._cachedIndex = r), this.intervalChanged_(r, i, n);
      }
      return this.interpolate_(r, i, e, n);
    }
    getSettings_() {
      return this.settings || this.DefaultSettings_;
    }
    copySampleValue_(e) {
      const t = this.resultBuffer,
        r = this.sampleValues,
        n = this.valueSize,
        i = e * n;
      for (let e = 0; e !== n; ++e) t[e] = r[i + e];
      return t;
    }
    interpolate_() {
      throw new Error("call to abstract method");
    }
    intervalChanged_() {}
  }
  class pa extends da {
    constructor(e, t, r, n) {
      super(e, t, r, n),
        (this._weightPrev = -0),
        (this._offsetPrev = -0),
        (this._weightNext = -0),
        (this._offsetNext = -0),
        (this.DefaultSettings_ = { endingStart: 2400, endingEnd: 2400 });
    }
    intervalChanged_(e, t, r) {
      const n = this.parameterPositions;
      let i = e - 2,
        o = e + 1,
        s = n[i],
        a = n[o];
      if (void 0 === s)
        switch (this.getSettings_().endingStart) {
          case 2401:
            (i = e), (s = 2 * t - r);
            break;
          case 2402:
            (i = n.length - 2), (s = t + n[i] - n[i + 1]);
            break;
          default:
            (i = e), (s = r);
        }
      if (void 0 === a)
        switch (this.getSettings_().endingEnd) {
          case 2401:
            (o = e), (a = 2 * r - t);
            break;
          case 2402:
            (o = 1), (a = r + n[1] - n[0]);
            break;
          default:
            (o = e - 1), (a = t);
        }
      const l = 0.5 * (r - t),
        c = this.valueSize;
      (this._weightPrev = l / (t - s)),
        (this._weightNext = l / (a - r)),
        (this._offsetPrev = i * c),
        (this._offsetNext = o * c);
    }
    interpolate_(e, t, r, n) {
      const i = this.resultBuffer,
        o = this.sampleValues,
        s = this.valueSize,
        a = e * s,
        l = a - s,
        c = this._offsetPrev,
        u = this._offsetNext,
        h = this._weightPrev,
        d = this._weightNext,
        p = (r - t) / (n - t),
        f = p * p,
        m = f * p,
        g = -h * m + 2 * h * f - h * p,
        _ = (1 + h) * m + (-1.5 - 2 * h) * f + (-0.5 + h) * p + 1,
        v = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
        y = d * m - d * f;
      for (let e = 0; e !== s; ++e)
        i[e] = g * o[c + e] + _ * o[l + e] + v * o[a + e] + y * o[u + e];
      return i;
    }
  }
  class fa extends da {
    constructor(e, t, r, n) {
      super(e, t, r, n);
    }
    interpolate_(e, t, r, n) {
      const i = this.resultBuffer,
        o = this.sampleValues,
        s = this.valueSize,
        a = e * s,
        l = a - s,
        c = (r - t) / (n - t),
        u = 1 - c;
      for (let e = 0; e !== s; ++e) i[e] = o[l + e] * u + o[a + e] * c;
      return i;
    }
  }
  class ma extends da {
    constructor(e, t, r, n) {
      super(e, t, r, n);
    }
    interpolate_(e) {
      return this.copySampleValue_(e - 1);
    }
  }
  class ga {
    constructor(e, t, r, n) {
      if (void 0 === e)
        throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (void 0 === t || 0 === t.length)
        throw new Error(
          "THREE.KeyframeTrack: no keyframes in track named " + e
        );
      (this.name = e),
        (this.times = la(t, this.TimeBufferType)),
        (this.values = la(r, this.ValueBufferType)),
        this.setInterpolation(n || this.DefaultInterpolation);
    }
    static toJSON(e) {
      const t = e.constructor;
      let r;
      if (t.toJSON !== this.toJSON) r = t.toJSON(e);
      else {
        r = {
          name: e.name,
          times: la(e.times, Array),
          values: la(e.values, Array),
        };
        const t = e.getInterpolation();
        t !== e.DefaultInterpolation && (r.interpolation = t);
      }
      return (r.type = e.ValueTypeName), r;
    }
    InterpolantFactoryMethodDiscrete(e) {
      return new ma(this.times, this.values, this.getValueSize(), e);
    }
    InterpolantFactoryMethodLinear(e) {
      return new fa(this.times, this.values, this.getValueSize(), e);
    }
    InterpolantFactoryMethodSmooth(e) {
      return new pa(this.times, this.values, this.getValueSize(), e);
    }
    setInterpolation(e) {
      let t;
      switch (e) {
        case $:
          t = this.InterpolantFactoryMethodDiscrete;
          break;
        case Q:
          t = this.InterpolantFactoryMethodLinear;
          break;
        case J:
          t = this.InterpolantFactoryMethodSmooth;
      }
      if (void 0 === t) {
        const t =
          "unsupported interpolation for " +
          this.ValueTypeName +
          " keyframe track named " +
          this.name;
        if (void 0 === this.createInterpolant) {
          if (e === this.DefaultInterpolation) throw new Error(t);
          this.setInterpolation(this.DefaultInterpolation);
        }
        return console.warn("THREE.KeyframeTrack:", t), this;
      }
      return (this.createInterpolant = t), this;
    }
    getInterpolation() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return $;
        case this.InterpolantFactoryMethodLinear:
          return Q;
        case this.InterpolantFactoryMethodSmooth:
          return J;
      }
    }
    getValueSize() {
      return this.values.length / this.times.length;
    }
    shift(e) {
      if (0 !== e) {
        const t = this.times;
        for (let r = 0, n = t.length; r !== n; ++r) t[r] += e;
      }
      return this;
    }
    scale(e) {
      if (1 !== e) {
        const t = this.times;
        for (let r = 0, n = t.length; r !== n; ++r) t[r] *= e;
      }
      return this;
    }
    trim(e, t) {
      const r = this.times,
        n = r.length;
      let i = 0,
        o = n - 1;
      for (; i !== n && r[i] < e; ) ++i;
      for (; -1 !== o && r[o] > t; ) --o;
      if ((++o, 0 !== i || o !== n)) {
        i >= o && ((o = Math.max(o, 1)), (i = o - 1));
        const e = this.getValueSize();
        (this.times = r.slice(i, o)),
          (this.values = this.values.slice(i * e, o * e));
      }
      return this;
    }
    validate() {
      let e = !0;
      const t = this.getValueSize();
      t - Math.floor(t) !== 0 &&
        (console.error(
          "THREE.KeyframeTrack: Invalid value size in track.",
          this
        ),
        (e = !1));
      const r = this.times,
        n = this.values,
        i = r.length;
      0 === i &&
        (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
      let o = null;
      for (let t = 0; t !== i; t++) {
        const n = r[t];
        if ("number" == typeof n && isNaN(n)) {
          console.error(
            "THREE.KeyframeTrack: Time is not a valid number.",
            this,
            t,
            n
          ),
            (e = !1);
          break;
        }
        if (null !== o && o > n) {
          console.error(
            "THREE.KeyframeTrack: Out of order keys.",
            this,
            t,
            n,
            o
          ),
            (e = !1);
          break;
        }
        o = n;
      }
      if (
        void 0 !== n &&
        ((s = n), ArrayBuffer.isView(s) && !(s instanceof DataView))
      )
        for (let t = 0, r = n.length; t !== r; ++t) {
          const r = n[t];
          if (isNaN(r)) {
            console.error(
              "THREE.KeyframeTrack: Value is not a valid number.",
              this,
              t,
              r
            ),
              (e = !1);
            break;
          }
        }
      var s;
      return e;
    }
    optimize() {
      const e = this.times.slice(),
        t = this.values.slice(),
        r = this.getValueSize(),
        n = this.getInterpolation() === J,
        i = e.length - 1;
      let o = 1;
      for (let s = 1; s < i; ++s) {
        let i = !1;
        const a = e[s];
        if (a !== e[s + 1] && (1 !== s || a !== e[0]))
          if (n) i = !0;
          else {
            const e = s * r,
              n = e - r,
              o = e + r;
            for (let s = 0; s !== r; ++s) {
              const r = t[e + s];
              if (r !== t[n + s] || r !== t[o + s]) {
                i = !0;
                break;
              }
            }
          }
        if (i) {
          if (s !== o) {
            e[o] = e[s];
            const n = s * r,
              i = o * r;
            for (let e = 0; e !== r; ++e) t[i + e] = t[n + e];
          }
          ++o;
        }
      }
      if (i > 0) {
        e[o] = e[i];
        for (let e = i * r, n = o * r, s = 0; s !== r; ++s) t[n + s] = t[e + s];
        ++o;
      }
      return (
        o !== e.length
          ? ((this.times = e.slice(0, o)), (this.values = t.slice(0, o * r)))
          : ((this.times = e), (this.values = t)),
        this
      );
    }
    clone() {
      const e = this.times.slice(),
        t = this.values.slice(),
        r = new (0, this.constructor)(this.name, e, t);
      return (r.createInterpolant = this.createInterpolant), r;
    }
  }
  (ga.prototype.TimeBufferType = Float32Array),
    (ga.prototype.ValueBufferType = Float32Array),
    (ga.prototype.DefaultInterpolation = Q);
  class _a extends ga {}
  (_a.prototype.ValueTypeName = "bool"),
    (_a.prototype.ValueBufferType = Array),
    (_a.prototype.DefaultInterpolation = $),
    (_a.prototype.InterpolantFactoryMethodLinear = void 0),
    (_a.prototype.InterpolantFactoryMethodSmooth = void 0);
  class va extends ga {}
  va.prototype.ValueTypeName = "color";
  class ya extends ga {}
  ya.prototype.ValueTypeName = "number";
  class ba extends da {
    constructor(e, t, r, n) {
      super(e, t, r, n);
    }
    interpolate_(e, t, r, n) {
      const i = this.resultBuffer,
        o = this.sampleValues,
        s = this.valueSize,
        a = (r - t) / (n - t);
      let l = e * s;
      for (let e = l + s; l !== e; l += 4)
        ct.slerpFlat(i, 0, o, l - s, o, l, a);
      return i;
    }
  }
  class xa extends ga {
    InterpolantFactoryMethodLinear(e) {
      return new ba(this.times, this.values, this.getValueSize(), e);
    }
  }
  (xa.prototype.ValueTypeName = "quaternion"),
    (xa.prototype.DefaultInterpolation = Q),
    (xa.prototype.InterpolantFactoryMethodSmooth = void 0);
  class wa extends ga {}
  (wa.prototype.ValueTypeName = "string"),
    (wa.prototype.ValueBufferType = Array),
    (wa.prototype.DefaultInterpolation = $),
    (wa.prototype.InterpolantFactoryMethodLinear = void 0),
    (wa.prototype.InterpolantFactoryMethodSmooth = void 0);
  class Sa extends ga {}
  Sa.prototype.ValueTypeName = "vector";
  class Ea {
    constructor(e, t = -1, r, n = 2500) {
      (this.name = e),
        (this.tracks = r),
        (this.duration = t),
        (this.blendMode = n),
        (this.uuid = Ae()),
        this.duration < 0 && this.resetDuration();
    }
    static parse(e) {
      const t = [],
        r = e.tracks,
        n = 1 / (e.fps || 1);
      for (let e = 0, i = r.length; e !== i; ++e) t.push(Ma(r[e]).scale(n));
      const i = new this(e.name, e.duration, t, e.blendMode);
      return (i.uuid = e.uuid), i;
    }
    static toJSON(e) {
      const t = [],
        r = e.tracks,
        n = {
          name: e.name,
          duration: e.duration,
          tracks: t,
          uuid: e.uuid,
          blendMode: e.blendMode,
        };
      for (let e = 0, n = r.length; e !== n; ++e) t.push(ga.toJSON(r[e]));
      return n;
    }
    static CreateFromMorphTargetSequence(e, t, r, n) {
      const i = t.length,
        o = [];
      for (let e = 0; e < i; e++) {
        let s = [],
          a = [];
        s.push((e + i - 1) % i, e, (e + 1) % i), a.push(0, 1, 0);
        const l = ca(s);
        (s = ua(s, 1, l)),
          (a = ua(a, 1, l)),
          n || 0 !== s[0] || (s.push(i), a.push(a[0])),
          o.push(
            new ya(".morphTargetInfluences[" + t[e].name + "]", s, a).scale(
              1 / r
            )
          );
      }
      return new this(e, -1, o);
    }
    static findByName(e, t) {
      let r = e;
      if (!Array.isArray(e)) {
        const t = e;
        r = (t.geometry && t.geometry.animations) || t.animations;
      }
      for (let e = 0; e < r.length; e++) if (r[e].name === t) return r[e];
      return null;
    }
    static CreateClipsFromMorphTargetSequences(e, t, r) {
      const n = {},
        i = /^([\w-]*?)([\d]+)$/;
      for (let t = 0, r = e.length; t < r; t++) {
        const r = e[t],
          o = r.name.match(i);
        if (o && o.length > 1) {
          const e = o[1];
          let t = n[e];
          t || (n[e] = t = []), t.push(r);
        }
      }
      const o = [];
      for (const e in n)
        o.push(this.CreateFromMorphTargetSequence(e, n[e], t, r));
      return o;
    }
    static parseAnimation(e, t) {
      if (!e)
        return (
          console.error(
            "THREE.AnimationClip: No animation in JSONLoader data."
          ),
          null
        );
      const r = function (e, t, r, n, i) {
          if (0 !== r.length) {
            const o = [],
              s = [];
            ha(r, o, s, n), 0 !== o.length && i.push(new e(t, o, s));
          }
        },
        n = [],
        i = e.name || "default",
        o = e.fps || 30,
        s = e.blendMode;
      let a = e.length || -1;
      const l = e.hierarchy || [];
      for (let e = 0; e < l.length; e++) {
        const i = l[e].keys;
        if (i && 0 !== i.length)
          if (i[0].morphTargets) {
            const e = {};
            let t;
            for (t = 0; t < i.length; t++)
              if (i[t].morphTargets)
                for (let r = 0; r < i[t].morphTargets.length; r++)
                  e[i[t].morphTargets[r]] = -1;
            for (const r in e) {
              const e = [],
                o = [];
              for (let n = 0; n !== i[t].morphTargets.length; ++n) {
                const n = i[t];
                e.push(n.time), o.push(n.morphTarget === r ? 1 : 0);
              }
              n.push(new ya(".morphTargetInfluence[" + r + "]", e, o));
            }
            a = e.length * o;
          } else {
            const o = ".bones[" + t[e].name + "]";
            r(Sa, o + ".position", i, "pos", n),
              r(xa, o + ".quaternion", i, "rot", n),
              r(Sa, o + ".scale", i, "scl", n);
          }
      }
      return 0 === n.length ? null : new this(i, a, n, s);
    }
    resetDuration() {
      let e = 0;
      for (let t = 0, r = this.tracks.length; t !== r; ++t) {
        const r = this.tracks[t];
        e = Math.max(e, r.times[r.times.length - 1]);
      }
      return (this.duration = e), this;
    }
    trim() {
      for (let e = 0; e < this.tracks.length; e++)
        this.tracks[e].trim(0, this.duration);
      return this;
    }
    validate() {
      let e = !0;
      for (let t = 0; t < this.tracks.length; t++)
        e = e && this.tracks[t].validate();
      return e;
    }
    optimize() {
      for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
      return this;
    }
    clone() {
      const e = [];
      for (let t = 0; t < this.tracks.length; t++)
        e.push(this.tracks[t].clone());
      return new this.constructor(this.name, this.duration, e, this.blendMode);
    }
    toJSON() {
      return this.constructor.toJSON(this);
    }
  }
  function Ma(e) {
    if (void 0 === e.type)
      throw new Error(
        "THREE.KeyframeTrack: track type undefined, can not parse"
      );
    const t = (function (e) {
      switch (e.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
          return ya;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
          return Sa;
        case "color":
          return va;
        case "quaternion":
          return xa;
        case "bool":
        case "boolean":
          return _a;
        case "string":
          return wa;
      }
      throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
    })(e.type);
    if (void 0 === e.times) {
      const t = [],
        r = [];
      ha(e.keys, t, r, "value"), (e.times = t), (e.values = r);
    }
    return void 0 !== t.parse
      ? t.parse(e)
      : new t(e.name, e.times, e.values, e.interpolation);
  }
  const Ta = {
    enabled: !1,
    files: {},
    add: function (e, t) {
      !1 !== this.enabled && (this.files[e] = t);
    },
    get: function (e) {
      if (!1 !== this.enabled) return this.files[e];
    },
    remove: function (e) {
      delete this.files[e];
    },
    clear: function () {
      this.files = {};
    },
  };
  class Aa {
    constructor(e, t, r) {
      const n = this;
      let i,
        o = !1,
        s = 0,
        a = 0;
      const l = [];
      (this.onStart = void 0),
        (this.onLoad = e),
        (this.onProgress = t),
        (this.onError = r),
        (this.itemStart = function (e) {
          a++, !1 === o && void 0 !== n.onStart && n.onStart(e, s, a), (o = !0);
        }),
        (this.itemEnd = function (e) {
          s++,
            void 0 !== n.onProgress && n.onProgress(e, s, a),
            s === a && ((o = !1), void 0 !== n.onLoad && n.onLoad());
        }),
        (this.itemError = function (e) {
          void 0 !== n.onError && n.onError(e);
        }),
        (this.resolveURL = function (e) {
          return i ? i(e) : e;
        }),
        (this.setURLModifier = function (e) {
          return (i = e), this;
        }),
        (this.addHandler = function (e, t) {
          return l.push(e, t), this;
        }),
        (this.removeHandler = function (e) {
          const t = l.indexOf(e);
          return -1 !== t && l.splice(t, 2), this;
        }),
        (this.getHandler = function (e) {
          for (let t = 0, r = l.length; t < r; t += 2) {
            const r = l[t],
              n = l[t + 1];
            if ((r.global && (r.lastIndex = 0), r.test(e))) return n;
          }
          return null;
        });
    }
  }
  const Ra = new Aa();
  class Pa {
    constructor(e) {
      (this.manager = void 0 !== e ? e : Ra),
        (this.crossOrigin = "anonymous"),
        (this.withCredentials = !1),
        (this.path = ""),
        (this.resourcePath = ""),
        (this.requestHeader = {});
    }
    load() {}
    loadAsync(e, t) {
      const r = this;
      return new Promise(function (n, i) {
        r.load(e, n, t, i);
      });
    }
    parse() {}
    setCrossOrigin(e) {
      return (this.crossOrigin = e), this;
    }
    setWithCredentials(e) {
      return (this.withCredentials = e), this;
    }
    setPath(e) {
      return (this.path = e), this;
    }
    setResourcePath(e) {
      return (this.resourcePath = e), this;
    }
    setRequestHeader(e) {
      return (this.requestHeader = e), this;
    }
  }
  Pa.DEFAULT_MATERIAL_NAME = "__DEFAULT";
  const Ca = {};
  class Ia extends Error {
    constructor(e, t) {
      super(e), (this.response = t);
    }
  }
  class La extends Pa {
    constructor(e) {
      super(e);
    }
    load(e, t, r, n) {
      void 0 === e && (e = ""),
        void 0 !== this.path && (e = this.path + e),
        (e = this.manager.resolveURL(e));
      const i = Ta.get(e);
      if (void 0 !== i)
        return (
          this.manager.itemStart(e),
          setTimeout(() => {
            t && t(i), this.manager.itemEnd(e);
          }, 0),
          i
        );
      if (void 0 !== Ca[e])
        return void Ca[e].push({ onLoad: t, onProgress: r, onError: n });
      (Ca[e] = []), Ca[e].push({ onLoad: t, onProgress: r, onError: n });
      const o = new Request(e, {
          headers: new Headers(this.requestHeader),
          credentials: this.withCredentials ? "include" : "same-origin",
        }),
        s = this.mimeType,
        a = this.responseType;
      fetch(o)
        .then((t) => {
          if (200 === t.status || 0 === t.status) {
            if (
              (0 === t.status &&
                console.warn("THREE.FileLoader: HTTP Status 0 received."),
              "undefined" == typeof ReadableStream ||
                void 0 === t.body ||
                void 0 === t.body.getReader)
            )
              return t;
            const r = Ca[e],
              n = t.body.getReader(),
              i =
                t.headers.get("Content-Length") || t.headers.get("X-File-Size"),
              o = i ? parseInt(i) : 0,
              s = 0 !== o;
            let a = 0;
            const l = new ReadableStream({
              start(e) {
                !(function t() {
                  n.read().then(({ done: n, value: i }) => {
                    if (n) e.close();
                    else {
                      a += i.byteLength;
                      const n = new ProgressEvent("progress", {
                        lengthComputable: s,
                        loaded: a,
                        total: o,
                      });
                      for (let e = 0, t = r.length; e < t; e++) {
                        const t = r[e];
                        t.onProgress && t.onProgress(n);
                      }
                      e.enqueue(i), t();
                    }
                  });
                })();
              },
            });
            return new Response(l);
          }
          throw new Ia(
            `fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`,
            t
          );
        })
        .then((e) => {
          switch (a) {
            case "arraybuffer":
              return e.arrayBuffer();
            case "blob":
              return e.blob();
            case "document":
              return e
                .text()
                .then((e) => new DOMParser().parseFromString(e, s));
            case "json":
              return e.json();
            default:
              if (void 0 === s) return e.text();
              {
                const t = /charset="?([^;"\s]*)"?/i.exec(s),
                  r = t && t[1] ? t[1].toLowerCase() : void 0,
                  n = new TextDecoder(r);
                return e.arrayBuffer().then((e) => n.decode(e));
              }
          }
        })
        .then((t) => {
          Ta.add(e, t);
          const r = Ca[e];
          delete Ca[e];
          for (let e = 0, n = r.length; e < n; e++) {
            const n = r[e];
            n.onLoad && n.onLoad(t);
          }
        })
        .catch((t) => {
          const r = Ca[e];
          if (void 0 === r) throw (this.manager.itemError(e), t);
          delete Ca[e];
          for (let e = 0, n = r.length; e < n; e++) {
            const n = r[e];
            n.onError && n.onError(t);
          }
          this.manager.itemError(e);
        })
        .finally(() => {
          this.manager.itemEnd(e);
        }),
        this.manager.itemStart(e);
    }
    setResponseType(e) {
      return (this.responseType = e), this;
    }
    setMimeType(e) {
      return (this.mimeType = e), this;
    }
  }
  class Oa extends Pa {
    constructor(e) {
      super(e);
    }
    load(e, t, r, n) {
      void 0 !== this.path && (e = this.path + e),
        (e = this.manager.resolveURL(e));
      const i = this,
        o = Ta.get(e);
      if (void 0 !== o)
        return (
          i.manager.itemStart(e),
          setTimeout(function () {
            t && t(o), i.manager.itemEnd(e);
          }, 0),
          o
        );
      const s = He("img");
      function a() {
        c(), Ta.add(e, this), t && t(this), i.manager.itemEnd(e);
      }
      function l(t) {
        c(), n && n(t), i.manager.itemError(e), i.manager.itemEnd(e);
      }
      function c() {
        s.removeEventListener("load", a, !1),
          s.removeEventListener("error", l, !1);
      }
      return (
        s.addEventListener("load", a, !1),
        s.addEventListener("error", l, !1),
        "data:" !== e.slice(0, 5) &&
          void 0 !== this.crossOrigin &&
          (s.crossOrigin = this.crossOrigin),
        i.manager.itemStart(e),
        (s.src = e),
        s
      );
    }
  }
  class Na extends Pa {
    constructor(e) {
      super(e);
    }
    load(e, t, r, n) {
      const i = new nt(),
        o = new Oa(this.manager);
      return (
        o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path),
        o.load(
          e,
          function (e) {
            (i.image = e), (i.needsUpdate = !0), void 0 !== t && t(i);
          },
          r,
          n
        ),
        i
      );
    }
  }
  class Ua extends hr {
    constructor(e, t = 1) {
      super(),
        (this.isLight = !0),
        (this.type = "Light"),
        (this.color = new Rr(e)),
        (this.intensity = t);
    }
    dispose() {}
    copy(e, t) {
      return (
        super.copy(e, t),
        this.color.copy(e.color),
        (this.intensity = e.intensity),
        this
      );
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return (
        (t.object.color = this.color.getHex()),
        (t.object.intensity = this.intensity),
        void 0 !== this.groundColor &&
          (t.object.groundColor = this.groundColor.getHex()),
        void 0 !== this.distance && (t.object.distance = this.distance),
        void 0 !== this.angle && (t.object.angle = this.angle),
        void 0 !== this.decay && (t.object.decay = this.decay),
        void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
        void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
        t
      );
    }
  }
  const Da = new Ht(),
    ka = new ut(),
    Ba = new ut();
  class Fa {
    constructor(e) {
      (this.camera = e),
        (this.bias = 0),
        (this.normalBias = 0),
        (this.radius = 1),
        (this.blurSamples = 8),
        (this.mapSize = new De(512, 512)),
        (this.map = null),
        (this.mapPass = null),
        (this.matrix = new Ht()),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this._frustum = new In()),
        (this._frameExtents = new De(1, 1)),
        (this._viewportCount = 1),
        (this._viewports = [new it(0, 0, 1, 1)]);
    }
    getViewportCount() {
      return this._viewportCount;
    }
    getFrustum() {
      return this._frustum;
    }
    updateMatrices(e) {
      const t = this.camera,
        r = this.matrix;
      ka.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(ka),
        Ba.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(Ba),
        t.updateMatrixWorld(),
        Da.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Da),
        r.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
        r.multiply(Da);
    }
    getViewport(e) {
      return this._viewports[e];
    }
    getFrameExtents() {
      return this._frameExtents;
    }
    dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
    }
    copy(e) {
      return (
        (this.camera = e.camera.clone()),
        (this.bias = e.bias),
        (this.radius = e.radius),
        this.mapSize.copy(e.mapSize),
        this
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
    toJSON() {
      const e = {};
      return (
        0 !== this.bias && (e.bias = this.bias),
        0 !== this.normalBias && (e.normalBias = this.normalBias),
        1 !== this.radius && (e.radius = this.radius),
        (512 === this.mapSize.x && 512 === this.mapSize.y) ||
          (e.mapSize = this.mapSize.toArray()),
        (e.camera = this.camera.toJSON(!1).object),
        delete e.camera.matrix,
        e
      );
    }
  }
  class Ha extends Fa {
    constructor() {
      super(new bn(50, 1, 0.5, 500)),
        (this.isSpotLightShadow = !0),
        (this.focus = 1);
    }
    updateMatrices(e) {
      const t = this.camera,
        r = 2 * Te * e.angle * this.focus,
        n = this.mapSize.width / this.mapSize.height,
        i = e.distance || t.far;
      (r === t.fov && n === t.aspect && i === t.far) ||
        ((t.fov = r), (t.aspect = n), (t.far = i), t.updateProjectionMatrix()),
        super.updateMatrices(e);
    }
    copy(e) {
      return super.copy(e), (this.focus = e.focus), this;
    }
  }
  class za extends Ua {
    constructor(e, t, r = 0, n = Math.PI / 3, i = 0, o = 2) {
      super(e, t),
        (this.isSpotLight = !0),
        (this.type = "SpotLight"),
        this.position.copy(hr.DEFAULT_UP),
        this.updateMatrix(),
        (this.target = new hr()),
        (this.distance = r),
        (this.angle = n),
        (this.penumbra = i),
        (this.decay = o),
        (this.map = null),
        (this.shadow = new Ha());
    }
    get power() {
      return this.intensity * Math.PI;
    }
    set power(e) {
      this.intensity = e / Math.PI;
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        (this.distance = e.distance),
        (this.angle = e.angle),
        (this.penumbra = e.penumbra),
        (this.decay = e.decay),
        (this.target = e.target.clone()),
        (this.shadow = e.shadow.clone()),
        this
      );
    }
  }
  const Va = new Ht(),
    ja = new ut(),
    Wa = new ut();
  class Ga extends Fa {
    constructor() {
      super(new bn(90, 1, 0.5, 500)),
        (this.isPointLightShadow = !0),
        (this._frameExtents = new De(4, 2)),
        (this._viewportCount = 6),
        (this._viewports = [
          new it(2, 1, 1, 1),
          new it(0, 1, 1, 1),
          new it(3, 1, 1, 1),
          new it(1, 1, 1, 1),
          new it(3, 0, 1, 1),
          new it(1, 0, 1, 1),
        ]),
        (this._cubeDirections = [
          new ut(1, 0, 0),
          new ut(-1, 0, 0),
          new ut(0, 0, 1),
          new ut(0, 0, -1),
          new ut(0, 1, 0),
          new ut(0, -1, 0),
        ]),
        (this._cubeUps = [
          new ut(0, 1, 0),
          new ut(0, 1, 0),
          new ut(0, 1, 0),
          new ut(0, 1, 0),
          new ut(0, 0, 1),
          new ut(0, 0, -1),
        ]);
    }
    updateMatrices(e, t = 0) {
      const r = this.camera,
        n = this.matrix,
        i = e.distance || r.far;
      i !== r.far && ((r.far = i), r.updateProjectionMatrix()),
        ja.setFromMatrixPosition(e.matrixWorld),
        r.position.copy(ja),
        Wa.copy(r.position),
        Wa.add(this._cubeDirections[t]),
        r.up.copy(this._cubeUps[t]),
        r.lookAt(Wa),
        r.updateMatrixWorld(),
        n.makeTranslation(-ja.x, -ja.y, -ja.z),
        Va.multiplyMatrices(r.projectionMatrix, r.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(Va);
    }
  }
  class Xa extends Ua {
    constructor(e, t, r = 0, n = 2) {
      super(e, t),
        (this.isPointLight = !0),
        (this.type = "PointLight"),
        (this.distance = r),
        (this.decay = n),
        (this.shadow = new Ga());
    }
    get power() {
      return 4 * this.intensity * Math.PI;
    }
    set power(e) {
      this.intensity = e / (4 * Math.PI);
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        (this.distance = e.distance),
        (this.decay = e.decay),
        (this.shadow = e.shadow.clone()),
        this
      );
    }
  }
  class qa extends Fa {
    constructor() {
      super(new Gn(-5, 5, 5, -5, 0.5, 500)),
        (this.isDirectionalLightShadow = !0);
    }
  }
  class Ya extends Ua {
    constructor(e, t) {
      super(e, t),
        (this.isDirectionalLight = !0),
        (this.type = "DirectionalLight"),
        this.position.copy(hr.DEFAULT_UP),
        this.updateMatrix(),
        (this.target = new hr()),
        (this.shadow = new qa());
    }
    dispose() {
      this.shadow.dispose();
    }
    copy(e) {
      return (
        super.copy(e),
        (this.target = e.target.clone()),
        (this.shadow = e.shadow.clone()),
        this
      );
    }
  }
  class Ka {
    static decodeText(e) {
      if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(e);
      let t = "";
      for (let r = 0, n = e.length; r < n; r++) t += String.fromCharCode(e[r]);
      try {
        return decodeURIComponent(escape(t));
      } catch (e) {
        return t;
      }
    }
    static extractUrlBase(e) {
      const t = e.lastIndexOf("/");
      return -1 === t ? "./" : e.slice(0, t + 1);
    }
    static resolveURL(e, t) {
      return "string" != typeof e || "" === e
        ? ""
        : (/^https?:\/\//i.test(t) &&
            /^\//.test(e) &&
            (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
          /^(https?:)?\/\//i.test(e) ||
          /^data:.*,.*$/i.test(e) ||
          /^blob:.*$/i.test(e)
            ? e
            : t + e);
    }
  }
  class $a extends Pa {
    constructor(e) {
      super(e),
        (this.isImageBitmapLoader = !0),
        "undefined" == typeof createImageBitmap &&
          console.warn(
            "THREE.ImageBitmapLoader: createImageBitmap() not supported."
          ),
        "undefined" == typeof fetch &&
          console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        (this.options = { premultiplyAlpha: "none" });
    }
    setOptions(e) {
      return (this.options = e), this;
    }
    load(e, t, r, n) {
      void 0 === e && (e = ""),
        void 0 !== this.path && (e = this.path + e),
        (e = this.manager.resolveURL(e));
      const i = this,
        o = Ta.get(e);
      if (void 0 !== o)
        return (
          i.manager.itemStart(e),
          o.then
            ? void o
                .then((r) => {
                  t && t(r), i.manager.itemEnd(e);
                })
                .catch((e) => {
                  n && n(e);
                })
            : (setTimeout(function () {
                t && t(o), i.manager.itemEnd(e);
              }, 0),
              o)
        );
      const s = {};
      (s.credentials =
        "anonymous" === this.crossOrigin ? "same-origin" : "include"),
        (s.headers = this.requestHeader);
      const a = fetch(e, s)
        .then(function (e) {
          return e.blob();
        })
        .then(function (e) {
          return createImageBitmap(
            e,
            Object.assign(i.options, { colorSpaceConversion: "none" })
          );
        })
        .then(function (r) {
          return Ta.add(e, r), t && t(r), i.manager.itemEnd(e), r;
        })
        .catch(function (t) {
          n && n(t), Ta.remove(e), i.manager.itemError(e), i.manager.itemEnd(e);
        });
      Ta.add(e, a), i.manager.itemStart(e);
    }
  }
  const Qa = "\\[\\]\\.:\\/",
    Ja = new RegExp("[" + Qa + "]", "g"),
    Za = "[^" + Qa + "]",
    el = "[^" + Qa.replace("\\.", "") + "]",
    tl = new RegExp(
      "^" +
        /((?:WC+[\/:])*)/.source.replace("WC", Za) +
        /(WCOD+)?/.source.replace("WCOD", el) +
        /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Za) +
        /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Za) +
        "$"
    ),
    rl = ["material", "materials", "bones", "map"];
  class nl {
    constructor(e, t, r) {
      (this.path = t),
        (this.parsedPath = r || nl.parseTrackName(t)),
        (this.node = nl.findNode(e, this.parsedPath.nodeName)),
        (this.rootNode = e),
        (this.getValue = this._getValue_unbound),
        (this.setValue = this._setValue_unbound);
    }
    static create(e, t, r) {
      return e && e.isAnimationObjectGroup
        ? new nl.Composite(e, t, r)
        : new nl(e, t, r);
    }
    static sanitizeNodeName(e) {
      return e.replace(/\s/g, "_").replace(Ja, "");
    }
    static parseTrackName(e) {
      const t = tl.exec(e);
      if (null === t)
        throw new Error("PropertyBinding: Cannot parse trackName: " + e);
      const r = {
          nodeName: t[2],
          objectName: t[3],
          objectIndex: t[4],
          propertyName: t[5],
          propertyIndex: t[6],
        },
        n = r.nodeName && r.nodeName.lastIndexOf(".");
      if (void 0 !== n && -1 !== n) {
        const e = r.nodeName.substring(n + 1);
        -1 !== rl.indexOf(e) &&
          ((r.nodeName = r.nodeName.substring(0, n)), (r.objectName = e));
      }
      if (null === r.propertyName || 0 === r.propertyName.length)
        throw new Error(
          "PropertyBinding: can not parse propertyName from trackName: " + e
        );
      return r;
    }
    static findNode(e, t) {
      if (
        void 0 === t ||
        "" === t ||
        "." === t ||
        -1 === t ||
        t === e.name ||
        t === e.uuid
      )
        return e;
      if (e.skeleton) {
        const r = e.skeleton.getBoneByName(t);
        if (void 0 !== r) return r;
      }
      if (e.children) {
        const r = function (e) {
            for (let n = 0; n < e.length; n++) {
              const i = e[n];
              if (i.name === t || i.uuid === t) return i;
              const o = r(i.children);
              if (o) return o;
            }
            return null;
          },
          n = r(e.children);
        if (n) return n;
      }
      return null;
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
      e[t] = this.targetObject[this.propertyName];
    }
    _getValue_array(e, t) {
      const r = this.resolvedProperty;
      for (let n = 0, i = r.length; n !== i; ++n) e[t++] = r[n];
    }
    _getValue_arrayElement(e, t) {
      e[t] = this.resolvedProperty[this.propertyIndex];
    }
    _getValue_toArray(e, t) {
      this.resolvedProperty.toArray(e, t);
    }
    _setValue_direct(e, t) {
      this.targetObject[this.propertyName] = e[t];
    }
    _setValue_direct_setNeedsUpdate(e, t) {
      (this.targetObject[this.propertyName] = e[t]),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
      (this.targetObject[this.propertyName] = e[t]),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _setValue_array(e, t) {
      const r = this.resolvedProperty;
      for (let n = 0, i = r.length; n !== i; ++n) r[n] = e[t++];
    }
    _setValue_array_setNeedsUpdate(e, t) {
      const r = this.resolvedProperty;
      for (let n = 0, i = r.length; n !== i; ++n) r[n] = e[t++];
      this.targetObject.needsUpdate = !0;
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
      const r = this.resolvedProperty;
      for (let n = 0, i = r.length; n !== i; ++n) r[n] = e[t++];
      this.targetObject.matrixWorldNeedsUpdate = !0;
    }
    _setValue_arrayElement(e, t) {
      this.resolvedProperty[this.propertyIndex] = e[t];
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
      (this.resolvedProperty[this.propertyIndex] = e[t]),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
      (this.resolvedProperty[this.propertyIndex] = e[t]),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _setValue_fromArray(e, t) {
      this.resolvedProperty.fromArray(e, t);
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
      this.resolvedProperty.fromArray(e, t),
        (this.targetObject.needsUpdate = !0);
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
      this.resolvedProperty.fromArray(e, t),
        (this.targetObject.matrixWorldNeedsUpdate = !0);
    }
    _getValue_unbound(e, t) {
      this.bind(), this.getValue(e, t);
    }
    _setValue_unbound(e, t) {
      this.bind(), this.setValue(e, t);
    }
    bind() {
      let e = this.node;
      const t = this.parsedPath,
        r = t.objectName,
        n = t.propertyName;
      let i = t.propertyIndex;
      if (
        (e || ((e = nl.findNode(this.rootNode, t.nodeName)), (this.node = e)),
        (this.getValue = this._getValue_unavailable),
        (this.setValue = this._setValue_unavailable),
        !e)
      )
        return void console.warn(
          "THREE.PropertyBinding: No target node found for track: " +
            this.path +
            "."
        );
      if (r) {
        let n = t.objectIndex;
        switch (r) {
          case "materials":
            if (!e.material)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                this
              );
            if (!e.material.materials)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                this
              );
            e = e.material.materials;
            break;
          case "bones":
            if (!e.skeleton)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                this
              );
            e = e.skeleton.bones;
            for (let t = 0; t < e.length; t++)
              if (e[t].name === n) {
                n = t;
                break;
              }
            break;
          case "map":
            if ("map" in e) {
              e = e.map;
              break;
            }
            if (!e.material)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                this
              );
            if (!e.material.map)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
                this
              );
            e = e.material.map;
            break;
          default:
            if (void 0 === e[r])
              return void console.error(
                "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                this
              );
            e = e[r];
        }
        if (void 0 !== n) {
          if (void 0 === e[n])
            return void console.error(
              "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
              this,
              e
            );
          e = e[n];
        }
      }
      const o = e[n];
      if (void 0 === o) {
        const r = t.nodeName;
        return void console.error(
          "THREE.PropertyBinding: Trying to update property for track: " +
            r +
            "." +
            n +
            " but it wasn't found.",
          e
        );
      }
      let s = this.Versioning.None;
      (this.targetObject = e),
        void 0 !== e.needsUpdate
          ? (s = this.Versioning.NeedsUpdate)
          : void 0 !== e.matrixWorldNeedsUpdate &&
            (s = this.Versioning.MatrixWorldNeedsUpdate);
      let a = this.BindingType.Direct;
      if (void 0 !== i) {
        if ("morphTargetInfluences" === n) {
          if (!e.geometry)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
              this
            );
          if (!e.geometry.morphAttributes)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
              this
            );
          void 0 !== e.morphTargetDictionary[i] &&
            (i = e.morphTargetDictionary[i]);
        }
        (a = this.BindingType.ArrayElement),
          (this.resolvedProperty = o),
          (this.propertyIndex = i);
      } else
        void 0 !== o.fromArray && void 0 !== o.toArray
          ? ((a = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
          : Array.isArray(o)
          ? ((a = this.BindingType.EntireArray), (this.resolvedProperty = o))
          : (this.propertyName = n);
      (this.getValue = this.GetterByBindingType[a]),
        (this.setValue = this.SetterByBindingTypeAndVersioning[a][s]);
    }
    unbind() {
      (this.node = null),
        (this.getValue = this._getValue_unbound),
        (this.setValue = this._setValue_unbound);
    }
  }
  (nl.Composite = class {
    constructor(e, t, r) {
      const n = r || nl.parseTrackName(t);
      (this._targetGroup = e), (this._bindings = e.subscribe_(t, n));
    }
    getValue(e, t) {
      this.bind();
      const r = this._targetGroup.nCachedObjects_,
        n = this._bindings[r];
      void 0 !== n && n.getValue(e, t);
    }
    setValue(e, t) {
      const r = this._bindings;
      for (
        let n = this._targetGroup.nCachedObjects_, i = r.length;
        n !== i;
        ++n
      )
        r[n].setValue(e, t);
    }
    bind() {
      const e = this._bindings;
      for (
        let t = this._targetGroup.nCachedObjects_, r = e.length;
        t !== r;
        ++t
      )
        e[t].bind();
    }
    unbind() {
      const e = this._bindings;
      for (
        let t = this._targetGroup.nCachedObjects_, r = e.length;
        t !== r;
        ++t
      )
        e[t].unbind();
    }
  }),
    (nl.prototype.BindingType = {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3,
    }),
    (nl.prototype.Versioning = {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2,
    }),
    (nl.prototype.GetterByBindingType = [
      nl.prototype._getValue_direct,
      nl.prototype._getValue_array,
      nl.prototype._getValue_arrayElement,
      nl.prototype._getValue_toArray,
    ]),
    (nl.prototype.SetterByBindingTypeAndVersioning = [
      [
        nl.prototype._setValue_direct,
        nl.prototype._setValue_direct_setNeedsUpdate,
        nl.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
      ],
      [
        nl.prototype._setValue_array,
        nl.prototype._setValue_array_setNeedsUpdate,
        nl.prototype._setValue_array_setMatrixWorldNeedsUpdate,
      ],
      [
        nl.prototype._setValue_arrayElement,
        nl.prototype._setValue_arrayElement_setNeedsUpdate,
        nl.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
      ],
      [
        nl.prototype._setValue_fromArray,
        nl.prototype._setValue_fromArray_setNeedsUpdate,
        nl.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
      ],
    ]),
    new Float32Array(1),
    "undefined" != typeof __THREE_DEVTOOLS__ &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("register", { detail: { revision: t } })
      ),
    "undefined" != typeof window &&
      (window.__THREE__
        ? console.warn(
            "WARNING: Multiple instances of Three.js being imported."
          )
        : (window.__THREE__ = t));
  class il {
    static createButton(e, t = {}) {
      const r = document.createElement("button");
      function n(n) {
        let i = null;
        async function o(t) {
          t.addEventListener("end", s),
            await e.xr.setSession(t),
            (r.textContent = "STOP XR"),
            (i = t);
        }
        function s() {
          i.removeEventListener("end", s),
            (r.textContent = "START XR"),
            (i = null);
        }
        (r.style.display = ""),
          (r.style.cursor = "pointer"),
          (r.style.left = "calc(50% - 50px)"),
          (r.style.width = "100px"),
          (r.textContent = "START XR");
        const a = {
          ...t,
          optionalFeatures: [
            "local-floor",
            "bounded-floor",
            "hand-tracking",
            "layers",
            ...(t.optionalFeatures || []),
          ],
        };
        (r.onmouseenter = function () {
          r.style.opacity = "1.0";
        }),
          (r.onmouseleave = function () {
            r.style.opacity = "0.5";
          }),
          (r.onclick = function () {
            null === i
              ? navigator.xr.requestSession(n, a).then(o)
              : (i.end(),
                void 0 !== navigator.xr.offerSession &&
                  navigator.xr.offerSession(n, a).then(o));
          }),
          void 0 !== navigator.xr.offerSession &&
            navigator.xr.offerSession(n, a).then(o);
      }
      function i() {
        (r.style.display = ""),
          (r.style.cursor = "auto"),
          (r.style.left = "calc(50% - 75px)"),
          (r.style.width = "150px"),
          (r.onmouseenter = null),
          (r.onmouseleave = null),
          (r.onclick = null);
      }
      function o(e) {
        i(),
          console.warn(
            "Exception when trying to call xr.isSessionSupported",
            e
          ),
          (r.textContent = "XR NOT ALLOWED");
      }
      function s(e) {
        (e.style.position = "absolute"),
          (e.style.bottom = "20px"),
          (e.style.padding = "12px 6px"),
          (e.style.border = "1px solid #fff"),
          (e.style.borderRadius = "4px"),
          (e.style.background = "rgba(0,0,0,0.1)"),
          (e.style.color = "#fff"),
          (e.style.font = "normal 13px sans-serif"),
          (e.style.textAlign = "center"),
          (e.style.opacity = "0.5"),
          (e.style.outline = "none"),
          (e.style.zIndex = "999");
      }
      if ("xr" in navigator)
        return (
          (r.id = "XRButton"),
          (r.style.display = "none"),
          s(r),
          navigator.xr
            .isSessionSupported("immersive-ar")
            .then(function (e) {
              e
                ? n("immersive-ar")
                : navigator.xr
                    .isSessionSupported("immersive-vr")
                    .then(function (e) {
                      e
                        ? n("immersive-vr")
                        : (i(), (r.textContent = "XR NOT SUPPORTED"));
                    })
                    .catch(o);
            })
            .catch(o),
          r
        );
      {
        const e = document.createElement("a");
        return (
          !1 === window.isSecureContext
            ? ((e.href = document.location.href.replace(/^http:/, "https:")),
              (e.innerHTML = "WEBXR NEEDS HTTPS"))
            : ((e.href = "https://immersiveweb.dev/"),
              (e.innerHTML = "WEBXR NOT AVAILABLE")),
          (e.style.left = "calc(50% - 90px)"),
          (e.style.width = "180px"),
          (e.style.textDecoration = "none"),
          s(e),
          e
        );
      }
    }
  }
  function ol(e, t) {
    if (0 === t)
      return (
        console.warn(
          "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
        ),
        e
      );
    if (2 === t || 1 === t) {
      let r = e.getIndex();
      if (null === r) {
        const t = [],
          n = e.getAttribute("position");
        if (void 0 === n)
          return (
            console.error(
              "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
            ),
            e
          );
        for (let e = 0; e < n.count; e++) t.push(e);
        e.setIndex(t), (r = e.getIndex());
      }
      const n = r.count - 2,
        i = [];
      if (2 === t)
        for (let e = 1; e <= n; e++)
          i.push(r.getX(0)), i.push(r.getX(e)), i.push(r.getX(e + 1));
      else
        for (let e = 0; e < n; e++)
          e % 2 == 0
            ? (i.push(r.getX(e)), i.push(r.getX(e + 1)), i.push(r.getX(e + 2)))
            : (i.push(r.getX(e + 2)), i.push(r.getX(e + 1)), i.push(r.getX(e)));
      i.length / 3 !== n &&
        console.error(
          "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
        );
      const o = e.clone();
      return o.setIndex(i), o.clearGroups(), o;
    }
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        t
      ),
      e
    );
  }
  class sl extends Pa {
    constructor(e) {
      super(e),
        (this.dracoLoader = null),
        (this.ktx2Loader = null),
        (this.meshoptDecoder = null),
        (this.pluginCallbacks = []),
        this.register(function (e) {
          return new dl(e);
        }),
        this.register(function (e) {
          return new xl(e);
        }),
        this.register(function (e) {
          return new wl(e);
        }),
        this.register(function (e) {
          return new Sl(e);
        }),
        this.register(function (e) {
          return new fl(e);
        }),
        this.register(function (e) {
          return new ml(e);
        }),
        this.register(function (e) {
          return new gl(e);
        }),
        this.register(function (e) {
          return new _l(e);
        }),
        this.register(function (e) {
          return new hl(e);
        }),
        this.register(function (e) {
          return new vl(e);
        }),
        this.register(function (e) {
          return new pl(e);
        }),
        this.register(function (e) {
          return new bl(e);
        }),
        this.register(function (e) {
          return new yl(e);
        }),
        this.register(function (e) {
          return new cl(e);
        }),
        this.register(function (e) {
          return new El(e);
        }),
        this.register(function (e) {
          return new Ml(e);
        });
    }
    load(e, t, r, n) {
      const i = this;
      let o;
      if ("" !== this.resourcePath) o = this.resourcePath;
      else if ("" !== this.path) {
        const t = Ka.extractUrlBase(e);
        o = Ka.resolveURL(t, this.path);
      } else o = Ka.extractUrlBase(e);
      this.manager.itemStart(e);
      const s = function (t) {
          n ? n(t) : console.error(t),
            i.manager.itemError(e),
            i.manager.itemEnd(e);
        },
        a = new La(this.manager);
      a.setPath(this.path),
        a.setResponseType("arraybuffer"),
        a.setRequestHeader(this.requestHeader),
        a.setWithCredentials(this.withCredentials),
        a.load(
          e,
          function (r) {
            try {
              i.parse(
                r,
                o,
                function (r) {
                  t(r), i.manager.itemEnd(e);
                },
                s
              );
            } catch (e) {
              s(e);
            }
          },
          r,
          s
        );
    }
    setDRACOLoader(e) {
      return (this.dracoLoader = e), this;
    }
    setDDSLoader() {
      throw new Error(
        'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
      );
    }
    setKTX2Loader(e) {
      return (this.ktx2Loader = e), this;
    }
    setMeshoptDecoder(e) {
      return (this.meshoptDecoder = e), this;
    }
    register(e) {
      return (
        -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e),
        this
      );
    }
    unregister(e) {
      return (
        -1 !== this.pluginCallbacks.indexOf(e) &&
          this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
        this
      );
    }
    parse(e, t, r, n) {
      let i;
      const o = {},
        s = {},
        a = new TextDecoder();
      if ("string" == typeof e) i = JSON.parse(e);
      else if (e instanceof ArrayBuffer)
        if (a.decode(new Uint8Array(e, 0, 4)) === Tl) {
          try {
            o[ll.KHR_BINARY_GLTF] = new Al(e);
          } catch (e) {
            return void (n && n(e));
          }
          i = JSON.parse(o[ll.KHR_BINARY_GLTF].content);
        } else i = JSON.parse(a.decode(e));
      else i = e;
      if (void 0 === i.asset || i.asset.version[0] < 2)
        return void (
          n &&
          n(
            new Error(
              "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
            )
          )
        );
      const l = new $l(i, {
        path: t || this.resourcePath || "",
        crossOrigin: this.crossOrigin,
        requestHeader: this.requestHeader,
        manager: this.manager,
        ktx2Loader: this.ktx2Loader,
        meshoptDecoder: this.meshoptDecoder,
      });
      l.fileLoader.setRequestHeader(this.requestHeader);
      for (let e = 0; e < this.pluginCallbacks.length; e++) {
        const t = this.pluginCallbacks[e](l);
        t.name ||
          console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
          (s[t.name] = t),
          (o[t.name] = !0);
      }
      if (i.extensionsUsed)
        for (let e = 0; e < i.extensionsUsed.length; ++e) {
          const t = i.extensionsUsed[e],
            r = i.extensionsRequired || [];
          switch (t) {
            case ll.KHR_MATERIALS_UNLIT:
              o[t] = new ul();
              break;
            case ll.KHR_DRACO_MESH_COMPRESSION:
              o[t] = new Rl(i, this.dracoLoader);
              break;
            case ll.KHR_TEXTURE_TRANSFORM:
              o[t] = new Pl();
              break;
            case ll.KHR_MESH_QUANTIZATION:
              o[t] = new Cl();
              break;
            default:
              r.indexOf(t) >= 0 &&
                void 0 === s[t] &&
                console.warn(
                  'THREE.GLTFLoader: Unknown extension "' + t + '".'
                );
          }
        }
      l.setExtensions(o), l.setPlugins(s), l.parse(r, n);
    }
    parseAsync(e, t) {
      const r = this;
      return new Promise(function (n, i) {
        r.parse(e, t, n, i);
      });
    }
  }
  function al() {
    let e = {};
    return {
      get: function (t) {
        return e[t];
      },
      add: function (t, r) {
        e[t] = r;
      },
      remove: function (t) {
        delete e[t];
      },
      removeAll: function () {
        e = {};
      },
    };
  }
  const ll = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_MATERIALS_BUMP: "EXT_materials_bump",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
  };
  class cl {
    constructor(e) {
      (this.parser = e),
        (this.name = ll.KHR_LIGHTS_PUNCTUAL),
        (this.cache = { refs: {}, uses: {} });
    }
    _markDefs() {
      const e = this.parser,
        t = this.parser.json.nodes || [];
      for (let r = 0, n = t.length; r < n; r++) {
        const n = t[r];
        n.extensions &&
          n.extensions[this.name] &&
          void 0 !== n.extensions[this.name].light &&
          e._addNodeRef(this.cache, n.extensions[this.name].light);
      }
    }
    _loadLight(e) {
      const t = this.parser,
        r = "light:" + e;
      let n = t.cache.get(r);
      if (n) return n;
      const i = t.json,
        o = (((i.extensions && i.extensions[this.name]) || {}).lights || [])[e];
      let s;
      const a = new Rr(16777215);
      void 0 !== o.color && a.setRGB(o.color[0], o.color[1], o.color[2], re);
      const l = void 0 !== o.range ? o.range : 0;
      switch (o.type) {
        case "directional":
          (s = new Ya(a)), s.target.position.set(0, 0, -1), s.add(s.target);
          break;
        case "point":
          (s = new Xa(a)), (s.distance = l);
          break;
        case "spot":
          (s = new za(a)),
            (s.distance = l),
            (o.spot = o.spot || {}),
            (o.spot.innerConeAngle =
              void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0),
            (o.spot.outerConeAngle =
              void 0 !== o.spot.outerConeAngle
                ? o.spot.outerConeAngle
                : Math.PI / 4),
            (s.angle = o.spot.outerConeAngle),
            (s.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle),
            s.target.position.set(0, 0, -1),
            s.add(s.target);
          break;
        default:
          throw new Error("THREE.GLTFLoader: Unexpected light type: " + o.type);
      }
      return (
        s.position.set(0, 0, 0),
        (s.decay = 2),
        Wl(s, o),
        void 0 !== o.intensity && (s.intensity = o.intensity),
        (s.name = t.createUniqueName(o.name || "light_" + e)),
        (n = Promise.resolve(s)),
        t.cache.add(r, n),
        n
      );
    }
    getDependency(e, t) {
      if ("light" === e) return this._loadLight(t);
    }
    createNodeAttachment(e) {
      const t = this,
        r = this.parser,
        n = r.json.nodes[e],
        i = ((n.extensions && n.extensions[this.name]) || {}).light;
      return void 0 === i
        ? null
        : this._loadLight(i).then(function (e) {
            return r._getNodeRef(t.cache, i, e);
          });
    }
  }
  class ul {
    constructor() {
      this.name = ll.KHR_MATERIALS_UNLIT;
    }
    getMaterialType() {
      return Lr;
    }
    extendParams(e, t, r) {
      const n = [];
      (e.color = new Rr(1, 1, 1)), (e.opacity = 1);
      const i = t.pbrMetallicRoughness;
      if (i) {
        if (Array.isArray(i.baseColorFactor)) {
          const t = i.baseColorFactor;
          e.color.setRGB(t[0], t[1], t[2], re), (e.opacity = t[3]);
        }
        void 0 !== i.baseColorTexture &&
          n.push(r.assignTexture(e, "map", i.baseColorTexture, te));
      }
      return Promise.all(n);
    }
  }
  class hl {
    constructor(e) {
      (this.parser = e), (this.name = ll.KHR_MATERIALS_EMISSIVE_STRENGTH);
    }
    extendMaterialParams(e, t) {
      const r = this.parser.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const n = r.extensions[this.name].emissiveStrength;
      return void 0 !== n && (t.emissiveIntensity = n), Promise.resolve();
    }
  }
  class dl {
    constructor(e) {
      (this.parser = e), (this.name = ll.KHR_MATERIALS_CLEARCOAT);
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? aa : null;
    }
    extendMaterialParams(e, t) {
      const r = this.parser,
        n = r.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const i = [],
        o = n.extensions[this.name];
      if (
        (void 0 !== o.clearcoatFactor && (t.clearcoat = o.clearcoatFactor),
        void 0 !== o.clearcoatTexture &&
          i.push(r.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
        void 0 !== o.clearcoatRoughnessFactor &&
          (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
        void 0 !== o.clearcoatRoughnessTexture &&
          i.push(
            r.assignTexture(
              t,
              "clearcoatRoughnessMap",
              o.clearcoatRoughnessTexture
            )
          ),
        void 0 !== o.clearcoatNormalTexture &&
          (i.push(
            r.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)
          ),
          void 0 !== o.clearcoatNormalTexture.scale))
      ) {
        const e = o.clearcoatNormalTexture.scale;
        t.clearcoatNormalScale = new De(e, e);
      }
      return Promise.all(i);
    }
  }
  class pl {
    constructor(e) {
      (this.parser = e), (this.name = ll.KHR_MATERIALS_IRIDESCENCE);
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? aa : null;
    }
    extendMaterialParams(e, t) {
      const r = this.parser,
        n = r.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const i = [],
        o = n.extensions[this.name];
      return (
        void 0 !== o.iridescenceFactor && (t.iridescence = o.iridescenceFactor),
        void 0 !== o.iridescenceTexture &&
          i.push(r.assignTexture(t, "iridescenceMap", o.iridescenceTexture)),
        void 0 !== o.iridescenceIor && (t.iridescenceIOR = o.iridescenceIor),
        void 0 === t.iridescenceThicknessRange &&
          (t.iridescenceThicknessRange = [100, 400]),
        void 0 !== o.iridescenceThicknessMinimum &&
          (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
        void 0 !== o.iridescenceThicknessMaximum &&
          (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
        void 0 !== o.iridescenceThicknessTexture &&
          i.push(
            r.assignTexture(
              t,
              "iridescenceThicknessMap",
              o.iridescenceThicknessTexture
            )
          ),
        Promise.all(i)
      );
    }
  }
  class fl {
    constructor(e) {
      (this.parser = e), (this.name = ll.KHR_MATERIALS_SHEEN);
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? aa : null;
    }
    extendMaterialParams(e, t) {
      const r = this.parser,
        n = r.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const i = [];
      (t.sheenColor = new Rr(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
      const o = n.extensions[this.name];
      if (void 0 !== o.sheenColorFactor) {
        const e = o.sheenColorFactor;
        t.sheenColor.setRGB(e[0], e[1], e[2], re);
      }
      return (
        void 0 !== o.sheenRoughnessFactor &&
          (t.sheenRoughness = o.sheenRoughnessFactor),
        void 0 !== o.sheenColorTexture &&
          i.push(r.assignTexture(t, "sheenColorMap", o.sheenColorTexture, te)),
        void 0 !== o.sheenRoughnessTexture &&
          i.push(
            r.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)
          ),
        Promise.all(i)
      );
    }
  }
  class ml {
    constructor(e) {
      (this.parser = e), (this.name = ll.KHR_MATERIALS_TRANSMISSION);
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? aa : null;
    }
    extendMaterialParams(e, t) {
      const r = this.parser,
        n = r.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const i = [],
        o = n.extensions[this.name];
      return (
        void 0 !== o.transmissionFactor &&
          (t.transmission = o.transmissionFactor),
        void 0 !== o.transmissionTexture &&
          i.push(r.assignTexture(t, "transmissionMap", o.transmissionTexture)),
        Promise.all(i)
      );
    }
  }
  class gl {
    constructor(e) {
      (this.parser = e), (this.name = ll.KHR_MATERIALS_VOLUME);
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? aa : null;
    }
    extendMaterialParams(e, t) {
      const r = this.parser,
        n = r.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const i = [],
        o = n.extensions[this.name];
      (t.thickness = void 0 !== o.thicknessFactor ? o.thicknessFactor : 0),
        void 0 !== o.thicknessTexture &&
          i.push(r.assignTexture(t, "thicknessMap", o.thicknessTexture)),
        (t.attenuationDistance = o.attenuationDistance || 1 / 0);
      const s = o.attenuationColor || [1, 1, 1];
      return (
        (t.attenuationColor = new Rr().setRGB(s[0], s[1], s[2], re)),
        Promise.all(i)
      );
    }
  }
  class _l {
    constructor(e) {
      (this.parser = e), (this.name = ll.KHR_MATERIALS_IOR);
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? aa : null;
    }
    extendMaterialParams(e, t) {
      const r = this.parser.json.materials[e];
      if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
      const n = r.extensions[this.name];
      return (t.ior = void 0 !== n.ior ? n.ior : 1.5), Promise.resolve();
    }
  }
  class vl {
    constructor(e) {
      (this.parser = e), (this.name = ll.KHR_MATERIALS_SPECULAR);
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? aa : null;
    }
    extendMaterialParams(e, t) {
      const r = this.parser,
        n = r.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const i = [],
        o = n.extensions[this.name];
      (t.specularIntensity =
        void 0 !== o.specularFactor ? o.specularFactor : 1),
        void 0 !== o.specularTexture &&
          i.push(r.assignTexture(t, "specularIntensityMap", o.specularTexture));
      const s = o.specularColorFactor || [1, 1, 1];
      return (
        (t.specularColor = new Rr().setRGB(s[0], s[1], s[2], re)),
        void 0 !== o.specularColorTexture &&
          i.push(
            r.assignTexture(t, "specularColorMap", o.specularColorTexture, te)
          ),
        Promise.all(i)
      );
    }
  }
  class yl {
    constructor(e) {
      (this.parser = e), (this.name = ll.EXT_MATERIALS_BUMP);
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? aa : null;
    }
    extendMaterialParams(e, t) {
      const r = this.parser,
        n = r.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const i = [],
        o = n.extensions[this.name];
      return (
        (t.bumpScale = void 0 !== o.bumpFactor ? o.bumpFactor : 1),
        void 0 !== o.bumpTexture &&
          i.push(r.assignTexture(t, "bumpMap", o.bumpTexture)),
        Promise.all(i)
      );
    }
  }
  class bl {
    constructor(e) {
      (this.parser = e), (this.name = ll.KHR_MATERIALS_ANISOTROPY);
    }
    getMaterialType(e) {
      const t = this.parser.json.materials[e];
      return t.extensions && t.extensions[this.name] ? aa : null;
    }
    extendMaterialParams(e, t) {
      const r = this.parser,
        n = r.json.materials[e];
      if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
      const i = [],
        o = n.extensions[this.name];
      return (
        void 0 !== o.anisotropyStrength &&
          (t.anisotropy = o.anisotropyStrength),
        void 0 !== o.anisotropyRotation &&
          (t.anisotropyRotation = o.anisotropyRotation),
        void 0 !== o.anisotropyTexture &&
          i.push(r.assignTexture(t, "anisotropyMap", o.anisotropyTexture)),
        Promise.all(i)
      );
    }
  }
  class xl {
    constructor(e) {
      (this.parser = e), (this.name = ll.KHR_TEXTURE_BASISU);
    }
    loadTexture(e) {
      const t = this.parser,
        r = t.json,
        n = r.textures[e];
      if (!n.extensions || !n.extensions[this.name]) return null;
      const i = n.extensions[this.name],
        o = t.options.ktx2Loader;
      if (!o) {
        if (
          r.extensionsRequired &&
          r.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
          );
        return null;
      }
      return t.loadTextureImage(e, i.source, o);
    }
  }
  class wl {
    constructor(e) {
      (this.parser = e),
        (this.name = ll.EXT_TEXTURE_WEBP),
        (this.isSupported = null);
    }
    loadTexture(e) {
      const t = this.name,
        r = this.parser,
        n = r.json,
        i = n.textures[e];
      if (!i.extensions || !i.extensions[t]) return null;
      const o = i.extensions[t],
        s = n.images[o.source];
      let a = r.textureLoader;
      if (s.uri) {
        const e = r.options.manager.getHandler(s.uri);
        null !== e && (a = e);
      }
      return this.detectSupport().then(function (i) {
        if (i) return r.loadTextureImage(e, o.source, a);
        if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
          throw new Error(
            "THREE.GLTFLoader: WebP required by asset but unsupported."
          );
        return r.loadTexture(e);
      });
    }
    detectSupport() {
      return (
        this.isSupported ||
          (this.isSupported = new Promise(function (e) {
            const t = new Image();
            (t.src =
              "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
              (t.onload = t.onerror =
                function () {
                  e(1 === t.height);
                });
          })),
        this.isSupported
      );
    }
  }
  class Sl {
    constructor(e) {
      (this.parser = e),
        (this.name = ll.EXT_TEXTURE_AVIF),
        (this.isSupported = null);
    }
    loadTexture(e) {
      const t = this.name,
        r = this.parser,
        n = r.json,
        i = n.textures[e];
      if (!i.extensions || !i.extensions[t]) return null;
      const o = i.extensions[t],
        s = n.images[o.source];
      let a = r.textureLoader;
      if (s.uri) {
        const e = r.options.manager.getHandler(s.uri);
        null !== e && (a = e);
      }
      return this.detectSupport().then(function (i) {
        if (i) return r.loadTextureImage(e, o.source, a);
        if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
          throw new Error(
            "THREE.GLTFLoader: AVIF required by asset but unsupported."
          );
        return r.loadTexture(e);
      });
    }
    detectSupport() {
      return (
        this.isSupported ||
          (this.isSupported = new Promise(function (e) {
            const t = new Image();
            (t.src =
              "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
              (t.onload = t.onerror =
                function () {
                  e(1 === t.height);
                });
          })),
        this.isSupported
      );
    }
  }
  class El {
    constructor(e) {
      (this.name = ll.EXT_MESHOPT_COMPRESSION), (this.parser = e);
    }
    loadBufferView(e) {
      const t = this.parser.json,
        r = t.bufferViews[e];
      if (r.extensions && r.extensions[this.name]) {
        const e = r.extensions[this.name],
          n = this.parser.getDependency("buffer", e.buffer),
          i = this.parser.options.meshoptDecoder;
        if (!i || !i.supported) {
          if (
            t.extensionsRequired &&
            t.extensionsRequired.indexOf(this.name) >= 0
          )
            throw new Error(
              "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
            );
          return null;
        }
        return n.then(function (t) {
          const r = e.byteOffset || 0,
            n = e.byteLength || 0,
            o = e.count,
            s = e.byteStride,
            a = new Uint8Array(t, r, n);
          return i.decodeGltfBufferAsync
            ? i
                .decodeGltfBufferAsync(o, s, a, e.mode, e.filter)
                .then(function (e) {
                  return e.buffer;
                })
            : i.ready.then(function () {
                const t = new ArrayBuffer(o * s);
                return (
                  i.decodeGltfBuffer(
                    new Uint8Array(t),
                    o,
                    s,
                    a,
                    e.mode,
                    e.filter
                  ),
                  t
                );
              });
        });
      }
      return null;
    }
  }
  class Ml {
    constructor(e) {
      (this.name = ll.EXT_MESH_GPU_INSTANCING), (this.parser = e);
    }
    createNodeMesh(e) {
      const t = this.parser.json,
        r = t.nodes[e];
      if (!r.extensions || !r.extensions[this.name] || void 0 === r.mesh)
        return null;
      const n = t.meshes[r.mesh];
      for (const e of n.primitives)
        if (
          e.mode !== Nl.TRIANGLES &&
          e.mode !== Nl.TRIANGLE_STRIP &&
          e.mode !== Nl.TRIANGLE_FAN &&
          void 0 !== e.mode
        )
          return null;
      const i = r.extensions[this.name].attributes,
        o = [],
        s = {};
      for (const e in i)
        o.push(
          this.parser
            .getDependency("accessor", i[e])
            .then((t) => ((s[e] = t), s[e]))
        );
      return o.length < 1
        ? null
        : (o.push(this.parser.createNodeMesh(e)),
          Promise.all(o).then((e) => {
            const t = e.pop(),
              r = t.isGroup ? t.children : [t],
              n = e[0].count,
              i = [];
            for (const e of r) {
              const t = new Ht(),
                r = new ut(),
                o = new ct(),
                a = new ut(1, 1, 1),
                l = new Hs(e.geometry, e.material, n);
              for (let e = 0; e < n; e++)
                s.TRANSLATION && r.fromBufferAttribute(s.TRANSLATION, e),
                  s.ROTATION && o.fromBufferAttribute(s.ROTATION, e),
                  s.SCALE && a.fromBufferAttribute(s.SCALE, e),
                  l.setMatrixAt(e, t.compose(r, o, a));
              for (const t in s)
                if ("_COLOR_0" === t) {
                  const e = s[t];
                  l.instanceColor = new Ls(e.array, e.itemSize, e.normalized);
                } else
                  "TRANSLATION" !== t &&
                    "ROTATION" !== t &&
                    "SCALE" !== t &&
                    e.geometry.setAttribute(t, s[t]);
              hr.prototype.copy.call(l, e),
                this.parser.assignFinalMaterial(l),
                i.push(l);
            }
            return t.isGroup ? (t.clear(), t.add(...i), t) : i[0];
          }));
    }
  }
  const Tl = "glTF";
  class Al {
    constructor(e) {
      (this.name = ll.KHR_BINARY_GLTF),
        (this.content = null),
        (this.body = null);
      const t = new DataView(e, 0, 12),
        r = new TextDecoder();
      if (
        ((this.header = {
          magic: r.decode(new Uint8Array(e.slice(0, 4))),
          version: t.getUint32(4, !0),
          length: t.getUint32(8, !0),
        }),
        this.header.magic !== Tl)
      )
        throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
      if (this.header.version < 2)
        throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
      const n = this.header.length - 12,
        i = new DataView(e, 12);
      let o = 0;
      for (; o < n; ) {
        const t = i.getUint32(o, !0);
        o += 4;
        const n = i.getUint32(o, !0);
        if (((o += 4), 1313821514 === n)) {
          const n = new Uint8Array(e, 12 + o, t);
          this.content = r.decode(n);
        } else if (5130562 === n) {
          const r = 12 + o;
          this.body = e.slice(r, r + t);
        }
        o += t;
      }
      if (null === this.content)
        throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
  class Rl {
    constructor(e, t) {
      if (!t)
        throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
      (this.name = ll.KHR_DRACO_MESH_COMPRESSION),
        (this.json = e),
        (this.dracoLoader = t),
        this.dracoLoader.preload();
    }
    decodePrimitive(e, t) {
      const r = this.json,
        n = this.dracoLoader,
        i = e.extensions[this.name].bufferView,
        o = e.extensions[this.name].attributes,
        s = {},
        a = {},
        l = {};
      for (const e in o) {
        const t = Fl[e] || e.toLowerCase();
        s[t] = o[e];
      }
      for (const t in e.attributes) {
        const n = Fl[t] || t.toLowerCase();
        if (void 0 !== o[t]) {
          const i = r.accessors[e.attributes[t]],
            o = Ul[i.componentType];
          (l[n] = o.name), (a[n] = !0 === i.normalized);
        }
      }
      return t.getDependency("bufferView", i).then(function (e) {
        return new Promise(function (t, r) {
          n.decodeDracoFile(
            e,
            function (e) {
              for (const t in e.attributes) {
                const r = e.attributes[t],
                  n = a[t];
                void 0 !== n && (r.normalized = n);
              }
              t(e);
            },
            s,
            l,
            re,
            r
          );
        });
      });
    }
  }
  class Pl {
    constructor() {
      this.name = ll.KHR_TEXTURE_TRANSFORM;
    }
    extendTexture(e, t) {
      return (void 0 !== t.texCoord && t.texCoord !== e.channel) ||
        void 0 !== t.offset ||
        void 0 !== t.rotation ||
        void 0 !== t.scale
        ? ((e = e.clone()),
          void 0 !== t.texCoord && (e.channel = t.texCoord),
          void 0 !== t.offset && e.offset.fromArray(t.offset),
          void 0 !== t.rotation && (e.rotation = t.rotation),
          void 0 !== t.scale && e.repeat.fromArray(t.scale),
          (e.needsUpdate = !0),
          e)
        : e;
    }
  }
  class Cl {
    constructor() {
      this.name = ll.KHR_MESH_QUANTIZATION;
    }
  }
  class Il extends da {
    constructor(e, t, r, n) {
      super(e, t, r, n);
    }
    copySampleValue_(e) {
      const t = this.resultBuffer,
        r = this.sampleValues,
        n = this.valueSize,
        i = e * n * 3 + n;
      for (let e = 0; e !== n; e++) t[e] = r[i + e];
      return t;
    }
    interpolate_(e, t, r, n) {
      const i = this.resultBuffer,
        o = this.sampleValues,
        s = this.valueSize,
        a = 2 * s,
        l = 3 * s,
        c = n - t,
        u = (r - t) / c,
        h = u * u,
        d = h * u,
        p = e * l,
        f = p - l,
        m = -2 * d + 3 * h,
        g = d - h,
        _ = 1 - m,
        v = g - h + u;
      for (let e = 0; e !== s; e++) {
        const t = o[f + e + s],
          r = o[f + e + a] * c,
          n = o[p + e + s],
          l = o[p + e] * c;
        i[e] = _ * t + v * r + m * n + g * l;
      }
      return i;
    }
  }
  const Ll = new ct();
  class Ol extends Il {
    interpolate_(e, t, r, n) {
      const i = super.interpolate_(e, t, r, n);
      return Ll.fromArray(i).normalize().toArray(i), i;
    }
  }
  const Nl = {
      FLOAT: 5126,
      FLOAT_MAT3: 35675,
      FLOAT_MAT4: 35676,
      FLOAT_VEC2: 35664,
      FLOAT_VEC3: 35665,
      FLOAT_VEC4: 35666,
      LINEAR: 9729,
      REPEAT: 10497,
      SAMPLER_2D: 35678,
      POINTS: 0,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      TRIANGLES: 4,
      TRIANGLE_STRIP: 5,
      TRIANGLE_FAN: 6,
      UNSIGNED_BYTE: 5121,
      UNSIGNED_SHORT: 5123,
    },
    Ul = {
      5120: Int8Array,
      5121: Uint8Array,
      5122: Int16Array,
      5123: Uint16Array,
      5125: Uint32Array,
      5126: Float32Array,
    },
    Dl = { 9728: C, 9729: O, 9984: I, 9985: 1007, 9986: L, 9987: U },
    kl = { 33071: R, 33648: P, 10497: A },
    Bl = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
    Fl = {
      POSITION: "position",
      NORMAL: "normal",
      TANGENT: "tangent",
      TEXCOORD_0: "uv",
      TEXCOORD_1: "uv1",
      TEXCOORD_2: "uv2",
      TEXCOORD_3: "uv3",
      COLOR_0: "color",
      WEIGHTS_0: "skinWeight",
      JOINTS_0: "skinIndex",
    },
    Hl = {
      scale: "scale",
      translation: "position",
      rotation: "quaternion",
      weights: "morphTargetInfluences",
    },
    zl = { CUBICSPLINE: void 0, LINEAR: Q, STEP: $ };
  function Vl(e) {
    return (
      void 0 === e.DefaultMaterial &&
        (e.DefaultMaterial = new sa({
          color: 16777215,
          emissive: 0,
          metalness: 1,
          roughness: 1,
          transparent: !1,
          depthTest: !0,
          side: 0,
        })),
      e.DefaultMaterial
    );
  }
  function jl(e, t, r) {
    for (const n in r.extensions)
      void 0 === e[n] &&
        ((t.userData.gltfExtensions = t.userData.gltfExtensions || {}),
        (t.userData.gltfExtensions[n] = r.extensions[n]));
  }
  function Wl(e, t) {
    void 0 !== t.extras &&
      ("object" == typeof t.extras
        ? Object.assign(e.userData, t.extras)
        : console.warn(
            "THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras
          ));
  }
  function Gl(e, t) {
    if ((e.updateMorphTargets(), void 0 !== t.weights))
      for (let r = 0, n = t.weights.length; r < n; r++)
        e.morphTargetInfluences[r] = t.weights[r];
    if (t.extras && Array.isArray(t.extras.targetNames)) {
      const r = t.extras.targetNames;
      if (e.morphTargetInfluences.length === r.length) {
        e.morphTargetDictionary = {};
        for (let t = 0, n = r.length; t < n; t++)
          e.morphTargetDictionary[r[t]] = t;
      } else
        console.warn(
          "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
        );
    }
  }
  function Xl(e) {
    let t;
    const r = e.extensions && e.extensions[ll.KHR_DRACO_MESH_COMPRESSION];
    if (
      ((t = r
        ? "draco:" + r.bufferView + ":" + r.indices + ":" + ql(r.attributes)
        : e.indices + ":" + ql(e.attributes) + ":" + e.mode),
      void 0 !== e.targets)
    )
      for (let r = 0, n = e.targets.length; r < n; r++)
        t += ":" + ql(e.targets[r]);
    return t;
  }
  function ql(e) {
    let t = "";
    const r = Object.keys(e).sort();
    for (let n = 0, i = r.length; n < i; n++) t += r[n] + ":" + e[r[n]] + ";";
    return t;
  }
  function Yl(e) {
    switch (e) {
      case Int8Array:
        return 1 / 127;
      case Uint8Array:
        return 1 / 255;
      case Int16Array:
        return 1 / 32767;
      case Uint16Array:
        return 1 / 65535;
      default:
        throw new Error(
          "THREE.GLTFLoader: Unsupported normalized accessor component type."
        );
    }
  }
  const Kl = new Ht();
  class $l {
    constructor(e = {}, t = {}) {
      (this.json = e),
        (this.extensions = {}),
        (this.plugins = {}),
        (this.options = t),
        (this.cache = new al()),
        (this.associations = new Map()),
        (this.primitiveCache = {}),
        (this.nodeCache = {}),
        (this.meshCache = { refs: {}, uses: {} }),
        (this.cameraCache = { refs: {}, uses: {} }),
        (this.lightCache = { refs: {}, uses: {} }),
        (this.sourceCache = {}),
        (this.textureCache = {}),
        (this.nodeNamesUsed = {});
      let r = !1,
        n = !1,
        i = -1;
      "undefined" != typeof navigator &&
        ((r =
          !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent)),
        (n = navigator.userAgent.indexOf("Firefox") > -1),
        (i = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
        "undefined" == typeof createImageBitmap || r || (n && i < 98)
          ? (this.textureLoader = new Na(this.options.manager))
          : (this.textureLoader = new $a(this.options.manager)),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        this.textureLoader.setRequestHeader(this.options.requestHeader),
        (this.fileLoader = new La(this.options.manager)),
        this.fileLoader.setResponseType("arraybuffer"),
        "use-credentials" === this.options.crossOrigin &&
          this.fileLoader.setWithCredentials(!0);
    }
    setExtensions(e) {
      this.extensions = e;
    }
    setPlugins(e) {
      this.plugins = e;
    }
    parse(e, t) {
      const r = this,
        n = this.json,
        i = this.extensions;
      this.cache.removeAll(),
        (this.nodeCache = {}),
        this._invokeAll(function (e) {
          return e._markDefs && e._markDefs();
        }),
        Promise.all(
          this._invokeAll(function (e) {
            return e.beforeRoot && e.beforeRoot();
          })
        )
          .then(function () {
            return Promise.all([
              r.getDependencies("scene"),
              r.getDependencies("animation"),
              r.getDependencies("camera"),
            ]);
          })
          .then(function (t) {
            const o = {
              scene: t[0][n.scene || 0],
              scenes: t[0],
              animations: t[1],
              cameras: t[2],
              asset: n.asset,
              parser: r,
              userData: {},
            };
            return (
              jl(i, o, n),
              Wl(o, n),
              Promise.all(
                r._invokeAll(function (e) {
                  return e.afterRoot && e.afterRoot(o);
                })
              ).then(function () {
                e(o);
              })
            );
          })
          .catch(t);
    }
    _markDefs() {
      const e = this.json.nodes || [],
        t = this.json.skins || [],
        r = this.json.meshes || [];
      for (let r = 0, n = t.length; r < n; r++) {
        const n = t[r].joints;
        for (let t = 0, r = n.length; t < r; t++) e[n[t]].isBone = !0;
      }
      for (let t = 0, n = e.length; t < n; t++) {
        const n = e[t];
        void 0 !== n.mesh &&
          (this._addNodeRef(this.meshCache, n.mesh),
          void 0 !== n.skin && (r[n.mesh].isSkinnedMesh = !0)),
          void 0 !== n.camera && this._addNodeRef(this.cameraCache, n.camera);
      }
    }
    _addNodeRef(e, t) {
      void 0 !== t &&
        (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
    }
    _getNodeRef(e, t, r) {
      if (e.refs[t] <= 1) return r;
      const n = r.clone(),
        i = (e, t) => {
          const r = this.associations.get(e);
          null != r && this.associations.set(t, r);
          for (const [r, n] of e.children.entries()) i(n, t.children[r]);
        };
      return i(r, n), (n.name += "_instance_" + e.uses[t]++), n;
    }
    _invokeOne(e) {
      const t = Object.values(this.plugins);
      t.push(this);
      for (let r = 0; r < t.length; r++) {
        const n = e(t[r]);
        if (n) return n;
      }
      return null;
    }
    _invokeAll(e) {
      const t = Object.values(this.plugins);
      t.unshift(this);
      const r = [];
      for (let n = 0; n < t.length; n++) {
        const i = e(t[n]);
        i && r.push(i);
      }
      return r;
    }
    getDependency(e, t) {
      const r = e + ":" + t;
      let n = this.cache.get(r);
      if (!n) {
        switch (e) {
          case "scene":
            n = this.loadScene(t);
            break;
          case "node":
            n = this._invokeOne(function (e) {
              return e.loadNode && e.loadNode(t);
            });
            break;
          case "mesh":
            n = this._invokeOne(function (e) {
              return e.loadMesh && e.loadMesh(t);
            });
            break;
          case "accessor":
            n = this.loadAccessor(t);
            break;
          case "bufferView":
            n = this._invokeOne(function (e) {
              return e.loadBufferView && e.loadBufferView(t);
            });
            break;
          case "buffer":
            n = this.loadBuffer(t);
            break;
          case "material":
            n = this._invokeOne(function (e) {
              return e.loadMaterial && e.loadMaterial(t);
            });
            break;
          case "texture":
            n = this._invokeOne(function (e) {
              return e.loadTexture && e.loadTexture(t);
            });
            break;
          case "skin":
            n = this.loadSkin(t);
            break;
          case "animation":
            n = this._invokeOne(function (e) {
              return e.loadAnimation && e.loadAnimation(t);
            });
            break;
          case "camera":
            n = this.loadCamera(t);
            break;
          default:
            if (
              ((n = this._invokeOne(function (r) {
                return r != this && r.getDependency && r.getDependency(e, t);
              })),
              !n)
            )
              throw new Error("Unknown type: " + e);
        }
        this.cache.add(r, n);
      }
      return n;
    }
    getDependencies(e) {
      let t = this.cache.get(e);
      if (!t) {
        const r = this,
          n = this.json[e + ("mesh" === e ? "es" : "s")] || [];
        (t = Promise.all(
          n.map(function (t, n) {
            return r.getDependency(e, n);
          })
        )),
          this.cache.add(e, t);
      }
      return t;
    }
    loadBuffer(e) {
      const t = this.json.buffers[e],
        r = this.fileLoader;
      if (t.type && "arraybuffer" !== t.type)
        throw new Error(
          "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
        );
      if (void 0 === t.uri && 0 === e)
        return Promise.resolve(this.extensions[ll.KHR_BINARY_GLTF].body);
      const n = this.options;
      return new Promise(function (e, i) {
        r.load(Ka.resolveURL(t.uri, n.path), e, void 0, function () {
          i(
            new Error(
              'THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'
            )
          );
        });
      });
    }
    loadBufferView(e) {
      const t = this.json.bufferViews[e];
      return this.getDependency("buffer", t.buffer).then(function (e) {
        const r = t.byteLength || 0,
          n = t.byteOffset || 0;
        return e.slice(n, n + r);
      });
    }
    loadAccessor(e) {
      const t = this,
        r = this.json,
        n = this.json.accessors[e];
      if (void 0 === n.bufferView && void 0 === n.sparse) {
        const e = Bl[n.type],
          t = Ul[n.componentType],
          r = !0 === n.normalized,
          i = new t(n.count * e);
        return Promise.resolve(new Ur(i, e, r));
      }
      const i = [];
      return (
        void 0 !== n.bufferView
          ? i.push(this.getDependency("bufferView", n.bufferView))
          : i.push(null),
        void 0 !== n.sparse &&
          (i.push(
            this.getDependency("bufferView", n.sparse.indices.bufferView)
          ),
          i.push(this.getDependency("bufferView", n.sparse.values.bufferView))),
        Promise.all(i).then(function (e) {
          const i = e[0],
            o = Bl[n.type],
            s = Ul[n.componentType],
            a = s.BYTES_PER_ELEMENT,
            l = a * o,
            c = n.byteOffset || 0,
            u =
              void 0 !== n.bufferView
                ? r.bufferViews[n.bufferView].byteStride
                : void 0,
            h = !0 === n.normalized;
          let d, p;
          if (u && u !== l) {
            const e = Math.floor(c / u),
              r =
                "InterleavedBuffer:" +
                n.bufferView +
                ":" +
                n.componentType +
                ":" +
                e +
                ":" +
                n.count;
            let l = t.cache.get(r);
            l ||
              ((d = new s(i, e * u, (n.count * u) / a)),
              (l = new fs(d, u / a)),
              t.cache.add(r, l)),
              (p = new gs(l, o, (c % u) / a, h));
          } else (d = null === i ? new s(n.count * o) : new s(i, c, n.count * o)), (p = new Ur(d, o, h));
          if (void 0 !== n.sparse) {
            const t = Bl.SCALAR,
              r = Ul[n.sparse.indices.componentType],
              a = n.sparse.indices.byteOffset || 0,
              l = n.sparse.values.byteOffset || 0,
              c = new r(e[1], a, n.sparse.count * t),
              u = new s(e[2], l, n.sparse.count * o);
            null !== i &&
              (p = new Ur(p.array.slice(), p.itemSize, p.normalized));
            for (let e = 0, t = c.length; e < t; e++) {
              const t = c[e];
              if (
                (p.setX(t, u[e * o]),
                o >= 2 && p.setY(t, u[e * o + 1]),
                o >= 3 && p.setZ(t, u[e * o + 2]),
                o >= 4 && p.setW(t, u[e * o + 3]),
                o >= 5)
              )
                throw new Error(
                  "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                );
            }
          }
          return p;
        })
      );
    }
    loadTexture(e) {
      const t = this.json,
        r = this.options,
        n = t.textures[e].source,
        i = t.images[n];
      let o = this.textureLoader;
      if (i.uri) {
        const e = r.manager.getHandler(i.uri);
        null !== e && (o = e);
      }
      return this.loadTextureImage(e, n, o);
    }
    loadTextureImage(e, t, r) {
      const n = this,
        i = this.json,
        o = i.textures[e],
        s = i.images[t],
        a = (s.uri || s.bufferView) + ":" + o.sampler;
      if (this.textureCache[a]) return this.textureCache[a];
      const l = this.loadImageSource(t, r)
        .then(function (t) {
          (t.flipY = !1),
            (t.name = o.name || s.name || ""),
            "" === t.name &&
              "string" == typeof s.uri &&
              !1 === s.uri.startsWith("data:image/") &&
              (t.name = s.uri);
          const r = (i.samplers || {})[o.sampler] || {};
          return (
            (t.magFilter = Dl[r.magFilter] || O),
            (t.minFilter = Dl[r.minFilter] || U),
            (t.wrapS = kl[r.wrapS] || A),
            (t.wrapT = kl[r.wrapT] || A),
            n.associations.set(t, { textures: e }),
            t
          );
        })
        .catch(function () {
          return null;
        });
      return (this.textureCache[a] = l), l;
    }
    loadImageSource(e, t) {
      const r = this.json,
        n = this.options;
      if (void 0 !== this.sourceCache[e])
        return this.sourceCache[e].then((e) => e.clone());
      const i = r.images[e],
        o = self.URL || self.webkitURL;
      let s = i.uri || "",
        a = !1;
      if (void 0 !== i.bufferView)
        s = this.getDependency("bufferView", i.bufferView).then(function (e) {
          a = !0;
          const t = new Blob([e], { type: i.mimeType });
          return (s = o.createObjectURL(t)), s;
        });
      else if (void 0 === i.uri)
        throw new Error(
          "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
        );
      const l = Promise.resolve(s)
        .then(function (e) {
          return new Promise(function (r, i) {
            let o = r;
            !0 === t.isImageBitmapLoader &&
              (o = function (e) {
                const t = new nt(e);
                (t.needsUpdate = !0), r(t);
              }),
              t.load(Ka.resolveURL(e, n.path), o, void 0, i);
          });
        })
        .then(function (e) {
          var t;
          return (
            !0 === a && o.revokeObjectURL(s),
            (e.userData.mimeType =
              i.mimeType ||
              ((t = i.uri).search(/\.jpe?g($|\?)/i) > 0 ||
              0 === t.search(/^data\:image\/jpeg/)
                ? "image/jpeg"
                : t.search(/\.webp($|\?)/i) > 0 ||
                  0 === t.search(/^data\:image\/webp/)
                ? "image/webp"
                : "image/png")),
            e
          );
        })
        .catch(function (e) {
          throw (
            (console.error("THREE.GLTFLoader: Couldn't load texture", s), e)
          );
        });
      return (this.sourceCache[e] = l), l;
    }
    assignTexture(e, t, r, n) {
      const i = this;
      return this.getDependency("texture", r.index).then(function (o) {
        if (!o) return null;
        if (
          (void 0 !== r.texCoord &&
            r.texCoord > 0 &&
            ((o = o.clone()).channel = r.texCoord),
          i.extensions[ll.KHR_TEXTURE_TRANSFORM])
        ) {
          const e =
            void 0 !== r.extensions
              ? r.extensions[ll.KHR_TEXTURE_TRANSFORM]
              : void 0;
          if (e) {
            const t = i.associations.get(o);
            (o = i.extensions[ll.KHR_TEXTURE_TRANSFORM].extendTexture(o, e)),
              i.associations.set(o, t);
          }
        }
        return void 0 !== n && (o.colorSpace = n), (e[t] = o), o;
      });
    }
    assignFinalMaterial(e) {
      const t = e.geometry;
      let r = e.material;
      const n = void 0 === t.attributes.tangent,
        i = void 0 !== t.attributes.color,
        o = void 0 === t.attributes.normal;
      if (e.isPoints) {
        const e = "PointsMaterial:" + r.uuid;
        let t = this.cache.get(e);
        t ||
          ((t = new Js()),
          Ir.prototype.copy.call(t, r),
          t.color.copy(r.color),
          (t.map = r.map),
          (t.sizeAttenuation = !1),
          this.cache.add(e, t)),
          (r = t);
      } else if (e.isLine) {
        const e = "LineBasicMaterial:" + r.uuid;
        let t = this.cache.get(e);
        t ||
          ((t = new zs()),
          Ir.prototype.copy.call(t, r),
          t.color.copy(r.color),
          (t.map = r.map),
          this.cache.add(e, t)),
          (r = t);
      }
      if (n || i || o) {
        let e = "ClonedMaterial:" + r.uuid + ":";
        n && (e += "derivative-tangents:"),
          i && (e += "vertex-colors:"),
          o && (e += "flat-shading:");
        let t = this.cache.get(e);
        t ||
          ((t = r.clone()),
          i && (t.vertexColors = !0),
          o && (t.flatShading = !0),
          n &&
            (t.normalScale && (t.normalScale.y *= -1),
            t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
          this.cache.add(e, t),
          this.associations.set(t, this.associations.get(r))),
          (r = t);
      }
      e.material = r;
    }
    getMaterialType() {
      return sa;
    }
    loadMaterial(e) {
      const t = this,
        r = this.json,
        n = this.extensions,
        i = r.materials[e];
      let o;
      const s = {},
        a = [];
      if ((i.extensions || {})[ll.KHR_MATERIALS_UNLIT]) {
        const e = n[ll.KHR_MATERIALS_UNLIT];
        (o = e.getMaterialType()), a.push(e.extendParams(s, i, t));
      } else {
        const r = i.pbrMetallicRoughness || {};
        if (
          ((s.color = new Rr(1, 1, 1)),
          (s.opacity = 1),
          Array.isArray(r.baseColorFactor))
        ) {
          const e = r.baseColorFactor;
          s.color.setRGB(e[0], e[1], e[2], re), (s.opacity = e[3]);
        }
        void 0 !== r.baseColorTexture &&
          a.push(t.assignTexture(s, "map", r.baseColorTexture, te)),
          (s.metalness = void 0 !== r.metallicFactor ? r.metallicFactor : 1),
          (s.roughness = void 0 !== r.roughnessFactor ? r.roughnessFactor : 1),
          void 0 !== r.metallicRoughnessTexture &&
            (a.push(
              t.assignTexture(s, "metalnessMap", r.metallicRoughnessTexture)
            ),
            a.push(
              t.assignTexture(s, "roughnessMap", r.metallicRoughnessTexture)
            )),
          (o = this._invokeOne(function (t) {
            return t.getMaterialType && t.getMaterialType(e);
          })),
          a.push(
            Promise.all(
              this._invokeAll(function (t) {
                return t.extendMaterialParams && t.extendMaterialParams(e, s);
              })
            )
          );
      }
      !0 === i.doubleSided && (s.side = 2);
      const l = i.alphaMode || "OPAQUE";
      if (
        ("BLEND" === l
          ? ((s.transparent = !0), (s.depthWrite = !1))
          : ((s.transparent = !1),
            "MASK" === l &&
              (s.alphaTest = void 0 !== i.alphaCutoff ? i.alphaCutoff : 0.5)),
        void 0 !== i.normalTexture &&
          o !== Lr &&
          (a.push(t.assignTexture(s, "normalMap", i.normalTexture)),
          (s.normalScale = new De(1, 1)),
          void 0 !== i.normalTexture.scale))
      ) {
        const e = i.normalTexture.scale;
        s.normalScale.set(e, e);
      }
      if (
        (void 0 !== i.occlusionTexture &&
          o !== Lr &&
          (a.push(t.assignTexture(s, "aoMap", i.occlusionTexture)),
          void 0 !== i.occlusionTexture.strength &&
            (s.aoMapIntensity = i.occlusionTexture.strength)),
        void 0 !== i.emissiveFactor && o !== Lr)
      ) {
        const e = i.emissiveFactor;
        s.emissive = new Rr().setRGB(e[0], e[1], e[2], re);
      }
      return (
        void 0 !== i.emissiveTexture &&
          o !== Lr &&
          a.push(t.assignTexture(s, "emissiveMap", i.emissiveTexture, te)),
        Promise.all(a).then(function () {
          const r = new o(s);
          return (
            i.name && (r.name = i.name),
            Wl(r, i),
            t.associations.set(r, { materials: e }),
            i.extensions && jl(n, r, i),
            r
          );
        })
      );
    }
    createUniqueName(e) {
      const t = nl.sanitizeNodeName(e || "");
      return t in this.nodeNamesUsed
        ? t + "_" + ++this.nodeNamesUsed[t]
        : ((this.nodeNamesUsed[t] = 0), t);
    }
    loadGeometries(e) {
      const t = this,
        r = this.extensions,
        n = this.primitiveCache;
      function i(e) {
        return r[ll.KHR_DRACO_MESH_COMPRESSION]
          .decodePrimitive(e, t)
          .then(function (r) {
            return Ql(r, e, t);
          });
      }
      const o = [];
      for (let r = 0, s = e.length; r < s; r++) {
        const s = e[r],
          a = Xl(s),
          l = n[a];
        if (l) o.push(l.promise);
        else {
          let e;
          (e =
            s.extensions && s.extensions[ll.KHR_DRACO_MESH_COMPRESSION]
              ? i(s)
              : Ql(new Xr(), s, t)),
            (n[a] = { primitive: s, promise: e }),
            o.push(e);
        }
      }
      return Promise.all(o);
    }
    loadMesh(e) {
      const t = this,
        r = this.json,
        n = this.extensions,
        i = r.meshes[e],
        o = i.primitives,
        s = [];
      for (let e = 0, t = o.length; e < t; e++) {
        const t =
          void 0 === o[e].material
            ? Vl(this.cache)
            : this.getDependency("material", o[e].material);
        s.push(t);
      }
      return (
        s.push(t.loadGeometries(o)),
        Promise.all(s).then(function (r) {
          const s = r.slice(0, r.length - 1),
            a = r[r.length - 1],
            l = [];
          for (let r = 0, c = a.length; r < c; r++) {
            const c = a[r],
              u = o[r];
            let h;
            const d = s[r];
            if (
              u.mode === Nl.TRIANGLES ||
              u.mode === Nl.TRIANGLE_STRIP ||
              u.mode === Nl.TRIANGLE_FAN ||
              void 0 === u.mode
            )
              (h = !0 === i.isSkinnedMesh ? new Ts(c, d) : new hn(c, d)),
                !0 === h.isSkinnedMesh && h.normalizeSkinWeights(),
                u.mode === Nl.TRIANGLE_STRIP
                  ? (h.geometry = ol(h.geometry, 1))
                  : u.mode === Nl.TRIANGLE_FAN &&
                    (h.geometry = ol(h.geometry, 2));
            else if (u.mode === Nl.LINES) h = new $s(c, d);
            else if (u.mode === Nl.LINE_STRIP) h = new qs(c, d);
            else if (u.mode === Nl.LINE_LOOP) h = new Qs(c, d);
            else {
              if (u.mode !== Nl.POINTS)
                throw new Error(
                  "THREE.GLTFLoader: Primitive mode unsupported: " + u.mode
                );
              h = new na(c, d);
            }
            Object.keys(h.geometry.morphAttributes).length > 0 && Gl(h, i),
              (h.name = t.createUniqueName(i.name || "mesh_" + e)),
              Wl(h, i),
              u.extensions && jl(n, h, u),
              t.assignFinalMaterial(h),
              l.push(h);
          }
          for (let r = 0, n = l.length; r < n; r++)
            t.associations.set(l[r], { meshes: e, primitives: r });
          if (1 === l.length) return i.extensions && jl(n, l[0], i), l[0];
          const c = new as();
          i.extensions && jl(n, c, i), t.associations.set(c, { meshes: e });
          for (let e = 0, t = l.length; e < t; e++) c.add(l[e]);
          return c;
        })
      );
    }
    loadCamera(e) {
      let t;
      const r = this.json.cameras[e],
        n = r[r.type];
      if (n)
        return (
          "perspective" === r.type
            ? (t = new bn(
                Ue(n.yfov),
                n.aspectRatio || 1,
                n.znear || 1,
                n.zfar || 2e6
              ))
            : "orthographic" === r.type &&
              (t = new Gn(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)),
          r.name && (t.name = this.createUniqueName(r.name)),
          Wl(t, r),
          Promise.resolve(t)
        );
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
    }
    loadSkin(e) {
      const t = this.json.skins[e],
        r = [];
      for (let e = 0, n = t.joints.length; e < n; e++)
        r.push(this._loadNodeShallow(t.joints[e]));
      return (
        void 0 !== t.inverseBindMatrices
          ? r.push(this.getDependency("accessor", t.inverseBindMatrices))
          : r.push(null),
        Promise.all(r).then(function (e) {
          const r = e.pop(),
            n = e,
            i = [],
            o = [];
          for (let e = 0, s = n.length; e < s; e++) {
            const s = n[e];
            if (s) {
              i.push(s);
              const t = new Ht();
              null !== r && t.fromArray(r.array, 16 * e), o.push(t);
            } else
              console.warn(
                'THREE.GLTFLoader: Joint "%s" could not be found.',
                t.joints[e]
              );
          }
          return new Is(i, o);
        })
      );
    }
    loadAnimation(e) {
      const t = this.json,
        r = this,
        n = t.animations[e],
        i = n.name ? n.name : "animation_" + e,
        o = [],
        s = [],
        a = [],
        l = [],
        c = [];
      for (let e = 0, t = n.channels.length; e < t; e++) {
        const t = n.channels[e],
          r = n.samplers[t.sampler],
          i = t.target,
          u = i.node,
          h = void 0 !== n.parameters ? n.parameters[r.input] : r.input,
          d = void 0 !== n.parameters ? n.parameters[r.output] : r.output;
        void 0 !== i.node &&
          (o.push(this.getDependency("node", u)),
          s.push(this.getDependency("accessor", h)),
          a.push(this.getDependency("accessor", d)),
          l.push(r),
          c.push(i));
      }
      return Promise.all([
        Promise.all(o),
        Promise.all(s),
        Promise.all(a),
        Promise.all(l),
        Promise.all(c),
      ]).then(function (e) {
        const t = e[0],
          n = e[1],
          o = e[2],
          s = e[3],
          a = e[4],
          l = [];
        for (let e = 0, i = t.length; e < i; e++) {
          const i = t[e],
            c = n[e],
            u = o[e],
            h = s[e],
            d = a[e];
          if (void 0 === i) continue;
          i.updateMatrix && i.updateMatrix();
          const p = r._createAnimationTracks(i, c, u, h, d);
          if (p) for (let e = 0; e < p.length; e++) l.push(p[e]);
        }
        return new Ea(i, void 0, l);
      });
    }
    createNodeMesh(e) {
      const t = this.json,
        r = this,
        n = t.nodes[e];
      return void 0 === n.mesh
        ? null
        : r.getDependency("mesh", n.mesh).then(function (e) {
            const t = r._getNodeRef(r.meshCache, n.mesh, e);
            return (
              void 0 !== n.weights &&
                t.traverse(function (e) {
                  if (e.isMesh)
                    for (let t = 0, r = n.weights.length; t < r; t++)
                      e.morphTargetInfluences[t] = n.weights[t];
                }),
              t
            );
          });
    }
    loadNode(e) {
      const t = this,
        r = this.json.nodes[e],
        n = t._loadNodeShallow(e),
        i = [],
        o = r.children || [];
      for (let e = 0, r = o.length; e < r; e++)
        i.push(t.getDependency("node", o[e]));
      const s =
        void 0 === r.skin
          ? Promise.resolve(null)
          : t.getDependency("skin", r.skin);
      return Promise.all([n, Promise.all(i), s]).then(function (e) {
        const t = e[0],
          r = e[1],
          n = e[2];
        null !== n &&
          t.traverse(function (e) {
            e.isSkinnedMesh && e.bind(n, Kl);
          });
        for (let e = 0, n = r.length; e < n; e++) t.add(r[e]);
        return t;
      });
    }
    _loadNodeShallow(e) {
      const t = this.json,
        r = this.extensions,
        n = this;
      if (void 0 !== this.nodeCache[e]) return this.nodeCache[e];
      const i = t.nodes[e],
        o = i.name ? n.createUniqueName(i.name) : "",
        s = [],
        a = n._invokeOne(function (t) {
          return t.createNodeMesh && t.createNodeMesh(e);
        });
      return (
        a && s.push(a),
        void 0 !== i.camera &&
          s.push(
            n.getDependency("camera", i.camera).then(function (e) {
              return n._getNodeRef(n.cameraCache, i.camera, e);
            })
          ),
        n
          ._invokeAll(function (t) {
            return t.createNodeAttachment && t.createNodeAttachment(e);
          })
          .forEach(function (e) {
            s.push(e);
          }),
        (this.nodeCache[e] = Promise.all(s).then(function (t) {
          let s;
          if (
            ((s =
              !0 === i.isBone
                ? new As()
                : t.length > 1
                ? new as()
                : 1 === t.length
                ? t[0]
                : new hr()),
            s !== t[0])
          )
            for (let e = 0, r = t.length; e < r; e++) s.add(t[e]);
          if (
            (i.name && ((s.userData.name = i.name), (s.name = o)),
            Wl(s, i),
            i.extensions && jl(r, s, i),
            void 0 !== i.matrix)
          ) {
            const e = new Ht();
            e.fromArray(i.matrix), s.applyMatrix4(e);
          } else void 0 !== i.translation && s.position.fromArray(i.translation), void 0 !== i.rotation && s.quaternion.fromArray(i.rotation), void 0 !== i.scale && s.scale.fromArray(i.scale);
          return (
            n.associations.has(s) || n.associations.set(s, {}),
            (n.associations.get(s).nodes = e),
            s
          );
        })),
        this.nodeCache[e]
      );
    }
    loadScene(e) {
      const t = this.extensions,
        r = this.json.scenes[e],
        n = this,
        i = new as();
      r.name && (i.name = n.createUniqueName(r.name)),
        Wl(i, r),
        r.extensions && jl(t, i, r);
      const o = r.nodes || [],
        s = [];
      for (let e = 0, t = o.length; e < t; e++)
        s.push(n.getDependency("node", o[e]));
      return Promise.all(s).then(function (e) {
        for (let t = 0, r = e.length; t < r; t++) i.add(e[t]);
        return (
          (n.associations = ((e) => {
            const t = new Map();
            for (const [e, r] of n.associations)
              (e instanceof Ir || e instanceof nt) && t.set(e, r);
            return (
              e.traverse((e) => {
                const r = n.associations.get(e);
                null != r && t.set(e, r);
              }),
              t
            );
          })(i)),
          i
        );
      });
    }
    _createAnimationTracks(e, t, r, n, i) {
      const o = [],
        s = e.name ? e.name : e.uuid,
        a = [];
      let l;
      switch (
        (Hl[i.path] === Hl.weights
          ? e.traverse(function (e) {
              e.morphTargetInfluences && a.push(e.name ? e.name : e.uuid);
            })
          : a.push(s),
        Hl[i.path])
      ) {
        case Hl.weights:
          l = ya;
          break;
        case Hl.rotation:
          l = xa;
          break;
        case Hl.position:
        case Hl.scale:
          l = Sa;
          break;
        default:
          l = 1 === r.itemSize ? ya : Sa;
      }
      const c = void 0 !== n.interpolation ? zl[n.interpolation] : Q,
        u = this._getArrayFromAccessor(r);
      for (let e = 0, r = a.length; e < r; e++) {
        const r = new l(a[e] + "." + Hl[i.path], t.array, u, c);
        "CUBICSPLINE" === n.interpolation &&
          this._createCubicSplineTrackInterpolant(r),
          o.push(r);
      }
      return o;
    }
    _getArrayFromAccessor(e) {
      let t = e.array;
      if (e.normalized) {
        const e = Yl(t.constructor),
          r = new Float32Array(t.length);
        for (let n = 0, i = t.length; n < i; n++) r[n] = t[n] * e;
        t = r;
      }
      return t;
    }
    _createCubicSplineTrackInterpolant(e) {
      (e.createInterpolant = function (e) {
        return new (this instanceof xa ? Ol : Il)(
          this.times,
          this.values,
          this.getValueSize() / 3,
          e
        );
      }),
        (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0);
    }
  }
  function Ql(e, t, r) {
    const n = t.attributes,
      i = [];
    function o(t, n) {
      return r.getDependency("accessor", t).then(function (t) {
        e.setAttribute(n, t);
      });
    }
    for (const t in n) {
      const r = Fl[t] || t.toLowerCase();
      r in e.attributes || i.push(o(n[t], r));
    }
    if (void 0 !== t.indices && !e.index) {
      const n = r.getDependency("accessor", t.indices).then(function (t) {
        e.setIndex(t);
      });
      i.push(n);
    }
    return (
      Ye.workingColorSpace !== re &&
        "COLOR_0" in n &&
        console.warn(
          `THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Ye.workingColorSpace}" not supported.`
        ),
      Wl(e, t),
      (function (e, t, r) {
        const n = t.attributes,
          i = new pt();
        if (void 0 === n.POSITION) return;
        {
          const e = r.json.accessors[n.POSITION],
            t = e.min,
            o = e.max;
          if (void 0 === t || void 0 === o)
            return void console.warn(
              "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
            );
          if (
            (i.set(new ut(t[0], t[1], t[2]), new ut(o[0], o[1], o[2])),
            e.normalized)
          ) {
            const t = Yl(Ul[e.componentType]);
            i.min.multiplyScalar(t), i.max.multiplyScalar(t);
          }
        }
        const o = t.targets;
        if (void 0 !== o) {
          const e = new ut(),
            t = new ut();
          for (let n = 0, i = o.length; n < i; n++) {
            const i = o[n];
            if (void 0 !== i.POSITION) {
              const n = r.json.accessors[i.POSITION],
                o = n.min,
                s = n.max;
              if (void 0 !== o && void 0 !== s) {
                if (
                  (t.setX(Math.max(Math.abs(o[0]), Math.abs(s[0]))),
                  t.setY(Math.max(Math.abs(o[1]), Math.abs(s[1]))),
                  t.setZ(Math.max(Math.abs(o[2]), Math.abs(s[2]))),
                  n.normalized)
                ) {
                  const e = Yl(Ul[n.componentType]);
                  t.multiplyScalar(e);
                }
                e.max(t);
              } else
                console.warn(
                  "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                );
            }
          }
          i.expandByVector(e);
        }
        e.boundingBox = i;
        const s = new It();
        i.getCenter(s.center),
          (s.radius = i.min.distanceTo(i.max) / 2),
          (e.boundingSphere = s);
      })(e, t, r),
      Promise.all(i).then(function () {
        return void 0 !== t.targets
          ? (function (e, t, r) {
              let n = !1,
                i = !1,
                o = !1;
              for (let e = 0, r = t.length; e < r; e++) {
                const r = t[e];
                if (
                  (void 0 !== r.POSITION && (n = !0),
                  void 0 !== r.NORMAL && (i = !0),
                  void 0 !== r.COLOR_0 && (o = !0),
                  n && i && o)
                )
                  break;
              }
              if (!n && !i && !o) return Promise.resolve(e);
              const s = [],
                a = [],
                l = [];
              for (let c = 0, u = t.length; c < u; c++) {
                const u = t[c];
                if (n) {
                  const t =
                    void 0 !== u.POSITION
                      ? r.getDependency("accessor", u.POSITION)
                      : e.attributes.position;
                  s.push(t);
                }
                if (i) {
                  const t =
                    void 0 !== u.NORMAL
                      ? r.getDependency("accessor", u.NORMAL)
                      : e.attributes.normal;
                  a.push(t);
                }
                if (o) {
                  const t =
                    void 0 !== u.COLOR_0
                      ? r.getDependency("accessor", u.COLOR_0)
                      : e.attributes.color;
                  l.push(t);
                }
              }
              return Promise.all([
                Promise.all(s),
                Promise.all(a),
                Promise.all(l),
              ]).then(function (t) {
                const r = t[0],
                  s = t[1],
                  a = t[2];
                return (
                  n && (e.morphAttributes.position = r),
                  i && (e.morphAttributes.normal = s),
                  o && (e.morphAttributes.color = a),
                  (e.morphTargetsRelative = !0),
                  e
                );
              });
            })(e, t.targets, r)
          : e;
      })
    );
  }
  const Jl = {
    Handedness: Object.freeze({ NONE: "none", LEFT: "left", RIGHT: "right" }),
    ComponentState: Object.freeze({
      DEFAULT: "default",
      TOUCHED: "touched",
      PRESSED: "pressed",
    }),
    ComponentProperty: Object.freeze({
      BUTTON: "button",
      X_AXIS: "xAxis",
      Y_AXIS: "yAxis",
      STATE: "state",
    }),
    ComponentType: Object.freeze({
      TRIGGER: "trigger",
      SQUEEZE: "squeeze",
      TOUCHPAD: "touchpad",
      THUMBSTICK: "thumbstick",
      BUTTON: "button",
    }),
    ButtonTouchThreshold: 0.05,
    AxisTouchThreshold: 0.1,
    VisualResponseProperty: Object.freeze({
      TRANSFORM: "transform",
      VISIBILITY: "visibility",
    }),
  };
  async function Zl(e) {
    const t = await fetch(e);
    if (t.ok) return t.json();
    throw new Error(t.statusText);
  }
  const ec = {
    xAxis: 0,
    yAxis: 0,
    button: 0,
    state: Jl.ComponentState.DEFAULT,
  };
  class tc {
    constructor(e) {
      (this.componentProperty = e.componentProperty),
        (this.states = e.states),
        (this.valueNodeName = e.valueNodeName),
        (this.valueNodeProperty = e.valueNodeProperty),
        this.valueNodeProperty === Jl.VisualResponseProperty.TRANSFORM &&
          ((this.minNodeName = e.minNodeName),
          (this.maxNodeName = e.maxNodeName)),
        (this.value = 0),
        this.updateFromComponent(ec);
    }
    updateFromComponent({ xAxis: e, yAxis: t, button: r, state: n }) {
      const { normalizedXAxis: i, normalizedYAxis: o } = (function (
        e = 0,
        t = 0
      ) {
        let r = e,
          n = t;
        if (Math.sqrt(e * e + t * t) > 1) {
          const i = Math.atan2(t, e);
          (r = Math.cos(i)), (n = Math.sin(i));
        }
        return {
          normalizedXAxis: 0.5 * r + 0.5,
          normalizedYAxis: 0.5 * n + 0.5,
        };
      })(e, t);
      switch (this.componentProperty) {
        case Jl.ComponentProperty.X_AXIS:
          this.value = this.states.includes(n) ? i : 0.5;
          break;
        case Jl.ComponentProperty.Y_AXIS:
          this.value = this.states.includes(n) ? o : 0.5;
          break;
        case Jl.ComponentProperty.BUTTON:
          this.value = this.states.includes(n) ? r : 0;
          break;
        case Jl.ComponentProperty.STATE:
          this.valueNodeProperty === Jl.VisualResponseProperty.VISIBILITY
            ? (this.value = this.states.includes(n))
            : (this.value = this.states.includes(n) ? 1 : 0);
          break;
        default:
          throw new Error(
            `Unexpected visualResponse componentProperty ${this.componentProperty}`
          );
      }
    }
  }
  class rc {
    constructor(e, t) {
      if (
        !(
          e &&
          t &&
          t.visualResponses &&
          t.gamepadIndices &&
          0 !== Object.keys(t.gamepadIndices).length
        )
      )
        throw new Error("Invalid arguments supplied");
      (this.id = e),
        (this.type = t.type),
        (this.rootNodeName = t.rootNodeName),
        (this.touchPointNodeName = t.touchPointNodeName),
        (this.visualResponses = {}),
        Object.keys(t.visualResponses).forEach((e) => {
          const r = new tc(t.visualResponses[e]);
          this.visualResponses[e] = r;
        }),
        (this.gamepadIndices = Object.assign({}, t.gamepadIndices)),
        (this.values = {
          state: Jl.ComponentState.DEFAULT,
          button: void 0 !== this.gamepadIndices.button ? 0 : void 0,
          xAxis: void 0 !== this.gamepadIndices.xAxis ? 0 : void 0,
          yAxis: void 0 !== this.gamepadIndices.yAxis ? 0 : void 0,
        });
    }
    get data() {
      return { id: this.id, ...this.values };
    }
    updateFromGamepad(e) {
      if (
        ((this.values.state = Jl.ComponentState.DEFAULT),
        void 0 !== this.gamepadIndices.button &&
          e.buttons.length > this.gamepadIndices.button)
      ) {
        const t = e.buttons[this.gamepadIndices.button];
        (this.values.button = t.value),
          (this.values.button =
            this.values.button < 0 ? 0 : this.values.button),
          (this.values.button =
            this.values.button > 1 ? 1 : this.values.button),
          t.pressed || 1 === this.values.button
            ? (this.values.state = Jl.ComponentState.PRESSED)
            : (t.touched || this.values.button > Jl.ButtonTouchThreshold) &&
              (this.values.state = Jl.ComponentState.TOUCHED);
      }
      void 0 !== this.gamepadIndices.xAxis &&
        e.axes.length > this.gamepadIndices.xAxis &&
        ((this.values.xAxis = e.axes[this.gamepadIndices.xAxis]),
        (this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis),
        (this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis),
        this.values.state === Jl.ComponentState.DEFAULT &&
          Math.abs(this.values.xAxis) > Jl.AxisTouchThreshold &&
          (this.values.state = Jl.ComponentState.TOUCHED)),
        void 0 !== this.gamepadIndices.yAxis &&
          e.axes.length > this.gamepadIndices.yAxis &&
          ((this.values.yAxis = e.axes[this.gamepadIndices.yAxis]),
          (this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis),
          (this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis),
          this.values.state === Jl.ComponentState.DEFAULT &&
            Math.abs(this.values.yAxis) > Jl.AxisTouchThreshold &&
            (this.values.state = Jl.ComponentState.TOUCHED)),
        Object.values(this.visualResponses).forEach((e) => {
          e.updateFromComponent(this.values);
        });
    }
  }
  class nc {
    constructor(e, t, r) {
      if (!e) throw new Error("No xrInputSource supplied");
      if (!t) throw new Error("No profile supplied");
      (this.xrInputSource = e),
        (this.assetUrl = r),
        (this.id = t.profileId),
        (this.layoutDescription = t.layouts[e.handedness]),
        (this.components = {}),
        Object.keys(this.layoutDescription.components).forEach((e) => {
          const t = this.layoutDescription.components[e];
          this.components[e] = new rc(e, t);
        }),
        this.updateFromGamepad();
    }
    get gripSpace() {
      return this.xrInputSource.gripSpace;
    }
    get targetRaySpace() {
      return this.xrInputSource.targetRaySpace;
    }
    get data() {
      const e = [];
      return (
        Object.values(this.components).forEach((t) => {
          e.push(t.data);
        }),
        e
      );
    }
    updateFromGamepad() {
      Object.values(this.components).forEach((e) => {
        e.updateFromGamepad(this.xrInputSource.gamepad);
      });
    }
  }
  class ic extends hr {
    constructor() {
      super(), (this.motionController = null), (this.envMap = null);
    }
    setEnvironmentMap(e) {
      return (
        this.envMap == e ||
          ((this.envMap = e),
          this.traverse((e) => {
            e.isMesh &&
              ((e.material.envMap = this.envMap),
              (e.material.needsUpdate = !0));
          })),
        this
      );
    }
    updateMatrixWorld(e) {
      super.updateMatrixWorld(e),
        this.motionController &&
          (this.motionController.updateFromGamepad(),
          Object.values(this.motionController.components).forEach((e) => {
            Object.values(e.visualResponses).forEach((e) => {
              const {
                valueNode: t,
                minNode: r,
                maxNode: n,
                value: i,
                valueNodeProperty: o,
              } = e;
              t &&
                (o === Jl.VisualResponseProperty.VISIBILITY
                  ? (t.visible = i)
                  : o === Jl.VisualResponseProperty.TRANSFORM &&
                    (t.quaternion.slerpQuaternions(
                      r.quaternion,
                      n.quaternion,
                      i
                    ),
                    t.position.lerpVectors(r.position, n.position, i)));
            });
          }));
    }
  }
  function oc(e, t) {
    !(function (e, t) {
      Object.values(e.components).forEach((e) => {
        const { type: r, touchPointNodeName: n, visualResponses: i } = e;
        if (r === Jl.ComponentType.TOUCHPAD)
          if (((e.touchPointNode = t.getObjectByName(n)), e.touchPointNode)) {
            const t = new oa(0.001),
              r = new Lr({ color: 255 }),
              n = new hn(t, r);
            e.touchPointNode.add(n);
          } else
            console.warn(
              `Could not find touch dot, ${e.touchPointNodeName}, in touchpad component ${e.id}`
            );
        Object.values(i).forEach((e) => {
          const {
            valueNodeName: r,
            minNodeName: n,
            maxNodeName: i,
            valueNodeProperty: o,
          } = e;
          if (o === Jl.VisualResponseProperty.TRANSFORM) {
            if (
              ((e.minNode = t.getObjectByName(n)),
              (e.maxNode = t.getObjectByName(i)),
              !e.minNode)
            )
              return void console.warn(`Could not find ${n} in the model`);
            if (!e.maxNode)
              return void console.warn(`Could not find ${i} in the model`);
          }
          (e.valueNode = t.getObjectByName(r)),
            e.valueNode || console.warn(`Could not find ${r} in the model`);
        });
      });
    })(e.motionController, t),
      e.envMap &&
        t.traverse((t) => {
          t.isMesh &&
            ((t.material.envMap = e.envMap), (t.material.needsUpdate = !0));
        }),
      e.add(t);
  }
  class sc {
    constructor(e = null) {
      (this.gltfLoader = e),
        (this.path =
          "https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles"),
        (this._assetCache = {}),
        this.gltfLoader || (this.gltfLoader = new sl());
    }
    createControllerModel(e) {
      const t = new ic();
      let r = null;
      return (
        e.addEventListener("connected", (e) => {
          const n = e.data;
          "tracked-pointer" === n.targetRayMode &&
            n.gamepad &&
            (async function (e, t, r = null, n = !0) {
              if (!e) throw new Error("No xrInputSource supplied");
              if (!t) throw new Error("No basePath supplied");
              const i = await (async function (e) {
                if (!e) throw new Error("No basePath supplied");
                return await Zl(`${e}/profilesList.json`);
              })(t);
              let o;
              if (
                (e.profiles.some((e) => {
                  const r = i[e];
                  return (
                    r &&
                      (o = {
                        profileId: e,
                        profilePath: `${t}/${r.path}`,
                        deprecated: !!r.deprecated,
                      }),
                    !!o
                  );
                }),
                !o)
              ) {
                if (!r) throw new Error("No matching profile name found");
                const e = i[r];
                if (!e)
                  throw new Error(
                    `No matching profile name found and default profile "${r}" missing.`
                  );
                o = {
                  profileId: r,
                  profilePath: `${t}/${e.path}`,
                  deprecated: !!e.deprecated,
                };
              }
              const s = await Zl(o.profilePath);
              let a;
              if (n) {
                let t;
                if (
                  ((t =
                    "any" === e.handedness
                      ? s.layouts[Object.keys(s.layouts)[0]]
                      : s.layouts[e.handedness]),
                  !t)
                )
                  throw new Error(
                    `No matching handedness, ${e.handedness}, in profile ${o.profileId}`
                  );
                t.assetPath &&
                  (a = o.profilePath.replace("profile.json", t.assetPath));
              }
              return { profile: s, assetPath: a };
            })(n, this.path, "generic-trigger")
              .then(({ profile: e, assetPath: i }) => {
                t.motionController = new nc(n, e, i);
                const o = this._assetCache[t.motionController.assetUrl];
                if (o) (r = o.scene.clone()), oc(t, r);
                else {
                  if (!this.gltfLoader) throw new Error("GLTFLoader not set.");
                  this.gltfLoader.setPath(""),
                    this.gltfLoader.load(
                      t.motionController.assetUrl,
                      (e) => {
                        (this._assetCache[t.motionController.assetUrl] = e),
                          (r = e.scene.clone()),
                          oc(t, r);
                      },
                      null,
                      () => {
                        throw new Error(
                          `Asset ${t.motionController.assetUrl} missing or malformed.`
                        );
                      }
                    );
                }
              })
              .catch((e) => {
                console.warn(e);
              });
        }),
        e.addEventListener("disconnected", () => {
          (t.motionController = null), t.remove(r), (r = null);
        }),
        t
      );
    }
  }
  var ac = Object.defineProperty,
    lc = Object.getOwnPropertyDescriptor,
    cc = Object.getOwnPropertyNames,
    uc = Object.prototype.hasOwnProperty,
    hc = (e, t) => () => (e && (t = e((e = 0))), t),
    dc = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports),
    pc = (e, t) => {
      for (var r in t) ac(e, r, { get: t[r], enumerable: !0 });
    },
    fc = (e) =>
      ((e, t, r, n) => {
        if ((t && "object" == typeof t) || "function" == typeof t)
          for (let r of cc(t))
            !uc.call(e, r) &&
              undefined !== r &&
              ac(e, r, {
                get: () => t[r],
                enumerable: !(n = lc(t, r)) || n.enumerable,
              });
        return e;
      })(ac({}, "__esModule", { value: !0 }), e),
    mc = hc(() => {}),
    gc = {};
  function _c(e) {
    throw new Error(
      "Node.js process " +
        e +
        " is not supported by JSPM core outside of Node.js"
    );
  }
  function vc() {
    !Nc ||
      !Uc ||
      ((Nc = !1),
      Uc.length ? (Oc = Uc.concat(Oc)) : (Dc = -1),
      Oc.length && yc());
  }
  function yc() {
    if (!Nc) {
      var e = setTimeout(vc, 0);
      Nc = !0;
      for (var t = Oc.length; t; ) {
        for (Uc = Oc, Oc = []; ++Dc < t; ) Uc && Uc[Dc].run();
        (Dc = -1), (t = Oc.length);
      }
      (Uc = null), (Nc = !1), clearTimeout(e);
    }
  }
  function bc(e) {
    var t = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
    Oc.push(new xc(e, t)), 1 === Oc.length && !Nc && setTimeout(yc, 0);
  }
  function xc(e, t) {
    (this.fun = e), (this.array = t);
  }
  function wc() {}
  function Sc(e) {
    _c("_linkedBinding");
  }
  function Ec(e) {
    _c("dlopen");
  }
  function Mc() {
    return [];
  }
  function Tc() {
    return [];
  }
  function Ac(e, t) {
    if (!e) throw new Error(t || "assertion error");
  }
  function Rc() {
    return !1;
  }
  function Pc() {
    return Iu.now() / 1e3;
  }
  function Cc(e) {
    var t = Math.floor(0.001 * (Date.now() - Iu.now())),
      r = 0.001 * Iu.now(),
      n = Math.floor(r) + t,
      i = Math.floor((r % 1) * 1e9);
    return e && ((n -= e[0]), (i -= e[1]) < 0 && (n--, (i += Ou))), [n, i];
  }
  function Ic() {
    return Gu;
  }
  function Lc(e) {
    return [];
  }
  pc(gc, {
    _debugEnd: () => _u,
    _debugProcess: () => gu,
    _events: () => Uu,
    _eventsCount: () => Du,
    _exiting: () => tu,
    _fatalExceptions: () => pu,
    _getActiveHandles: () => Tc,
    _getActiveRequests: () => Mc,
    _kill: () => iu,
    _linkedBinding: () => Sc,
    _maxListeners: () => Nu,
    _preload_modules: () => Pu,
    _rawDebug: () => Jc,
    _startProfilerIdleNotifier: () => vu,
    _stopProfilerIdleNotifier: () => yu,
    _tickCallback: () => mu,
    abort: () => Su,
    addListener: () => ku,
    allowedNodeEnvironmentFlags: () => hu,
    arch: () => Bc,
    argv: () => zc,
    argv0: () => Ru,
    assert: () => Ac,
    binding: () => Xc,
    browser: () => Qc,
    chdir: () => Kc,
    config: () => ru,
    cpuUsage: () => ou,
    cwd: () => Yc,
    debugPort: () => Au,
    default: () => Gu,
    dlopen: () => Ec,
    domain: () => eu,
    emit: () => Vu,
    emitWarning: () => Gc,
    env: () => Hc,
    execArgv: () => Vc,
    execPath: () => Tu,
    exit: () => cu,
    features: () => du,
    hasUncaughtExceptionCaptureCallback: () => Rc,
    hrtime: () => Cc,
    kill: () => lu,
    listeners: () => Lc,
    memoryUsage: () => au,
    moduleLoadList: () => Zc,
    nextTick: () => bc,
    off: () => Fu,
    on: () => Ic,
    once: () => Bu,
    openStdin: () => uu,
    pid: () => Eu,
    platform: () => Fc,
    ppid: () => Mu,
    prependListener: () => ju,
    prependOnceListener: () => Wu,
    reallyExit: () => nu,
    release: () => $c,
    removeAllListeners: () => zu,
    removeListener: () => Hu,
    resourceUsage: () => su,
    setSourceMapsEnabled: () => Cu,
    setUncaughtExceptionCaptureCallback: () => fu,
    stderr: () => xu,
    stdin: () => wu,
    stdout: () => bu,
    title: () => kc,
    umask: () => qc,
    uptime: () => Pc,
    version: () => jc,
    versions: () => Wc,
  });
  var Oc,
    Nc,
    Uc,
    Dc,
    kc,
    Bc,
    Fc,
    Hc,
    zc,
    Vc,
    jc,
    Wc,
    Gc,
    Xc,
    qc,
    Yc,
    Kc,
    $c,
    Qc,
    Jc,
    Zc,
    eu,
    tu,
    ru,
    nu,
    iu,
    ou,
    su,
    au,
    lu,
    cu,
    uu,
    hu,
    du,
    pu,
    fu,
    mu,
    gu,
    _u,
    vu,
    yu,
    bu,
    xu,
    wu,
    Su,
    Eu,
    Mu,
    Tu,
    Au,
    Ru,
    Pu,
    Cu,
    Iu,
    Lu,
    Ou,
    Nu,
    Uu,
    Du,
    ku,
    Bu,
    Fu,
    Hu,
    zu,
    Vu,
    ju,
    Wu,
    Gu,
    Xu = hc(() => {
      mc(),
        lh(),
        qu(),
        (Oc = []),
        (Nc = !1),
        (Dc = -1),
        (xc.prototype.run = function () {
          this.fun.apply(null, this.array);
        }),
        (kc = "browser"),
        (Bc = "x64"),
        (Fc = "browser"),
        (Hc = {
          PATH: "/usr/bin",
          LANG: typeof navigator < "u" ? navigator.language + ".UTF-8" : void 0,
          PWD: "/",
          HOME: "/home",
          TMP: "/tmp",
        }),
        (zc = ["/usr/bin/node"]),
        (Vc = []),
        (jc = "v16.8.0"),
        (Wc = {}),
        (Gc = function (e, t) {
          console.warn((t ? t + ": " : "") + e);
        }),
        (Xc = function (e) {
          _c("binding");
        }),
        (qc = function (e) {
          return 0;
        }),
        (Yc = function () {
          return "/";
        }),
        (Kc = function (e) {}),
        ($c = { name: "node", sourceUrl: "", headersUrl: "", libUrl: "" }),
        (Qc = !0),
        (Jc = wc),
        (Zc = []),
        (eu = {}),
        (tu = !1),
        (ru = {}),
        (nu = wc),
        (iu = wc),
        (su = ou =
          function () {
            return {};
          }),
        (au = ou),
        (lu = wc),
        (cu = wc),
        (uu = wc),
        (hu = {}),
        (du = {
          inspector: !1,
          debug: !1,
          uv: !1,
          ipv6: !1,
          tls_alpn: !1,
          tls_sni: !1,
          tls_ocsp: !1,
          tls: !1,
          cached_builtins: !0,
        }),
        (pu = wc),
        (fu = wc),
        (mu = wc),
        (gu = wc),
        (_u = wc),
        (vu = wc),
        (yu = wc),
        (bu = void 0),
        (xu = void 0),
        (wu = void 0),
        (Su = wc),
        (Eu = 2),
        (Mu = 1),
        (Tu = "/bin/usr/node"),
        (Au = 9229),
        (Ru = "node"),
        (Pu = []),
        (Cu = wc),
        void 0 ===
          (Iu = {
            now:
              typeof performance < "u"
                ? performance.now.bind(performance)
                : void 0,
            timing: typeof performance < "u" ? performance.timing : void 0,
          }).now &&
          ((Lu = Date.now()),
          Iu.timing &&
            Iu.timing.navigationStart &&
            (Lu = Iu.timing.navigationStart),
          (Iu.now = () => Date.now() - Lu)),
        (Ou = 1e9),
        (Cc.bigint = function (e) {
          var t = Cc(e);
          return typeof BigInt > "u"
            ? t[0] * Ou + t[1]
            : BigInt(t[0] * Ou) + BigInt(t[1]);
        }),
        (Gu = {
          version: jc,
          versions: Wc,
          arch: Bc,
          platform: Fc,
          browser: Qc,
          release: $c,
          _rawDebug: Jc,
          moduleLoadList: Zc,
          binding: Xc,
          _linkedBinding: Sc,
          _events: (Uu = {}),
          _eventsCount: (Du = 0),
          _maxListeners: (Nu = 10),
          on: Ic,
          addListener: (ku = Ic),
          once: (Bu = Ic),
          off: (Fu = Ic),
          removeListener: (Hu = Ic),
          removeAllListeners: (zu = Ic),
          emit: (Vu = wc),
          prependListener: (ju = Ic),
          prependOnceListener: (Wu = Ic),
          listeners: Lc,
          domain: eu,
          _exiting: tu,
          config: ru,
          dlopen: Ec,
          uptime: Pc,
          _getActiveRequests: Mc,
          _getActiveHandles: Tc,
          reallyExit: nu,
          _kill: iu,
          cpuUsage: ou,
          resourceUsage: su,
          memoryUsage: au,
          kill: lu,
          exit: cu,
          openStdin: uu,
          allowedNodeEnvironmentFlags: hu,
          assert: Ac,
          features: du,
          _fatalExceptions: pu,
          setUncaughtExceptionCaptureCallback: fu,
          hasUncaughtExceptionCaptureCallback: Rc,
          emitWarning: Gc,
          nextTick: bc,
          _tickCallback: mu,
          _debugProcess: gu,
          _debugEnd: _u,
          _startProfilerIdleNotifier: vu,
          _stopProfilerIdleNotifier: yu,
          stdout: bu,
          stdin: wu,
          stderr: xu,
          abort: Su,
          umask: qc,
          chdir: Kc,
          cwd: Yc,
          env: Hc,
          title: kc,
          argv: zc,
          execArgv: Vc,
          pid: Eu,
          ppid: Mu,
          execPath: Tu,
          debugPort: Au,
          hrtime: Cc,
          argv0: Ru,
          _preload_modules: Pu,
          setSourceMapsEnabled: Cu,
        });
    }),
    qu = hc(() => {
      Xu();
    });
  function Yu() {
    if (eh) return Zu;
    eh = !0;
    let e = (function () {
        if ($u) return Ku;
        ($u = !0),
          (Ku.byteLength = function (e) {
            var t = o(e),
              r = t[0],
              n = t[1];
            return (3 * (r + n)) / 4 - n;
          }),
          (Ku.toByteArray = function (e) {
            var n,
              i,
              s = o(e),
              a = s[0],
              l = s[1],
              c = new r(
                (function (e, t, r) {
                  return (3 * (t + r)) / 4 - r;
                })(0, a, l)
              ),
              u = 0,
              h = l > 0 ? a - 4 : a;
            for (i = 0; i < h; i += 4)
              (n =
                (t[e.charCodeAt(i)] << 18) |
                (t[e.charCodeAt(i + 1)] << 12) |
                (t[e.charCodeAt(i + 2)] << 6) |
                t[e.charCodeAt(i + 3)]),
                (c[u++] = (n >> 16) & 255),
                (c[u++] = (n >> 8) & 255),
                (c[u++] = 255 & n);
            return (
              2 === l &&
                ((n =
                  (t[e.charCodeAt(i)] << 2) | (t[e.charCodeAt(i + 1)] >> 4)),
                (c[u++] = 255 & n)),
              1 === l &&
                ((n =
                  (t[e.charCodeAt(i)] << 10) |
                  (t[e.charCodeAt(i + 1)] << 4) |
                  (t[e.charCodeAt(i + 2)] >> 2)),
                (c[u++] = (n >> 8) & 255),
                (c[u++] = 255 & n)),
              c
            );
          }),
          (Ku.fromByteArray = function (t) {
            for (
              var r,
                n = t.length,
                i = n % 3,
                o = [],
                s = 16383,
                l = 0,
                c = n - i;
              l < c;
              l += s
            )
              o.push(a(t, l, l + s > c ? c : l + s));
            return (
              1 === i
                ? ((r = t[n - 1]), o.push(e[r >> 2] + e[(r << 4) & 63] + "=="))
                : 2 === i &&
                  ((r = (t[n - 2] << 8) + t[n - 1]),
                  o.push(
                    e[r >> 10] + e[(r >> 4) & 63] + e[(r << 2) & 63] + "="
                  )),
              o.join("")
            );
          });
        for (
          var e = [],
            t = [],
            r = typeof Uint8Array < "u" ? Uint8Array : Array,
            n =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            i = 0;
          i < 64;
          ++i
        )
          (e[i] = n[i]), (t[n.charCodeAt(i)] = i);
        function o(e) {
          var t = e.length;
          if (t % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var r = e.indexOf("=");
          return -1 === r && (r = t), [r, r === t ? 0 : 4 - (r % 4)];
        }
        function s(t) {
          return (
            e[(t >> 18) & 63] + e[(t >> 12) & 63] + e[(t >> 6) & 63] + e[63 & t]
          );
        }
        function a(e, t, r) {
          for (var n, i = [], o = t; o < r; o += 3)
            (n =
              ((e[o] << 16) & 16711680) +
              ((e[o + 1] << 8) & 65280) +
              (255 & e[o + 2])),
              i.push(s(n));
          return i.join("");
        }
        return (t[45] = 62), (t[95] = 63), Ku;
      })(),
      t =
        (Ju ||
          ((Ju = !0),
          (Qu.read = function (e, t, r, n, i) {
            var o,
              s,
              a = 8 * i - n - 1,
              l = (1 << a) - 1,
              c = l >> 1,
              u = -7,
              h = r ? i - 1 : 0,
              d = r ? -1 : 1,
              p = e[t + h];
            for (
              h += d, o = p & ((1 << -u) - 1), p >>= -u, u += a;
              u > 0;
              o = 256 * o + e[t + h], h += d, u -= 8
            );
            for (
              s = o & ((1 << -u) - 1), o >>= -u, u += n;
              u > 0;
              s = 256 * s + e[t + h], h += d, u -= 8
            );
            if (0 === o) o = 1 - c;
            else {
              if (o === l) return s ? NaN : (1 / 0) * (p ? -1 : 1);
              (s += Math.pow(2, n)), (o -= c);
            }
            return (p ? -1 : 1) * s * Math.pow(2, o - n);
          }),
          (Qu.write = function (e, t, r, n, i, o) {
            var s,
              a,
              l,
              c = 8 * o - i - 1,
              u = (1 << c) - 1,
              h = u >> 1,
              d = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
              p = n ? 0 : o - 1,
              f = n ? 1 : -1,
              m = t < 0 || (0 === t && 1 / t < 0) ? 1 : 0;
            for (
              t = Math.abs(t),
                isNaN(t) || t === 1 / 0
                  ? ((a = isNaN(t) ? 1 : 0), (s = u))
                  : ((s = Math.floor(Math.log(t) / Math.LN2)),
                    t * (l = Math.pow(2, -s)) < 1 && (s--, (l *= 2)),
                    (t += s + h >= 1 ? d / l : d * Math.pow(2, 1 - h)) * l >=
                      2 && (s++, (l /= 2)),
                    s + h >= u
                      ? ((a = 0), (s = u))
                      : s + h >= 1
                      ? ((a = (t * l - 1) * Math.pow(2, i)), (s += h))
                      : ((a = t * Math.pow(2, h - 1) * Math.pow(2, i)),
                        (s = 0)));
              i >= 8;
              e[r + p] = 255 & a, p += f, a /= 256, i -= 8
            );
            for (
              s = (s << i) | a, c += i;
              c > 0;
              e[r + p] = 255 & s, p += f, s /= 256, c -= 8
            );
            e[r + p - f] |= 128 * m;
          })),
        Qu),
      r =
        "function" == typeof Symbol && "function" == typeof Symbol.for
          ? Symbol.for("nodejs.util.inspect.custom")
          : null;
    (Zu.Buffer = o),
      (Zu.SlowBuffer = function (e) {
        return +e != e && (e = 0), o.alloc(+e);
      }),
      (Zu.INSPECT_MAX_BYTES = 50);
    let n = 2147483647;
    function i(e) {
      if (e > n)
        throw new RangeError(
          'The value "' + e + '" is invalid for option "size"'
        );
      let t = new Uint8Array(e);
      return Object.setPrototypeOf(t, o.prototype), t;
    }
    function o(e, t, r) {
      if ("number" == typeof e) {
        if ("string" == typeof t)
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return l(e);
      }
      return s(e, t, r);
    }
    function s(e, t, r) {
      if ("string" == typeof e)
        return (function (e, t) {
          if (
            (("string" != typeof t || "" === t) && (t = "utf8"),
            !o.isEncoding(t))
          )
            throw new TypeError("Unknown encoding: " + t);
          let r = 0 | d(e, t),
            n = i(r),
            s = n.write(e, t);
          return s !== r && (n = n.slice(0, s)), n;
        })(e, t);
      if (ArrayBuffer.isView(e))
        return (function (e) {
          if (X(e, Uint8Array)) {
            let t = new Uint8Array(e);
            return u(t.buffer, t.byteOffset, t.byteLength);
          }
          return c(e);
        })(e);
      if (null == e)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
            typeof e
        );
      if (
        X(e, ArrayBuffer) ||
        (e && X(e.buffer, ArrayBuffer)) ||
        (typeof SharedArrayBuffer < "u" &&
          (X(e, SharedArrayBuffer) || (e && X(e.buffer, SharedArrayBuffer))))
      )
        return u(e, t, r);
      if ("number" == typeof e)
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      let n = e.valueOf && e.valueOf();
      if (null != n && n !== e) return o.from(n, t, r);
      let s = (function (e) {
        if (o.isBuffer(e)) {
          let t = 0 | h(e.length),
            r = i(t);
          return 0 === r.length || e.copy(r, 0, 0, t), r;
        }
        return void 0 !== e.length
          ? "number" != typeof e.length || q(e.length)
            ? i(0)
            : c(e)
          : "Buffer" === e.type && Array.isArray(e.data)
          ? c(e.data)
          : void 0;
      })(e);
      if (s) return s;
      if (
        typeof Symbol < "u" &&
        null != Symbol.toPrimitive &&
        "function" == typeof e[Symbol.toPrimitive]
      )
        return o.from(e[Symbol.toPrimitive]("string"), t, r);
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
          typeof e
      );
    }
    function a(e) {
      if ("number" != typeof e)
        throw new TypeError('"size" argument must be of type number');
      if (e < 0)
        throw new RangeError(
          'The value "' + e + '" is invalid for option "size"'
        );
    }
    function l(e) {
      return a(e), i(e < 0 ? 0 : 0 | h(e));
    }
    function c(e) {
      let t = e.length < 0 ? 0 : 0 | h(e.length),
        r = i(t);
      for (let n = 0; n < t; n += 1) r[n] = 255 & e[n];
      return r;
    }
    function u(e, t, r) {
      if (t < 0 || e.byteLength < t)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (e.byteLength < t + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let n;
      return (
        (n =
          void 0 === t && void 0 === r
            ? new Uint8Array(e)
            : void 0 === r
            ? new Uint8Array(e, t)
            : new Uint8Array(e, t, r)),
        Object.setPrototypeOf(n, o.prototype),
        n
      );
    }
    function h(e) {
      if (e >= n)
        throw new RangeError(
          "Attempt to allocate Buffer larger than maximum size: 0x" +
            n.toString(16) +
            " bytes"
        );
      return 0 | e;
    }
    function d(e, t) {
      if (o.isBuffer(e)) return e.length;
      if (ArrayBuffer.isView(e) || X(e, ArrayBuffer)) return e.byteLength;
      if ("string" != typeof e)
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
            typeof e
        );
      let r = e.length,
        n = arguments.length > 2 && !0 === arguments[2];
      if (!n && 0 === r) return 0;
      let i = !1;
      for (;;)
        switch (t) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return j(e).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return 2 * r;
          case "hex":
            return r >>> 1;
          case "base64":
            return W(e).length;
          default:
            if (i) return n ? -1 : j(e).length;
            (t = ("" + t).toLowerCase()), (i = !0);
        }
    }
    function p(e, t, r) {
      let n = !1;
      if (
        ((void 0 === t || t < 0) && (t = 0),
        t > this.length ||
          ((void 0 === r || r > this.length) && (r = this.length), r <= 0) ||
          (r >>>= 0) <= (t >>>= 0))
      )
        return "";
      for (e || (e = "utf8"); ; )
        switch (e) {
          case "hex":
            return A(this, t, r);
          case "utf8":
          case "utf-8":
            return S(this, t, r);
          case "ascii":
            return M(this, t, r);
          case "latin1":
          case "binary":
            return T(this, t, r);
          case "base64":
            return w(this, t, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return R(this, t, r);
          default:
            if (n) throw new TypeError("Unknown encoding: " + e);
            (e = (e + "").toLowerCase()), (n = !0);
        }
    }
    function f(e, t, r) {
      let n = e[t];
      (e[t] = e[r]), (e[r] = n);
    }
    function m(e, t, r, n, i) {
      if (0 === e.length) return -1;
      if (
        ("string" == typeof r
          ? ((n = r), (r = 0))
          : r > 2147483647
          ? (r = 2147483647)
          : r < -2147483648 && (r = -2147483648),
        q((r = +r)) && (r = i ? 0 : e.length - 1),
        r < 0 && (r = e.length + r),
        r >= e.length)
      ) {
        if (i) return -1;
        r = e.length - 1;
      } else if (r < 0) {
        if (!i) return -1;
        r = 0;
      }
      if (("string" == typeof t && (t = o.from(t, n)), o.isBuffer(t)))
        return 0 === t.length ? -1 : g(e, t, r, n, i);
      if ("number" == typeof t)
        return (
          (t &= 255),
          "function" == typeof Uint8Array.prototype.indexOf
            ? i
              ? Uint8Array.prototype.indexOf.call(e, t, r)
              : Uint8Array.prototype.lastIndexOf.call(e, t, r)
            : g(e, [t], r, n, i)
        );
      throw new TypeError("val must be string, number or Buffer");
    }
    function g(e, t, r, n, i) {
      let o,
        s = 1,
        a = e.length,
        l = t.length;
      if (
        void 0 !== n &&
        ("ucs2" === (n = String(n).toLowerCase()) ||
          "ucs-2" === n ||
          "utf16le" === n ||
          "utf-16le" === n)
      ) {
        if (e.length < 2 || t.length < 2) return -1;
        (s = 2), (a /= 2), (l /= 2), (r /= 2);
      }
      function c(e, t) {
        return 1 === s ? e[t] : e.readUInt16BE(t * s);
      }
      if (i) {
        let n = -1;
        for (o = r; o < a; o++)
          if (c(e, o) === c(t, -1 === n ? 0 : o - n)) {
            if ((-1 === n && (n = o), o - n + 1 === l)) return n * s;
          } else -1 !== n && (o -= o - n), (n = -1);
      } else
        for (r + l > a && (r = a - l), o = r; o >= 0; o--) {
          let r = !0;
          for (let n = 0; n < l; n++)
            if (c(e, o + n) !== c(t, n)) {
              r = !1;
              break;
            }
          if (r) return o;
        }
      return -1;
    }
    function _(e, t, r, n) {
      r = Number(r) || 0;
      let i = e.length - r;
      n ? (n = Number(n)) > i && (n = i) : (n = i);
      let o,
        s = t.length;
      for (n > s / 2 && (n = s / 2), o = 0; o < n; ++o) {
        let n = parseInt(t.substr(2 * o, 2), 16);
        if (q(n)) return o;
        e[r + o] = n;
      }
      return o;
    }
    function v(e, t, r, n) {
      return G(j(t, e.length - r), e, r, n);
    }
    function y(e, t, r, n) {
      return G(
        (function (e) {
          let t = [];
          for (let r = 0; r < e.length; ++r) t.push(255 & e.charCodeAt(r));
          return t;
        })(t),
        e,
        r,
        n
      );
    }
    function b(e, t, r, n) {
      return G(W(t), e, r, n);
    }
    function x(e, t, r, n) {
      return G(
        (function (e, t) {
          let r,
            n,
            i,
            o = [];
          for (let s = 0; s < e.length && !((t -= 2) < 0); ++s)
            (r = e.charCodeAt(s)),
              (n = r >> 8),
              (i = r % 256),
              o.push(i),
              o.push(n);
          return o;
        })(t, e.length - r),
        e,
        r,
        n
      );
    }
    function w(t, r, n) {
      return 0 === r && n === t.length
        ? e.fromByteArray(t)
        : e.fromByteArray(t.slice(r, n));
    }
    function S(e, t, r) {
      r = Math.min(e.length, r);
      let n = [],
        i = t;
      for (; i < r; ) {
        let t = e[i],
          o = null,
          s = t > 239 ? 4 : t > 223 ? 3 : t > 191 ? 2 : 1;
        if (i + s <= r) {
          let r, n, a, l;
          switch (s) {
            case 1:
              t < 128 && (o = t);
              break;
            case 2:
              (r = e[i + 1]),
                128 == (192 & r) &&
                  ((l = ((31 & t) << 6) | (63 & r)), l > 127 && (o = l));
              break;
            case 3:
              (r = e[i + 1]),
                (n = e[i + 2]),
                128 == (192 & r) &&
                  128 == (192 & n) &&
                  ((l = ((15 & t) << 12) | ((63 & r) << 6) | (63 & n)),
                  l > 2047 && (l < 55296 || l > 57343) && (o = l));
              break;
            case 4:
              (r = e[i + 1]),
                (n = e[i + 2]),
                (a = e[i + 3]),
                128 == (192 & r) &&
                  128 == (192 & n) &&
                  128 == (192 & a) &&
                  ((l =
                    ((15 & t) << 18) |
                    ((63 & r) << 12) |
                    ((63 & n) << 6) |
                    (63 & a)),
                  l > 65535 && l < 1114112 && (o = l));
          }
        }
        null === o
          ? ((o = 65533), (s = 1))
          : o > 65535 &&
            ((o -= 65536),
            n.push(((o >>> 10) & 1023) | 55296),
            (o = 56320 | (1023 & o))),
          n.push(o),
          (i += s);
      }
      return (function (e) {
        let t = e.length;
        if (t <= E) return String.fromCharCode.apply(String, e);
        let r = "",
          n = 0;
        for (; n < t; )
          r += String.fromCharCode.apply(String, e.slice(n, (n += E)));
        return r;
      })(n);
    }
    (Zu.kMaxLength = n),
      (o.TYPED_ARRAY_SUPPORT = (function () {
        try {
          let e = new Uint8Array(1),
            t = {
              foo: function () {
                return 42;
              },
            };
          return (
            Object.setPrototypeOf(t, Uint8Array.prototype),
            Object.setPrototypeOf(e, t),
            42 === e.foo()
          );
        } catch {
          return !1;
        }
      })()),
      !o.TYPED_ARRAY_SUPPORT &&
        typeof console < "u" &&
        "function" == typeof console.error &&
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        ),
      Object.defineProperty(o.prototype, "parent", {
        enumerable: !0,
        get: function () {
          if (o.isBuffer(this)) return this.buffer;
        },
      }),
      Object.defineProperty(o.prototype, "offset", {
        enumerable: !0,
        get: function () {
          if (o.isBuffer(this)) return this.byteOffset;
        },
      }),
      (o.poolSize = 8192),
      (o.from = function (e, t, r) {
        return s(e, t, r);
      }),
      Object.setPrototypeOf(o.prototype, Uint8Array.prototype),
      Object.setPrototypeOf(o, Uint8Array),
      (o.alloc = function (e, t, r) {
        return (function (e, t, r) {
          return (
            a(e),
            e <= 0
              ? i(e)
              : void 0 !== t
              ? "string" == typeof r
                ? i(e).fill(t, r)
                : i(e).fill(t)
              : i(e)
          );
        })(e, t, r);
      }),
      (o.allocUnsafe = function (e) {
        return l(e);
      }),
      (o.allocUnsafeSlow = function (e) {
        return l(e);
      }),
      (o.isBuffer = function (e) {
        return null != e && !0 === e._isBuffer && e !== o.prototype;
      }),
      (o.compare = function (e, t) {
        if (
          (X(e, Uint8Array) && (e = o.from(e, e.offset, e.byteLength)),
          X(t, Uint8Array) && (t = o.from(t, t.offset, t.byteLength)),
          !o.isBuffer(e) || !o.isBuffer(t))
        )
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        if (e === t) return 0;
        let r = e.length,
          n = t.length;
        for (let i = 0, o = Math.min(r, n); i < o; ++i)
          if (e[i] !== t[i]) {
            (r = e[i]), (n = t[i]);
            break;
          }
        return r < n ? -1 : n < r ? 1 : 0;
      }),
      (o.isEncoding = function (e) {
        switch (String(e).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return !0;
          default:
            return !1;
        }
      }),
      (o.concat = function (e, t) {
        if (!Array.isArray(e))
          throw new TypeError('"list" argument must be an Array of Buffers');
        if (0 === e.length) return o.alloc(0);
        let r;
        if (void 0 === t)
          for (t = 0, r = 0; r < e.length; ++r) t += e[r].length;
        let n = o.allocUnsafe(t),
          i = 0;
        for (r = 0; r < e.length; ++r) {
          let t = e[r];
          if (X(t, Uint8Array))
            i + t.length > n.length
              ? (o.isBuffer(t) || (t = o.from(t)), t.copy(n, i))
              : Uint8Array.prototype.set.call(n, t, i);
          else {
            if (!o.isBuffer(t))
              throw new TypeError(
                '"list" argument must be an Array of Buffers'
              );
            t.copy(n, i);
          }
          i += t.length;
        }
        return n;
      }),
      (o.byteLength = d),
      (o.prototype._isBuffer = !0),
      (o.prototype.swap16 = function () {
        let e = this.length;
        if (e % 2 != 0)
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let t = 0; t < e; t += 2) f(this, t, t + 1);
        return this;
      }),
      (o.prototype.swap32 = function () {
        let e = this.length;
        if (e % 4 != 0)
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let t = 0; t < e; t += 4) f(this, t, t + 3), f(this, t + 1, t + 2);
        return this;
      }),
      (o.prototype.swap64 = function () {
        let e = this.length;
        if (e % 8 != 0)
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let t = 0; t < e; t += 8)
          f(this, t, t + 7),
            f(this, t + 1, t + 6),
            f(this, t + 2, t + 5),
            f(this, t + 3, t + 4);
        return this;
      }),
      (o.prototype.toString = function () {
        let e = this.length;
        return 0 === e
          ? ""
          : 0 === arguments.length
          ? S(this, 0, e)
          : p.apply(this, arguments);
      }),
      (o.prototype.toLocaleString = o.prototype.toString),
      (o.prototype.equals = function (e) {
        if (!o.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
        return this === e || 0 === o.compare(this, e);
      }),
      (o.prototype.inspect = function () {
        let e = "",
          t = Zu.INSPECT_MAX_BYTES;
        return (
          (e = this.toString("hex", 0, t)
            .replace(/(.{2})/g, "$1 ")
            .trim()),
          this.length > t && (e += " ... "),
          "<Buffer " + e + ">"
        );
      }),
      r && (o.prototype[r] = o.prototype.inspect),
      (o.prototype.compare = function (e, t, r, n, i) {
        if (
          (X(e, Uint8Array) && (e = o.from(e, e.offset, e.byteLength)),
          !o.isBuffer(e))
        )
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
              typeof e
          );
        if (
          (void 0 === t && (t = 0),
          void 0 === r && (r = e ? e.length : 0),
          void 0 === n && (n = 0),
          void 0 === i && (i = this.length),
          t < 0 || r > e.length || n < 0 || i > this.length)
        )
          throw new RangeError("out of range index");
        if (n >= i && t >= r) return 0;
        if (n >= i) return -1;
        if (t >= r) return 1;
        if (this === e) return 0;
        let s = (i >>>= 0) - (n >>>= 0),
          a = (r >>>= 0) - (t >>>= 0),
          l = Math.min(s, a),
          c = this.slice(n, i),
          u = e.slice(t, r);
        for (let e = 0; e < l; ++e)
          if (c[e] !== u[e]) {
            (s = c[e]), (a = u[e]);
            break;
          }
        return s < a ? -1 : a < s ? 1 : 0;
      }),
      (o.prototype.includes = function (e, t, r) {
        return -1 !== this.indexOf(e, t, r);
      }),
      (o.prototype.indexOf = function (e, t, r) {
        return m(this, e, t, r, !0);
      }),
      (o.prototype.lastIndexOf = function (e, t, r) {
        return m(this, e, t, r, !1);
      }),
      (o.prototype.write = function (e, t, r, n) {
        if (void 0 === t) (n = "utf8"), (r = this.length), (t = 0);
        else if (void 0 === r && "string" == typeof t)
          (n = t), (r = this.length), (t = 0);
        else {
          if (!isFinite(t))
            throw new Error(
              "Buffer.write(string, encoding, offset[, length]) is no longer supported"
            );
          (t >>>= 0),
            isFinite(r)
              ? ((r >>>= 0), void 0 === n && (n = "utf8"))
              : ((n = r), (r = void 0));
        }
        let i = this.length - t;
        if (
          ((void 0 === r || r > i) && (r = i),
          (e.length > 0 && (r < 0 || t < 0)) || t > this.length)
        )
          throw new RangeError("Attempt to write outside buffer bounds");
        n || (n = "utf8");
        let o = !1;
        for (;;)
          switch (n) {
            case "hex":
              return _(this, e, t, r);
            case "utf8":
            case "utf-8":
              return v(this, e, t, r);
            case "ascii":
            case "latin1":
            case "binary":
              return y(this, e, t, r);
            case "base64":
              return b(this, e, t, r);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return x(this, e, t, r);
            default:
              if (o) throw new TypeError("Unknown encoding: " + n);
              (n = ("" + n).toLowerCase()), (o = !0);
          }
      }),
      (o.prototype.toJSON = function () {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0),
        };
      });
    let E = 4096;
    function M(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t; i < r; ++i) n += String.fromCharCode(127 & e[i]);
      return n;
    }
    function T(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t; i < r; ++i) n += String.fromCharCode(e[i]);
      return n;
    }
    function A(e, t, r) {
      let n = e.length;
      (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);
      let i = "";
      for (let n = t; n < r; ++n) i += Y[e[n]];
      return i;
    }
    function R(e, t, r) {
      let n = e.slice(t, r),
        i = "";
      for (let e = 0; e < n.length - 1; e += 2)
        i += String.fromCharCode(n[e] + 256 * n[e + 1]);
      return i;
    }
    function P(e, t, r) {
      if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint");
      if (e + t > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    function C(e, t, r, n, i, s) {
      if (!o.isBuffer(e))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (t > i || t < s)
        throw new RangeError('"value" argument is out of bounds');
      if (r + n > e.length) throw new RangeError("Index out of range");
    }
    function I(e, t, r, n, i) {
      F(t, n, i, e, r, 7);
      let o = Number(t & BigInt(4294967295));
      (e[r++] = o),
        (o >>= 8),
        (e[r++] = o),
        (o >>= 8),
        (e[r++] = o),
        (o >>= 8),
        (e[r++] = o);
      let s = Number((t >> BigInt(32)) & BigInt(4294967295));
      return (
        (e[r++] = s),
        (s >>= 8),
        (e[r++] = s),
        (s >>= 8),
        (e[r++] = s),
        (s >>= 8),
        (e[r++] = s),
        r
      );
    }
    function L(e, t, r, n, i) {
      F(t, n, i, e, r, 7);
      let o = Number(t & BigInt(4294967295));
      (e[r + 7] = o),
        (o >>= 8),
        (e[r + 6] = o),
        (o >>= 8),
        (e[r + 5] = o),
        (o >>= 8),
        (e[r + 4] = o);
      let s = Number((t >> BigInt(32)) & BigInt(4294967295));
      return (
        (e[r + 3] = s),
        (s >>= 8),
        (e[r + 2] = s),
        (s >>= 8),
        (e[r + 1] = s),
        (s >>= 8),
        (e[r] = s),
        r + 8
      );
    }
    function O(e, t, r, n, i, o) {
      if (r + n > e.length) throw new RangeError("Index out of range");
      if (r < 0) throw new RangeError("Index out of range");
    }
    function N(e, r, n, i, o) {
      return (
        (r = +r),
        (n >>>= 0),
        o || O(e, 0, n, 4),
        t.write(e, r, n, i, 23, 4),
        n + 4
      );
    }
    function U(e, r, n, i, o) {
      return (
        (r = +r),
        (n >>>= 0),
        o || O(e, 0, n, 8),
        t.write(e, r, n, i, 52, 8),
        n + 8
      );
    }
    (o.prototype.slice = function (e, t) {
      let r = this.length;
      (e = ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r),
        (t = void 0 === t ? r : ~~t) < 0
          ? (t += r) < 0 && (t = 0)
          : t > r && (t = r),
        t < e && (t = e);
      let n = this.subarray(e, t);
      return Object.setPrototypeOf(n, o.prototype), n;
    }),
      (o.prototype.readUintLE = o.prototype.readUIntLE =
        function (e, t, r) {
          (e >>>= 0), (t >>>= 0), r || P(e, t, this.length);
          let n = this[e],
            i = 1,
            o = 0;
          for (; ++o < t && (i *= 256); ) n += this[e + o] * i;
          return n;
        }),
      (o.prototype.readUintBE = o.prototype.readUIntBE =
        function (e, t, r) {
          (e >>>= 0), (t >>>= 0), r || P(e, t, this.length);
          let n = this[e + --t],
            i = 1;
          for (; t > 0 && (i *= 256); ) n += this[e + --t] * i;
          return n;
        }),
      (o.prototype.readUint8 = o.prototype.readUInt8 =
        function (e, t) {
          return (e >>>= 0), t || P(e, 1, this.length), this[e];
        }),
      (o.prototype.readUint16LE = o.prototype.readUInt16LE =
        function (e, t) {
          return (
            (e >>>= 0), t || P(e, 2, this.length), this[e] | (this[e + 1] << 8)
          );
        }),
      (o.prototype.readUint16BE = o.prototype.readUInt16BE =
        function (e, t) {
          return (
            (e >>>= 0), t || P(e, 2, this.length), (this[e] << 8) | this[e + 1]
          );
        }),
      (o.prototype.readUint32LE = o.prototype.readUInt32LE =
        function (e, t) {
          return (
            (e >>>= 0),
            t || P(e, 4, this.length),
            (this[e] | (this[e + 1] << 8) | (this[e + 2] << 16)) +
              16777216 * this[e + 3]
          );
        }),
      (o.prototype.readUint32BE = o.prototype.readUInt32BE =
        function (e, t) {
          return (
            (e >>>= 0),
            t || P(e, 4, this.length),
            16777216 * this[e] +
              ((this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3])
          );
        }),
      (o.prototype.readBigUInt64LE = K(function (e) {
        H((e >>>= 0), "offset");
        let t = this[e],
          r = this[e + 7];
        (void 0 === t || void 0 === r) && z(e, this.length - 8);
        let n = t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24,
          i = this[++e] + 256 * this[++e] + 65536 * this[++e] + r * 2 ** 24;
        return BigInt(n) + (BigInt(i) << BigInt(32));
      })),
      (o.prototype.readBigUInt64BE = K(function (e) {
        H((e >>>= 0), "offset");
        let t = this[e],
          r = this[e + 7];
        (void 0 === t || void 0 === r) && z(e, this.length - 8);
        let n = t * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + this[++e],
          i = this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + r;
        return (BigInt(n) << BigInt(32)) + BigInt(i);
      })),
      (o.prototype.readIntLE = function (e, t, r) {
        (e >>>= 0), (t >>>= 0), r || P(e, t, this.length);
        let n = this[e],
          i = 1,
          o = 0;
        for (; ++o < t && (i *= 256); ) n += this[e + o] * i;
        return (i *= 128), n >= i && (n -= Math.pow(2, 8 * t)), n;
      }),
      (o.prototype.readIntBE = function (e, t, r) {
        (e >>>= 0), (t >>>= 0), r || P(e, t, this.length);
        let n = t,
          i = 1,
          o = this[e + --n];
        for (; n > 0 && (i *= 256); ) o += this[e + --n] * i;
        return (i *= 128), o >= i && (o -= Math.pow(2, 8 * t)), o;
      }),
      (o.prototype.readInt8 = function (e, t) {
        return (
          (e >>>= 0),
          t || P(e, 1, this.length),
          128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
        );
      }),
      (o.prototype.readInt16LE = function (e, t) {
        (e >>>= 0), t || P(e, 2, this.length);
        let r = this[e] | (this[e + 1] << 8);
        return 32768 & r ? 4294901760 | r : r;
      }),
      (o.prototype.readInt16BE = function (e, t) {
        (e >>>= 0), t || P(e, 2, this.length);
        let r = this[e + 1] | (this[e] << 8);
        return 32768 & r ? 4294901760 | r : r;
      }),
      (o.prototype.readInt32LE = function (e, t) {
        return (
          (e >>>= 0),
          t || P(e, 4, this.length),
          this[e] |
            (this[e + 1] << 8) |
            (this[e + 2] << 16) |
            (this[e + 3] << 24)
        );
      }),
      (o.prototype.readInt32BE = function (e, t) {
        return (
          (e >>>= 0),
          t || P(e, 4, this.length),
          (this[e] << 24) |
            (this[e + 1] << 16) |
            (this[e + 2] << 8) |
            this[e + 3]
        );
      }),
      (o.prototype.readBigInt64LE = K(function (e) {
        H((e >>>= 0), "offset");
        let t = this[e],
          r = this[e + 7];
        (void 0 === t || void 0 === r) && z(e, this.length - 8);
        let n =
          this[e + 4] + 256 * this[e + 5] + 65536 * this[e + 6] + (r << 24);
        return (
          (BigInt(n) << BigInt(32)) +
          BigInt(t + 256 * this[++e] + 65536 * this[++e] + this[++e] * 2 ** 24)
        );
      })),
      (o.prototype.readBigInt64BE = K(function (e) {
        H((e >>>= 0), "offset");
        let t = this[e],
          r = this[e + 7];
        (void 0 === t || void 0 === r) && z(e, this.length - 8);
        let n = (t << 24) + 65536 * this[++e] + 256 * this[++e] + this[++e];
        return (
          (BigInt(n) << BigInt(32)) +
          BigInt(this[++e] * 2 ** 24 + 65536 * this[++e] + 256 * this[++e] + r)
        );
      })),
      (o.prototype.readFloatLE = function (e, r) {
        return (
          (e >>>= 0), r || P(e, 4, this.length), t.read(this, e, !0, 23, 4)
        );
      }),
      (o.prototype.readFloatBE = function (e, r) {
        return (
          (e >>>= 0), r || P(e, 4, this.length), t.read(this, e, !1, 23, 4)
        );
      }),
      (o.prototype.readDoubleLE = function (e, r) {
        return (
          (e >>>= 0), r || P(e, 8, this.length), t.read(this, e, !0, 52, 8)
        );
      }),
      (o.prototype.readDoubleBE = function (e, r) {
        return (
          (e >>>= 0), r || P(e, 8, this.length), t.read(this, e, !1, 52, 8)
        );
      }),
      (o.prototype.writeUintLE = o.prototype.writeUIntLE =
        function (e, t, r, n) {
          (e = +e),
            (t >>>= 0),
            (r >>>= 0),
            n || C(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
          let i = 1,
            o = 0;
          for (this[t] = 255 & e; ++o < r && (i *= 256); )
            this[t + o] = (e / i) & 255;
          return t + r;
        }),
      (o.prototype.writeUintBE = o.prototype.writeUIntBE =
        function (e, t, r, n) {
          (e = +e),
            (t >>>= 0),
            (r >>>= 0),
            n || C(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
          let i = r - 1,
            o = 1;
          for (this[t + i] = 255 & e; --i >= 0 && (o *= 256); )
            this[t + i] = (e / o) & 255;
          return t + r;
        }),
      (o.prototype.writeUint8 = o.prototype.writeUInt8 =
        function (e, t, r) {
          return (
            (e = +e),
            (t >>>= 0),
            r || C(this, e, t, 1, 255, 0),
            (this[t] = 255 & e),
            t + 1
          );
        }),
      (o.prototype.writeUint16LE = o.prototype.writeUInt16LE =
        function (e, t, r) {
          return (
            (e = +e),
            (t >>>= 0),
            r || C(this, e, t, 2, 65535, 0),
            (this[t] = 255 & e),
            (this[t + 1] = e >>> 8),
            t + 2
          );
        }),
      (o.prototype.writeUint16BE = o.prototype.writeUInt16BE =
        function (e, t, r) {
          return (
            (e = +e),
            (t >>>= 0),
            r || C(this, e, t, 2, 65535, 0),
            (this[t] = e >>> 8),
            (this[t + 1] = 255 & e),
            t + 2
          );
        }),
      (o.prototype.writeUint32LE = o.prototype.writeUInt32LE =
        function (e, t, r) {
          return (
            (e = +e),
            (t >>>= 0),
            r || C(this, e, t, 4, 4294967295, 0),
            (this[t + 3] = e >>> 24),
            (this[t + 2] = e >>> 16),
            (this[t + 1] = e >>> 8),
            (this[t] = 255 & e),
            t + 4
          );
        }),
      (o.prototype.writeUint32BE = o.prototype.writeUInt32BE =
        function (e, t, r) {
          return (
            (e = +e),
            (t >>>= 0),
            r || C(this, e, t, 4, 4294967295, 0),
            (this[t] = e >>> 24),
            (this[t + 1] = e >>> 16),
            (this[t + 2] = e >>> 8),
            (this[t + 3] = 255 & e),
            t + 4
          );
        }),
      (o.prototype.writeBigUInt64LE = K(function (e, t = 0) {
        return I(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
      })),
      (o.prototype.writeBigUInt64BE = K(function (e, t = 0) {
        return L(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
      })),
      (o.prototype.writeIntLE = function (e, t, r, n) {
        if (((e = +e), (t >>>= 0), !n)) {
          let n = Math.pow(2, 8 * r - 1);
          C(this, e, t, r, n - 1, -n);
        }
        let i = 0,
          o = 1,
          s = 0;
        for (this[t] = 255 & e; ++i < r && (o *= 256); )
          e < 0 && 0 === s && 0 !== this[t + i - 1] && (s = 1),
            (this[t + i] = (((e / o) | 0) - s) & 255);
        return t + r;
      }),
      (o.prototype.writeIntBE = function (e, t, r, n) {
        if (((e = +e), (t >>>= 0), !n)) {
          let n = Math.pow(2, 8 * r - 1);
          C(this, e, t, r, n - 1, -n);
        }
        let i = r - 1,
          o = 1,
          s = 0;
        for (this[t + i] = 255 & e; --i >= 0 && (o *= 256); )
          e < 0 && 0 === s && 0 !== this[t + i + 1] && (s = 1),
            (this[t + i] = (((e / o) | 0) - s) & 255);
        return t + r;
      }),
      (o.prototype.writeInt8 = function (e, t, r) {
        return (
          (e = +e),
          (t >>>= 0),
          r || C(this, e, t, 1, 127, -128),
          e < 0 && (e = 255 + e + 1),
          (this[t] = 255 & e),
          t + 1
        );
      }),
      (o.prototype.writeInt16LE = function (e, t, r) {
        return (
          (e = +e),
          (t >>>= 0),
          r || C(this, e, t, 2, 32767, -32768),
          (this[t] = 255 & e),
          (this[t + 1] = e >>> 8),
          t + 2
        );
      }),
      (o.prototype.writeInt16BE = function (e, t, r) {
        return (
          (e = +e),
          (t >>>= 0),
          r || C(this, e, t, 2, 32767, -32768),
          (this[t] = e >>> 8),
          (this[t + 1] = 255 & e),
          t + 2
        );
      }),
      (o.prototype.writeInt32LE = function (e, t, r) {
        return (
          (e = +e),
          (t >>>= 0),
          r || C(this, e, t, 4, 2147483647, -2147483648),
          (this[t] = 255 & e),
          (this[t + 1] = e >>> 8),
          (this[t + 2] = e >>> 16),
          (this[t + 3] = e >>> 24),
          t + 4
        );
      }),
      (o.prototype.writeInt32BE = function (e, t, r) {
        return (
          (e = +e),
          (t >>>= 0),
          r || C(this, e, t, 4, 2147483647, -2147483648),
          e < 0 && (e = 4294967295 + e + 1),
          (this[t] = e >>> 24),
          (this[t + 1] = e >>> 16),
          (this[t + 2] = e >>> 8),
          (this[t + 3] = 255 & e),
          t + 4
        );
      }),
      (o.prototype.writeBigInt64LE = K(function (e, t = 0) {
        return I(
          this,
          e,
          t,
          -BigInt("0x8000000000000000"),
          BigInt("0x7fffffffffffffff")
        );
      })),
      (o.prototype.writeBigInt64BE = K(function (e, t = 0) {
        return L(
          this,
          e,
          t,
          -BigInt("0x8000000000000000"),
          BigInt("0x7fffffffffffffff")
        );
      })),
      (o.prototype.writeFloatLE = function (e, t, r) {
        return N(this, e, t, !0, r);
      }),
      (o.prototype.writeFloatBE = function (e, t, r) {
        return N(this, e, t, !1, r);
      }),
      (o.prototype.writeDoubleLE = function (e, t, r) {
        return U(this, e, t, !0, r);
      }),
      (o.prototype.writeDoubleBE = function (e, t, r) {
        return U(this, e, t, !1, r);
      }),
      (o.prototype.copy = function (e, t, r, n) {
        if (!o.isBuffer(e)) throw new TypeError("argument should be a Buffer");
        if (
          (r || (r = 0),
          !n && 0 !== n && (n = this.length),
          t >= e.length && (t = e.length),
          t || (t = 0),
          n > 0 && n < r && (n = r),
          n === r || 0 === e.length || 0 === this.length)
        )
          return 0;
        if (t < 0) throw new RangeError("targetStart out of bounds");
        if (r < 0 || r >= this.length)
          throw new RangeError("Index out of range");
        if (n < 0) throw new RangeError("sourceEnd out of bounds");
        n > this.length && (n = this.length),
          e.length - t < n - r && (n = e.length - t + r);
        let i = n - r;
        return (
          this === e && "function" == typeof Uint8Array.prototype.copyWithin
            ? this.copyWithin(t, r, n)
            : Uint8Array.prototype.set.call(e, this.subarray(r, n), t),
          i
        );
      }),
      (o.prototype.fill = function (e, t, r, n) {
        if ("string" == typeof e) {
          if (
            ("string" == typeof t
              ? ((n = t), (t = 0), (r = this.length))
              : "string" == typeof r && ((n = r), (r = this.length)),
            void 0 !== n && "string" != typeof n)
          )
            throw new TypeError("encoding must be a string");
          if ("string" == typeof n && !o.isEncoding(n))
            throw new TypeError("Unknown encoding: " + n);
          if (1 === e.length) {
            let t = e.charCodeAt(0);
            (("utf8" === n && t < 128) || "latin1" === n) && (e = t);
          }
        } else
          "number" == typeof e
            ? (e &= 255)
            : "boolean" == typeof e && (e = Number(e));
        if (t < 0 || this.length < t || this.length < r)
          throw new RangeError("Out of range index");
        if (r <= t) return this;
        let i;
        if (
          ((t >>>= 0),
          (r = void 0 === r ? this.length : r >>> 0),
          e || (e = 0),
          "number" == typeof e)
        )
          for (i = t; i < r; ++i) this[i] = e;
        else {
          let s = o.isBuffer(e) ? e : o.from(e, n),
            a = s.length;
          if (0 === a)
            throw new TypeError(
              'The value "' + e + '" is invalid for argument "value"'
            );
          for (i = 0; i < r - t; ++i) this[i + t] = s[i % a];
        }
        return this;
      });
    let D = {};
    function k(e, t, r) {
      D[e] = class extends r {
        constructor() {
          super(),
            Object.defineProperty(this, "message", {
              value: t.apply(this, arguments),
              writable: !0,
              configurable: !0,
            }),
            (this.name = `${this.name} [${e}]`),
            this.stack,
            delete this.name;
        }
        get code() {
          return e;
        }
        set code(e) {
          Object.defineProperty(this, "code", {
            configurable: !0,
            enumerable: !0,
            value: e,
            writable: !0,
          });
        }
        toString() {
          return `${this.name} [${e}]: ${this.message}`;
        }
      };
    }
    function B(e) {
      let t = "",
        r = e.length,
        n = "-" === e[0] ? 1 : 0;
      for (; r >= n + 4; r -= 3) t = `_${e.slice(r - 3, r)}${t}`;
      return `${e.slice(0, r)}${t}`;
    }
    function F(e, t, r, n, i, o) {
      if (e > r || e < t) {
        let r,
          n = "bigint" == typeof t ? "n" : "";
        throw (
          ((r =
            0 === t || t === BigInt(0)
              ? `>= 0${n} and < 2${n} ** ${8 * (o + 1)}${n}`
              : `>= -(2${n} ** ${8 * (o + 1) - 1}${n}) and < 2 ** ${
                  8 * (o + 1) - 1
                }${n}`),
          new D.ERR_OUT_OF_RANGE("value", r, e))
        );
      }
      !(function (e, t, r) {
        H(t, "offset"),
          (void 0 === e[t] || void 0 === e[t + r]) && z(t, e.length - (r + 1));
      })(n, i, o);
    }
    function H(e, t) {
      if ("number" != typeof e)
        throw new D.ERR_INVALID_ARG_TYPE(t, "number", e);
    }
    function z(e, t, r) {
      throw Math.floor(e) !== e
        ? (H(e, r), new D.ERR_OUT_OF_RANGE("offset", "an integer", e))
        : t < 0
        ? new D.ERR_BUFFER_OUT_OF_BOUNDS()
        : new D.ERR_OUT_OF_RANGE("offset", `>= 0 and <= ${t}`, e);
    }
    k(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function (e) {
        return e
          ? `${e} is outside of buffer bounds`
          : "Attempt to access memory outside buffer bounds";
      },
      RangeError
    ),
      k(
        "ERR_INVALID_ARG_TYPE",
        function (e, t) {
          return `The "${e}" argument must be of type number. Received type ${typeof t}`;
        },
        TypeError
      ),
      k(
        "ERR_OUT_OF_RANGE",
        function (e, t, r) {
          let n = `The value of "${e}" is out of range.`,
            i = r;
          return (
            Number.isInteger(r) && Math.abs(r) > 2 ** 32
              ? (i = B(String(r)))
              : "bigint" == typeof r &&
                ((i = String(r)),
                (r > BigInt(2) ** BigInt(32) ||
                  r < -(BigInt(2) ** BigInt(32))) &&
                  (i = B(i)),
                (i += "n")),
            (n += ` It must be ${t}. Received ${i}`),
            n
          );
        },
        RangeError
      );
    let V = /[^+/0-9A-Za-z-_]/g;
    function j(e, t) {
      t = t || 1 / 0;
      let r,
        n = e.length,
        i = null,
        o = [];
      for (let s = 0; s < n; ++s) {
        if (((r = e.charCodeAt(s)), r > 55295 && r < 57344)) {
          if (!i) {
            if (r > 56319) {
              (t -= 3) > -1 && o.push(239, 191, 189);
              continue;
            }
            if (s + 1 === n) {
              (t -= 3) > -1 && o.push(239, 191, 189);
              continue;
            }
            i = r;
            continue;
          }
          if (r < 56320) {
            (t -= 3) > -1 && o.push(239, 191, 189), (i = r);
            continue;
          }
          r = 65536 + (((i - 55296) << 10) | (r - 56320));
        } else i && (t -= 3) > -1 && o.push(239, 191, 189);
        if (((i = null), r < 128)) {
          if ((t -= 1) < 0) break;
          o.push(r);
        } else if (r < 2048) {
          if ((t -= 2) < 0) break;
          o.push((r >> 6) | 192, (63 & r) | 128);
        } else if (r < 65536) {
          if ((t -= 3) < 0) break;
          o.push((r >> 12) | 224, ((r >> 6) & 63) | 128, (63 & r) | 128);
        } else {
          if (!(r < 1114112)) throw new Error("Invalid code point");
          if ((t -= 4) < 0) break;
          o.push(
            (r >> 18) | 240,
            ((r >> 12) & 63) | 128,
            ((r >> 6) & 63) | 128,
            (63 & r) | 128
          );
        }
      }
      return o;
    }
    function W(t) {
      return e.toByteArray(
        (function (e) {
          if ((e = (e = e.split("=")[0]).trim().replace(V, "")).length < 2)
            return "";
          for (; e.length % 4 != 0; ) e += "=";
          return e;
        })(t)
      );
    }
    function G(e, t, r, n) {
      let i;
      for (i = 0; i < n && !(i + r >= t.length || i >= e.length); ++i)
        t[i + r] = e[i];
      return i;
    }
    function X(e, t) {
      return (
        e instanceof t ||
        (null != e &&
          null != e.constructor &&
          null != e.constructor.name &&
          e.constructor.name === t.name)
      );
    }
    function q(e) {
      return e != e;
    }
    let Y = (function () {
      let e = "0123456789abcdef",
        t = new Array(256);
      for (let r = 0; r < 16; ++r) {
        let n = 16 * r;
        for (let i = 0; i < 16; ++i) t[n + i] = e[r] + e[i];
      }
      return t;
    })();
    function K(e) {
      return typeof BigInt > "u" ? $ : e;
    }
    function $() {
      throw new Error("BigInt not supported");
    }
    return Zu;
  }
  var Ku,
    $u,
    Qu,
    Ju,
    Zu,
    eh,
    th = hc(() => {
      mc(),
        lh(),
        qu(),
        (Ku = {}),
        ($u = !1),
        (Qu = {}),
        (Ju = !1),
        (Zu = {}),
        (eh = !1);
    }),
    rh = {};
  pc(rh, {
    Buffer: () => ih,
    INSPECT_MAX_BYTES: () => oh,
    default: () => nh,
    kMaxLength: () => sh,
  });
  var nh,
    ih,
    oh,
    sh,
    ah = hc(() => {
      mc(),
        lh(),
        qu(),
        th(),
        (nh = Yu()).Buffer,
        nh.SlowBuffer,
        nh.INSPECT_MAX_BYTES,
        nh.kMaxLength,
        (ih = nh.Buffer),
        (oh = nh.INSPECT_MAX_BYTES),
        (sh = nh.kMaxLength);
    }),
    lh = hc(() => {
      ah();
    }),
    ch = dc((e, t) => {
      mc(), lh(), qu();
      var r = class extends Error {
        constructor(e) {
          if (!Array.isArray(e))
            throw new TypeError(
              "Expected input to be an Array, got " + typeof e
            );
          let t = "";
          for (let r = 0; r < e.length; r++) t += `    ${e[r].stack}\n`;
          super(t), (this.name = "AggregateError"), (this.errors = e);
        }
      };
      t.exports = {
        AggregateError: r,
        ArrayIsArray: (e) => Array.isArray(e),
        ArrayPrototypeIncludes: (e, t) => e.includes(t),
        ArrayPrototypeIndexOf: (e, t) => e.indexOf(t),
        ArrayPrototypeJoin: (e, t) => e.join(t),
        ArrayPrototypeMap: (e, t) => e.map(t),
        ArrayPrototypePop: (e, t) => e.pop(t),
        ArrayPrototypePush: (e, t) => e.push(t),
        ArrayPrototypeSlice: (e, t, r) => e.slice(t, r),
        Error,
        FunctionPrototypeCall: (e, t, ...r) => e.call(t, ...r),
        FunctionPrototypeSymbolHasInstance: (e, t) =>
          Function.prototype[Symbol.hasInstance].call(e, t),
        MathFloor: Math.floor,
        Number,
        NumberIsInteger: Number.isInteger,
        NumberIsNaN: Number.isNaN,
        NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
        NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
        NumberParseInt: Number.parseInt,
        ObjectDefineProperties: (e, t) => Object.defineProperties(e, t),
        ObjectDefineProperty: (e, t, r) => Object.defineProperty(e, t, r),
        ObjectGetOwnPropertyDescriptor: (e, t) =>
          Object.getOwnPropertyDescriptor(e, t),
        ObjectKeys: (e) => Object.keys(e),
        ObjectSetPrototypeOf: (e, t) => Object.setPrototypeOf(e, t),
        Promise,
        PromisePrototypeCatch: (e, t) => e.catch(t),
        PromisePrototypeThen: (e, t, r) => e.then(t, r),
        PromiseReject: (e) => Promise.reject(e),
        PromiseResolve: (e) => Promise.resolve(e),
        ReflectApply: Reflect.apply,
        RegExpPrototypeTest: (e, t) => e.test(t),
        SafeSet: Set,
        String,
        StringPrototypeSlice: (e, t, r) => e.slice(t, r),
        StringPrototypeToLowerCase: (e) => e.toLowerCase(),
        StringPrototypeToUpperCase: (e) => e.toUpperCase(),
        StringPrototypeTrim: (e) => e.trim(),
        Symbol,
        SymbolFor: Symbol.for,
        SymbolAsyncIterator: Symbol.asyncIterator,
        SymbolHasInstance: Symbol.hasInstance,
        SymbolIterator: Symbol.iterator,
        SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
        SymbolAsyncDispose:
          Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
        TypedArrayPrototypeSet: (e, t, r) => e.set(t, r),
        Boolean,
        Uint8Array,
      };
    }),
    uh = dc((e, t) => {
      mc(),
        lh(),
        qu(),
        (t.exports = {
          format: (e, ...t) =>
            e.replace(/%([sdifj])/g, function (...[e, r]) {
              let n = t.shift();
              return "f" === r
                ? n.toFixed(6)
                : "j" === r
                ? JSON.stringify(n)
                : "s" === r && "object" == typeof n
                ? `${
                    n.constructor !== Object ? n.constructor.name : ""
                  } {}`.trim()
                : n.toString();
            }),
          inspect(e) {
            switch (typeof e) {
              case "string":
                if (e.includes("'")) {
                  if (!e.includes('"')) return `"${e}"`;
                  if (!e.includes("`") && !e.includes("${")) return `\`${e}\``;
                }
                return `'${e}'`;
              case "number":
                return isNaN(e) ? "NaN" : Object.is(e, -0) ? String(e) : e;
              case "bigint":
                return `${String(e)}n`;
              case "boolean":
              case "undefined":
                return String(e);
              case "object":
                return "{}";
            }
          },
        });
    }),
    hh = dc((e, t) => {
      mc(), lh(), qu();
      var { format: r, inspect: n } = uh(),
        { AggregateError: i } = ch(),
        o = globalThis.AggregateError || i,
        s = Symbol("kIsNodeError"),
        a = [
          "string",
          "function",
          "number",
          "object",
          "Function",
          "Object",
          "boolean",
          "bigint",
          "symbol",
        ],
        l = /^([A-Z][a-z0-9]*)+$/,
        c = {};
      function u(e, t) {
        if (!e) throw new c.ERR_INTERNAL_ASSERTION(t);
      }
      function h(e) {
        let t = "",
          r = e.length,
          n = "-" === e[0] ? 1 : 0;
        for (; r >= n + 4; r -= 3) t = `_${e.slice(r - 3, r)}${t}`;
        return `${e.slice(0, r)}${t}`;
      }
      function d(e, t, n) {
        n || (n = Error);
        class i extends n {
          constructor(...n) {
            super(
              (function (e, t, n) {
                if ("function" == typeof t)
                  return (
                    u(
                      t.length <= n.length,
                      `Code: ${e}; The provided arguments length (${n.length}) does not match the required ones (${t.length}).`
                    ),
                    t(...n)
                  );
                let i = (t.match(/%[dfijoOs]/g) || []).length;
                return (
                  u(
                    i === n.length,
                    `Code: ${e}; The provided arguments length (${n.length}) does not match the required ones (${i}).`
                  ),
                  0 === n.length ? t : r(t, ...n)
                );
              })(e, t, n)
            );
          }
          toString() {
            return `${this.name} [${e}]: ${this.message}`;
          }
        }
        Object.defineProperties(i.prototype, {
          name: {
            value: n.name,
            writable: !0,
            enumerable: !1,
            configurable: !0,
          },
          toString: {
            value() {
              return `${this.name} [${e}]: ${this.message}`;
            },
            writable: !0,
            enumerable: !1,
            configurable: !0,
          },
        }),
          (i.prototype.code = e),
          (i.prototype[s] = !0),
          (c[e] = i);
      }
      function p(e) {
        let t = "__node_internal_" + e.name;
        return Object.defineProperty(e, "name", { value: t }), e;
      }
      var f = class extends Error {
        constructor(e = "The operation was aborted", t = void 0) {
          if (void 0 !== t && "object" != typeof t)
            throw new c.ERR_INVALID_ARG_TYPE("options", "Object", t);
          super(e, t), (this.code = "ABORT_ERR"), (this.name = "AbortError");
        }
      };
      d("ERR_ASSERTION", "%s", Error),
        d(
          "ERR_INVALID_ARG_TYPE",
          (e, t, r) => {
            u("string" == typeof e, "'name' must be a string"),
              Array.isArray(t) || (t = [t]);
            let i = "The ";
            e.endsWith(" argument")
              ? (i += `${e} `)
              : (i += `"${e}" ${e.includes(".") ? "property" : "argument"} `),
              (i += "must be ");
            let o = [],
              s = [],
              c = [];
            for (let e of t)
              u(
                "string" == typeof e,
                "All expected entries have to be of type string"
              ),
                a.includes(e)
                  ? o.push(e.toLowerCase())
                  : l.test(e)
                  ? s.push(e)
                  : (u(
                      "object" !== e,
                      'The value "object" should be written as "Object"'
                    ),
                    c.push(e));
            if (s.length > 0) {
              let e = o.indexOf("object");
              -1 !== e && (o.splice(o, e, 1), s.push("Object"));
            }
            if (o.length > 0) {
              switch (o.length) {
                case 1:
                  i += `of type ${o[0]}`;
                  break;
                case 2:
                  i += `one of type ${o[0]} or ${o[1]}`;
                  break;
                default: {
                  let e = o.pop();
                  i += `one of type ${o.join(", ")}, or ${e}`;
                }
              }
              (s.length > 0 || c.length > 0) && (i += " or ");
            }
            if (s.length > 0) {
              switch (s.length) {
                case 1:
                  i += `an instance of ${s[0]}`;
                  break;
                case 2:
                  i += `an instance of ${s[0]} or ${s[1]}`;
                  break;
                default: {
                  let e = s.pop();
                  i += `an instance of ${s.join(", ")}, or ${e}`;
                }
              }
              c.length > 0 && (i += " or ");
            }
            switch (c.length) {
              case 0:
                break;
              case 1:
                c[0].toLowerCase() !== c[0] && (i += "an "), (i += `${c[0]}`);
                break;
              case 2:
                i += `one of ${c[0]} or ${c[1]}`;
                break;
              default: {
                let e = c.pop();
                i += `one of ${c.join(", ")}, or ${e}`;
              }
            }
            if (null == r) i += `. Received ${r}`;
            else if ("function" == typeof r && r.name)
              i += `. Received function ${r.name}`;
            else if ("object" == typeof r) {
              var h;
              null !== (h = r.constructor) && void 0 !== h && h.name
                ? (i += `. Received an instance of ${r.constructor.name}`)
                : (i += `. Received ${n(r, { depth: -1 })}`);
            } else {
              let e = n(r, { colors: !1 });
              e.length > 25 && (e = `${e.slice(0, 25)}...`),
                (i += `. Received type ${typeof r} (${e})`);
            }
            return i;
          },
          TypeError
        ),
        d(
          "ERR_INVALID_ARG_VALUE",
          (e, t, r = "is invalid") => {
            let i = n(t);
            return (
              i.length > 128 && (i = i.slice(0, 128) + "..."),
              `The ${
                e.includes(".") ? "property" : "argument"
              } '${e}' ${r}. Received ${i}`
            );
          },
          TypeError
        ),
        d(
          "ERR_INVALID_RETURN_VALUE",
          (e, t, r) => {
            var n;
            return `Expected ${e} to be returned from the "${t}" function but got ${
              null != r &&
              null !== (n = r.constructor) &&
              void 0 !== n &&
              n.name
                ? `instance of ${r.constructor.name}`
                : "type " + typeof r
            }.`;
          },
          TypeError
        ),
        d(
          "ERR_MISSING_ARGS",
          (...e) => {
            u(e.length > 0, "At least one arg needs to be specified");
            let t,
              r = e.length;
            switch (
              ((e = (Array.isArray(e) ? e : [e])
                .map((e) => `"${e}"`)
                .join(" or ")),
              r)
            ) {
              case 1:
                t += `The ${e[0]} argument`;
                break;
              case 2:
                t += `The ${e[0]} and ${e[1]} arguments`;
                break;
              default: {
                let r = e.pop();
                t += `The ${e.join(", ")}, and ${r} arguments`;
              }
            }
            return `${t} must be specified`;
          },
          TypeError
        ),
        d(
          "ERR_OUT_OF_RANGE",
          (e, t, r) => {
            let i;
            if (
              (u(t, 'Missing "range" argument'),
              Number.isInteger(r) && Math.abs(r) > 2 ** 32)
            )
              i = h(String(r));
            else if ("bigint" == typeof r) {
              i = String(r);
              let e = BigInt(2) ** BigInt(32);
              (r > e || r < -e) && (i = h(i)), (i += "n");
            } else i = n(r);
            return `The value of "${e}" is out of range. It must be ${t}. Received ${i}`;
          },
          RangeError
        ),
        d("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error),
        d(
          "ERR_METHOD_NOT_IMPLEMENTED",
          "The %s method is not implemented",
          Error
        ),
        d(
          "ERR_STREAM_ALREADY_FINISHED",
          "Cannot call %s after a stream was finished",
          Error
        ),
        d("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error),
        d(
          "ERR_STREAM_DESTROYED",
          "Cannot call %s after a stream was destroyed",
          Error
        ),
        d(
          "ERR_STREAM_NULL_VALUES",
          "May not write null values to stream",
          TypeError
        ),
        d("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error),
        d("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error),
        d(
          "ERR_STREAM_UNSHIFT_AFTER_END_EVENT",
          "stream.unshift() after end event",
          Error
        ),
        d("ERR_STREAM_WRITE_AFTER_END", "write after end", Error),
        d("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError),
        (t.exports = {
          AbortError: f,
          aggregateTwoErrors: p(function (e, t) {
            if (e && t && e !== t) {
              if (Array.isArray(t.errors)) return t.errors.push(e), t;
              let r = new o([t, e], t.message);
              return (r.code = t.code), r;
            }
            return e || t;
          }),
          hideStackFrames: p,
          codes: c,
        });
    }),
    dh = dc((e, t) => {
      mc(), lh(), qu();
      var { AbortController: r, AbortSignal: n } =
        typeof self < "u" ? self : typeof window < "u" ? window : void 0;
      (t.exports = r), (t.exports.AbortSignal = n), (t.exports.default = r);
    }),
    ph = {};
  pc(ph, {
    EventEmitter: () => _h,
    default: () => gh,
    defaultMaxListeners: () => vh,
    init: () => yh,
    listenerCount: () => bh,
    on: () => xh,
    once: () => wh,
  });
  var fh,
    mh,
    gh,
    _h,
    vh,
    yh,
    bh,
    xh,
    wh,
    Sh,
    Eh,
    Mh,
    Th = hc(() => {
      mc(),
        lh(),
        qu(),
        (fh = {}),
        (mh = !1),
        (gh = (function () {
          if (mh) return fh;
          mh = !0;
          var e,
            t = "object" == typeof Reflect ? Reflect : null,
            r =
              t && "function" == typeof t.apply
                ? t.apply
                : function (e, t, r) {
                    return Function.prototype.apply.call(e, t, r);
                  };
          e =
            t && "function" == typeof t.ownKeys
              ? t.ownKeys
              : Object.getOwnPropertySymbols
              ? function (e) {
                  return Object.getOwnPropertyNames(e).concat(
                    Object.getOwnPropertySymbols(e)
                  );
                }
              : function (e) {
                  return Object.getOwnPropertyNames(e);
                };
          var n =
            Number.isNaN ||
            function (e) {
              return e != e;
            };
          function i() {
            i.init.call(this);
          }
          ((fh = i).once = function (e, t) {
            return new Promise(function (r, n) {
              function i(r) {
                e.removeListener(t, o), n(r);
              }
              function o() {
                "function" == typeof e.removeListener &&
                  e.removeListener("error", i),
                  r([].slice.call(arguments));
              }
              f(e, t, o, { once: !0 }),
                "error" !== t &&
                  (function (e, t) {
                    "function" == typeof e.on && f(e, "error", t, { once: !0 });
                  })(e, i);
            });
          }),
            (i.EventEmitter = i),
            (i.prototype._events = void 0),
            (i.prototype._eventsCount = 0),
            (i.prototype._maxListeners = void 0);
          var o = 10;
          function s(e) {
            if ("function" != typeof e)
              throw new TypeError(
                'The "listener" argument must be of type Function. Received type ' +
                  typeof e
              );
          }
          function a(e) {
            return void 0 === e._maxListeners
              ? i.defaultMaxListeners
              : e._maxListeners;
          }
          function l(e, t, r, n) {
            var i, o, l;
            if (
              (s(r),
              void 0 === (o = e._events)
                ? ((o = e._events = Object.create(null)), (e._eventsCount = 0))
                : (void 0 !== o.newListener &&
                    (e.emit("newListener", t, r.listener ? r.listener : r),
                    (o = e._events)),
                  (l = o[t])),
              void 0 === l)
            )
              (l = o[t] = r), ++e._eventsCount;
            else if (
              ("function" == typeof l
                ? (l = o[t] = n ? [r, l] : [l, r])
                : n
                ? l.unshift(r)
                : l.push(r),
              (i = a(e)) > 0 && l.length > i && !l.warned)
            ) {
              l.warned = !0;
              var c = new Error(
                "Possible EventEmitter memory leak detected. " +
                  l.length +
                  " " +
                  String(t) +
                  " listeners added. Use emitter.setMaxListeners() to increase limit"
              );
              (c.name = "MaxListenersExceededWarning"),
                (c.emitter = e),
                (c.type = t),
                (c.count = l.length),
                (function (e) {
                  console && console.warn && console.warn(e);
                })(c);
            }
            return e;
          }
          function c() {
            if (!this.fired)
              return (
                this.target.removeListener(this.type, this.wrapFn),
                (this.fired = !0),
                0 === arguments.length
                  ? this.listener.call(this.target)
                  : this.listener.apply(this.target, arguments)
              );
          }
          function u(e, t, r) {
            var n = {
                fired: !1,
                wrapFn: void 0,
                target: e,
                type: t,
                listener: r,
              },
              i = c.bind(n);
            return (i.listener = r), (n.wrapFn = i), i;
          }
          function h(e, t, r) {
            var n = e._events;
            if (void 0 === n) return [];
            var i = n[t];
            return void 0 === i
              ? []
              : "function" == typeof i
              ? r
                ? [i.listener || i]
                : [i]
              : r
              ? (function (e) {
                  for (var t = new Array(e.length), r = 0; r < t.length; ++r)
                    t[r] = e[r].listener || e[r];
                  return t;
                })(i)
              : p(i, i.length);
          }
          function d(e) {
            var t = this._events;
            if (void 0 !== t) {
              var r = t[e];
              if ("function" == typeof r) return 1;
              if (void 0 !== r) return r.length;
            }
            return 0;
          }
          function p(e, t) {
            for (var r = new Array(t), n = 0; n < t; ++n) r[n] = e[n];
            return r;
          }
          function f(e, t, r, n) {
            if ("function" == typeof e.on) n.once ? e.once(t, r) : e.on(t, r);
            else {
              if ("function" != typeof e.addEventListener)
                throw new TypeError(
                  'The "emitter" argument must be of type EventEmitter. Received type ' +
                    typeof e
                );
              e.addEventListener(t, function i(o) {
                n.once && e.removeEventListener(t, i), r(o);
              });
            }
          }
          return (
            Object.defineProperty(i, "defaultMaxListeners", {
              enumerable: !0,
              get: function () {
                return o;
              },
              set: function (e) {
                if ("number" != typeof e || e < 0 || n(e))
                  throw new RangeError(
                    'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                      e +
                      "."
                  );
                o = e;
              },
            }),
            (i.init = function () {
              (void 0 === this._events ||
                this._events === Object.getPrototypeOf(this)._events) &&
                ((this._events = Object.create(null)), (this._eventsCount = 0)),
                (this._maxListeners = this._maxListeners || void 0);
            }),
            (i.prototype.setMaxListeners = function (e) {
              if ("number" != typeof e || e < 0 || n(e))
                throw new RangeError(
                  'The value of "n" is out of range. It must be a non-negative number. Received ' +
                    e +
                    "."
                );
              return (this._maxListeners = e), this;
            }),
            (i.prototype.getMaxListeners = function () {
              return a(this);
            }),
            (i.prototype.emit = function (e) {
              for (var t = [], n = 1; n < arguments.length; n++)
                t.push(arguments[n]);
              var i = "error" === e,
                o = this._events;
              if (void 0 !== o) i = i && void 0 === o.error;
              else if (!i) return !1;
              if (i) {
                var s;
                if ((t.length > 0 && (s = t[0]), s instanceof Error)) throw s;
                var a = new Error(
                  "Unhandled error." + (s ? " (" + s.message + ")" : "")
                );
                throw ((a.context = s), a);
              }
              var l = o[e];
              if (void 0 === l) return !1;
              if ("function" == typeof l) r(l, this, t);
              else {
                var c = l.length,
                  u = p(l, c);
                for (n = 0; n < c; ++n) r(u[n], this, t);
              }
              return !0;
            }),
            (i.prototype.addListener = function (e, t) {
              return l(this, e, t, !1);
            }),
            (i.prototype.on = i.prototype.addListener),
            (i.prototype.prependListener = function (e, t) {
              return l(this, e, t, !0);
            }),
            (i.prototype.once = function (e, t) {
              return s(t), this.on(e, u(this, e, t)), this;
            }),
            (i.prototype.prependOnceListener = function (e, t) {
              return s(t), this.prependListener(e, u(this, e, t)), this;
            }),
            (i.prototype.removeListener = function (e, t) {
              var r, n, i, o, a;
              if ((s(t), void 0 === (n = this._events))) return this;
              if (void 0 === (r = n[e])) return this;
              if (r === t || r.listener === t)
                0 === --this._eventsCount
                  ? (this._events = Object.create(null))
                  : (delete n[e],
                    n.removeListener &&
                      this.emit("removeListener", e, r.listener || t));
              else if ("function" != typeof r) {
                for (i = -1, o = r.length - 1; o >= 0; o--)
                  if (r[o] === t || r[o].listener === t) {
                    (a = r[o].listener), (i = o);
                    break;
                  }
                if (i < 0) return this;
                0 === i
                  ? r.shift()
                  : (function (e, t) {
                      for (; t + 1 < e.length; t++) e[t] = e[t + 1];
                      e.pop();
                    })(r, i),
                  1 === r.length && (n[e] = r[0]),
                  void 0 !== n.removeListener &&
                    this.emit("removeListener", e, a || t);
              }
              return this;
            }),
            (i.prototype.off = i.prototype.removeListener),
            (i.prototype.removeAllListeners = function (e) {
              var t, r, n;
              if (void 0 === (r = this._events)) return this;
              if (void 0 === r.removeListener)
                return (
                  0 === arguments.length
                    ? ((this._events = Object.create(null)),
                      (this._eventsCount = 0))
                    : void 0 !== r[e] &&
                      (0 === --this._eventsCount
                        ? (this._events = Object.create(null))
                        : delete r[e]),
                  this
                );
              if (0 === arguments.length) {
                var i,
                  o = Object.keys(r);
                for (n = 0; n < o.length; ++n)
                  "removeListener" !== (i = o[n]) && this.removeAllListeners(i);
                return (
                  this.removeAllListeners("removeListener"),
                  (this._events = Object.create(null)),
                  (this._eventsCount = 0),
                  this
                );
              }
              if ("function" == typeof (t = r[e])) this.removeListener(e, t);
              else if (void 0 !== t)
                for (n = t.length - 1; n >= 0; n--)
                  this.removeListener(e, t[n]);
              return this;
            }),
            (i.prototype.listeners = function (e) {
              return h(this, e, !0);
            }),
            (i.prototype.rawListeners = function (e) {
              return h(this, e, !1);
            }),
            (i.listenerCount = function (e, t) {
              return "function" == typeof e.listenerCount
                ? e.listenerCount(t)
                : d.call(e, t);
            }),
            (i.prototype.listenerCount = d),
            (i.prototype.eventNames = function () {
              return this._eventsCount > 0 ? e(this._events) : [];
            }),
            fh
          );
        })()).once,
        (gh.once = function (e, t) {
          return new Promise((r, n) => {
            function i(...t) {
              void 0 !== o && e.removeListener("error", o), r(t);
            }
            let o;
            "error" !== t &&
              ((o = (t) => {
                e.removeListener(name, i), n(t);
              }),
              e.once("error", o)),
              e.once(t, i);
          });
        }),
        (gh.on = function (e, t) {
          let r = [],
            n = [],
            i = null,
            o = !1,
            s = {
              async next() {
                let e = r.shift();
                if (e) return createIterResult(e, !1);
                if (i) {
                  let e = Promise.reject(i);
                  return (i = null), e;
                }
                return o
                  ? createIterResult(void 0, !0)
                  : new Promise((e, t) => n.push({ resolve: e, reject: t }));
              },
              async return() {
                e.removeListener(t, a), e.removeListener("error", l), (o = !0);
                for (let e of n) e.resolve(createIterResult(void 0, !0));
                return createIterResult(void 0, !0);
              },
              throw(r) {
                (i = r), e.removeListener(t, a), e.removeListener("error", l);
              },
              [Symbol.asyncIterator]() {
                return this;
              },
            };
          return e.on(t, a), e.on("error", l), s;
          function a(...e) {
            let t = n.shift();
            t ? t.resolve(createIterResult(e, !1)) : r.push(e);
          }
          function l(e) {
            o = !0;
            let t = n.shift();
            t ? t.reject(e) : (i = e), s.return();
          }
        }),
        ({
          EventEmitter: _h,
          defaultMaxListeners: vh,
          init: yh,
          listenerCount: bh,
          on: xh,
          once: wh,
        } = gh);
    }),
    Ah = dc((e, t) => {
      mc(), lh(), qu();
      var r = (ah(), fc(rh)),
        { format: n, inspect: i } = uh(),
        {
          codes: { ERR_INVALID_ARG_TYPE: o },
        } = hh(),
        {
          kResistStopPropagation: s,
          AggregateError: a,
          SymbolDispose: l,
        } = ch(),
        c = globalThis.AbortSignal || dh().AbortSignal,
        u = globalThis.AbortController || dh().AbortController,
        h = Object.getPrototypeOf(async function () {}).constructor,
        d = globalThis.Blob || r.Blob,
        p =
          typeof d < "u"
            ? function (e) {
                return e instanceof d;
              }
            : function (e) {
                return !1;
              },
        f = (e, t) => {
          if (
            void 0 !== e &&
            (null === e || "object" != typeof e || !("aborted" in e))
          )
            throw new o(t, "AbortSignal", e);
        };
      (t.exports = {
        AggregateError: a,
        kEmptyObject: Object.freeze({}),
        once(e) {
          let t = !1;
          return function (...r) {
            t || ((t = !0), e.apply(this, r));
          };
        },
        createDeferredPromise: function () {
          let e, t;
          return {
            promise: new Promise((r, n) => {
              (e = r), (t = n);
            }),
            resolve: e,
            reject: t,
          };
        },
        promisify: (e) =>
          new Promise((t, r) => {
            e((e, ...n) => (e ? r(e) : t(...n)));
          }),
        debuglog: () => function () {},
        format: n,
        inspect: i,
        types: {
          isAsyncFunction: (e) => e instanceof h,
          isArrayBufferView: (e) => ArrayBuffer.isView(e),
        },
        isBlob: p,
        deprecate: (e, t) => e,
        addAbortListener:
          (Th(), fc(ph)).addAbortListener ||
          function (e, t) {
            if (void 0 === e) throw new o("signal", "AbortSignal", e);
            let r;
            return (
              f(e, "signal"),
              ((e) => {
                if ("function" != typeof e)
                  throw new o("listener", "Function", e);
              })(t),
              e.aborted
                ? queueMicrotask(() => t())
                : (e.addEventListener("abort", t, {
                    __proto__: null,
                    once: !0,
                    [s]: !0,
                  }),
                  (r = () => {
                    e.removeEventListener("abort", t);
                  })),
              {
                __proto__: null,
                [l]() {
                  var e;
                  null === (e = r) || void 0 === e || e();
                },
              }
            );
          },
        AbortSignalAny:
          c.any ||
          function (e) {
            if (1 === e.length) return e[0];
            let t = new u(),
              r = () => t.abort();
            return (
              e.forEach((e) => {
                f(e, "signals"), e.addEventListener("abort", r, { once: !0 });
              }),
              t.signal.addEventListener(
                "abort",
                () => {
                  e.forEach((e) => e.removeEventListener("abort", r));
                },
                { once: !0 }
              ),
              t.signal
            );
          },
      }),
        (t.exports.promisify.custom = Symbol.for(
          "nodejs.util.promisify.custom"
        ));
    }),
    Rh = dc((e, t) => {
      mc(), lh(), qu();
      var {
          ArrayIsArray: r,
          ArrayPrototypeIncludes: n,
          ArrayPrototypeJoin: i,
          ArrayPrototypeMap: o,
          NumberIsInteger: s,
          NumberIsNaN: a,
          NumberMAX_SAFE_INTEGER: l,
          NumberMIN_SAFE_INTEGER: c,
          NumberParseInt: u,
          ObjectPrototypeHasOwnProperty: h,
          RegExpPrototypeExec: d,
          String: p,
          StringPrototypeToUpperCase: f,
          StringPrototypeTrim: m,
        } = ch(),
        {
          hideStackFrames: g,
          codes: {
            ERR_SOCKET_BAD_PORT: _,
            ERR_INVALID_ARG_TYPE: v,
            ERR_INVALID_ARG_VALUE: y,
            ERR_OUT_OF_RANGE: b,
            ERR_UNKNOWN_SIGNAL: x,
          },
        } = hh(),
        { normalizeEncoding: w } = Ah(),
        { isAsyncFunction: S, isArrayBufferView: E } = Ah().types,
        M = {},
        T = /^[0-7]+$/,
        A = g((e, t, r = c, n = l) => {
          if ("number" != typeof e) throw new v(t, "number", e);
          if (!s(e)) throw new b(t, "an integer", e);
          if (e < r || e > n) throw new b(t, `>= ${r} && <= ${n}`, e);
        }),
        R = g((e, t, r = -2147483648, n = 2147483647) => {
          if ("number" != typeof e) throw new v(t, "number", e);
          if (!s(e)) throw new b(t, "an integer", e);
          if (e < r || e > n) throw new b(t, `>= ${r} && <= ${n}`, e);
        }),
        P = g((e, t, r = !1) => {
          if ("number" != typeof e) throw new v(t, "number", e);
          if (!s(e)) throw new b(t, "an integer", e);
          let n = r ? 1 : 0,
            i = 4294967295;
          if (e < n || e > i) throw new b(t, `>= ${n} && <= ${i}`, e);
        });
      function C(e, t) {
        if ("string" != typeof e) throw new v(t, "string", e);
      }
      var I = g((e, t, r) => {
        if (!n(r, e)) {
          let n =
            "must be one of: " +
            i(
              o(r, (e) => ("string" == typeof e ? `'${e}'` : p(e))),
              ", "
            );
          throw new y(t, e, n);
        }
      });
      function L(e, t) {
        if ("boolean" != typeof e) throw new v(t, "boolean", e);
      }
      function O(e, t, r) {
        return null != e && h(e, t) ? e[t] : r;
      }
      var N = g((e, t, n = null) => {
          let i = O(n, "allowArray", !1),
            o = O(n, "allowFunction", !1);
          if (
            (!O(n, "nullable", !1) && null === e) ||
            (!i && r(e)) ||
            ("object" != typeof e && (!o || "function" != typeof e))
          )
            throw new v(t, "Object", e);
        }),
        U = g((e, t) => {
          if (null != e && "object" != typeof e && "function" != typeof e)
            throw new v(t, "a dictionary", e);
        }),
        D = g((e, t, n = 0) => {
          if (!r(e)) throw new v(t, "Array", e);
          if (e.length < n) throw new y(t, e, `must be longer than ${n}`);
        }),
        k = g((e, t = "buffer") => {
          if (!E(e)) throw new v(t, ["Buffer", "TypedArray", "DataView"], e);
        }),
        B = g((e, t) => {
          if (
            void 0 !== e &&
            (null === e || "object" != typeof e || !("aborted" in e))
          )
            throw new v(t, "AbortSignal", e);
        }),
        F = g((e, t) => {
          if ("function" != typeof e) throw new v(t, "Function", e);
        }),
        H = g((e, t) => {
          if ("function" != typeof e || S(e)) throw new v(t, "Function", e);
        }),
        z = g((e, t) => {
          if (void 0 !== e) throw new v(t, "undefined", e);
        }),
        V = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
      function j(e, t) {
        if (typeof e > "u" || !d(V, e))
          throw new y(
            t,
            e,
            'must be an array or string of format "</styles.css>; rel=preload; as=style"'
          );
      }
      t.exports = {
        isInt32: function (e) {
          return e === (0 | e);
        },
        isUint32: function (e) {
          return e === e >>> 0;
        },
        parseFileMode: function (e, t, r) {
          if ((typeof e > "u" && (e = r), "string" == typeof e)) {
            if (null === d(T, e))
              throw new y(
                t,
                e,
                "must be a 32-bit unsigned integer or an octal string"
              );
            e = u(e, 8);
          }
          return P(e, t), e;
        },
        validateArray: D,
        validateStringArray: function (e, t) {
          D(e, t);
          for (let r = 0; r < e.length; r++) C(e[r], `${t}[${r}]`);
        },
        validateBooleanArray: function (e, t) {
          D(e, t);
          for (let r = 0; r < e.length; r++) L(e[r], `${t}[${r}]`);
        },
        validateAbortSignalArray: function (e, t) {
          D(e, t);
          for (let r = 0; r < e.length; r++) {
            let n = e[r],
              i = `${t}[${r}]`;
            if (null == n) throw new v(i, "AbortSignal", n);
            B(n, i);
          }
        },
        validateBoolean: L,
        validateBuffer: k,
        validateDictionary: U,
        validateEncoding: function (e, t) {
          let r = w(t),
            n = e.length;
          if ("hex" === r && n % 2 != 0)
            throw new y("encoding", t, `is invalid for data of length ${n}`);
        },
        validateFunction: F,
        validateInt32: R,
        validateInteger: A,
        validateNumber: function (e, t, r = void 0, n) {
          if ("number" != typeof e) throw new v(t, "number", e);
          if (
            (null != r && e < r) ||
            (null != n && e > n) ||
            ((null != r || null != n) && a(e))
          )
            throw new b(
              t,
              `${null != r ? `>= ${r}` : ""}${
                null != r && null != n ? " && " : ""
              }${null != n ? `<= ${n}` : ""}`,
              e
            );
        },
        validateObject: N,
        validateOneOf: I,
        validatePlainFunction: H,
        validatePort: function (e, t = "Port", r = !0) {
          if (
            ("number" != typeof e && "string" != typeof e) ||
            ("string" == typeof e && 0 === m(e).length) ||
            +e !== +e >>> 0 ||
            e > 65535 ||
            (0 === e && !r)
          )
            throw new _(t, e, r);
          return 0 | e;
        },
        validateSignalName: function (e, t = "signal") {
          if ((C(e, t), void 0 === M[e]))
            throw void 0 !== M[f(e)]
              ? new x(e + " (signals must use all capital letters)")
              : new x(e);
        },
        validateString: C,
        validateUint32: P,
        validateUndefined: z,
        validateUnion: function (e, t, r) {
          if (!n(r, e)) throw new v(t, `('${i(r, "|")}')`, e);
        },
        validateAbortSignal: B,
        validateLinkHeaderValue: function (e) {
          if ("string" == typeof e) return j(e, "hints"), e;
          if (r(e)) {
            let t = e.length,
              r = "";
            if (0 === t) return r;
            for (let n = 0; n < t; n++) {
              let i = e[n];
              j(i, "hints"), (r += i), n !== t - 1 && (r += ", ");
            }
            return r;
          }
          throw new y(
            "hints",
            e,
            'must be an array or string of format "</styles.css>; rel=preload; as=style"'
          );
        },
      };
    }),
    Ph = dc((e, t) => {
      mc(), lh(), qu();
      var r,
        n,
        i = (t.exports = {});
      function o() {
        throw new Error("setTimeout has not been defined");
      }
      function s() {
        throw new Error("clearTimeout has not been defined");
      }
      function a(e) {
        if (r === setTimeout) return setTimeout(e, 0);
        if ((r === o || !r) && setTimeout)
          return (r = setTimeout), setTimeout(e, 0);
        try {
          return r(e, 0);
        } catch {
          try {
            return r.call(null, e, 0);
          } catch {
            return r.call(this, e, 0);
          }
        }
      }
      !(function () {
        try {
          r = "function" == typeof setTimeout ? setTimeout : o;
        } catch {
          r = o;
        }
        try {
          n = "function" == typeof clearTimeout ? clearTimeout : s;
        } catch {
          n = s;
        }
      })();
      var l,
        c = [],
        u = !1,
        h = -1;
      function d() {
        !u ||
          !l ||
          ((u = !1), l.length ? (c = l.concat(c)) : (h = -1), c.length && p());
      }
      function p() {
        if (!u) {
          var e = a(d);
          u = !0;
          for (var t = c.length; t; ) {
            for (l = c, c = []; ++h < t; ) l && l[h].run();
            (h = -1), (t = c.length);
          }
          (l = null),
            (u = !1),
            (function (e) {
              if (n === clearTimeout) return clearTimeout(e);
              if ((n === s || !n) && clearTimeout)
                return (n = clearTimeout), clearTimeout(e);
              try {
                return n(e);
              } catch {
                try {
                  return n.call(null, e);
                } catch {
                  return n.call(this, e);
                }
              }
            })(e);
        }
      }
      function f(e, t) {
        (this.fun = e), (this.array = t);
      }
      function m() {}
      (i.nextTick = function (e) {
        var t = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
        c.push(new f(e, t)), 1 === c.length && !u && a(p);
      }),
        (f.prototype.run = function () {
          this.fun.apply(null, this.array);
        }),
        (i.title = "browser"),
        (i.browser = !0),
        (i.env = {}),
        (i.argv = []),
        (i.version = ""),
        (i.versions = {}),
        (i.on = m),
        (i.addListener = m),
        (i.once = m),
        (i.off = m),
        (i.removeListener = m),
        (i.removeAllListeners = m),
        (i.emit = m),
        (i.prependListener = m),
        (i.prependOnceListener = m),
        (i.listeners = function (e) {
          return [];
        }),
        (i.binding = function (e) {
          throw new Error("process.binding is not supported");
        }),
        (i.cwd = function () {
          return "/";
        }),
        (i.chdir = function (e) {
          throw new Error("process.chdir is not supported");
        }),
        (i.umask = function () {
          return 0;
        });
    }),
    Ch = dc((e, t) => {
      mc(), lh(), qu();
      var { SymbolAsyncIterator: r, SymbolIterator: n, SymbolFor: i } = ch(),
        o = i("nodejs.stream.destroyed"),
        s = i("nodejs.stream.errored"),
        a = i("nodejs.stream.readable"),
        l = i("nodejs.stream.writable"),
        c = i("nodejs.stream.disturbed"),
        u = i("nodejs.webstream.isClosedPromise"),
        h = i("nodejs.webstream.controllerErrorFunction");
      function d(e, t = !1) {
        var r;
        return !(
          !e ||
          "function" != typeof e.pipe ||
          "function" != typeof e.on ||
          (t &&
            ("function" != typeof e.pause || "function" != typeof e.resume)) ||
          (e._writableState &&
            !1 ===
              (null === (r = e._readableState) || void 0 === r
                ? void 0
                : r.readable)) ||
          (e._writableState && !e._readableState)
        );
      }
      function p(e) {
        var t;
        return !(
          !e ||
          "function" != typeof e.write ||
          "function" != typeof e.on ||
          (e._readableState &&
            !1 ===
              (null === (t = e._writableState) || void 0 === t
                ? void 0
                : t.writable))
        );
      }
      function f(e) {
        return (
          e &&
          (e._readableState ||
            e._writableState ||
            ("function" == typeof e.write && "function" == typeof e.on) ||
            ("function" == typeof e.pipe && "function" == typeof e.on))
        );
      }
      function m(e) {
        return !(
          !e ||
          f(e) ||
          "function" != typeof e.pipeThrough ||
          "function" != typeof e.getReader ||
          "function" != typeof e.cancel
        );
      }
      function g(e) {
        return !(
          !e ||
          f(e) ||
          "function" != typeof e.getWriter ||
          "function" != typeof e.abort
        );
      }
      function _(e) {
        return !(
          !e ||
          f(e) ||
          "object" != typeof e.readable ||
          "object" != typeof e.writable
        );
      }
      function v(e) {
        if (!f(e)) return null;
        let t = e._writableState,
          r = e._readableState,
          n = t || r;
        return !!(e.destroyed || e[o] || (null != n && n.destroyed));
      }
      function y(e) {
        if (!p(e)) return null;
        if (!0 === e.writableEnded) return !0;
        let t = e._writableState;
        return (
          (null == t || !t.errored) &&
          ("boolean" != typeof t?.ended ? null : t.ended)
        );
      }
      function b(e, t) {
        if (!d(e)) return null;
        let r = e._readableState;
        return (
          (null == r || !r.errored) &&
          ("boolean" != typeof r?.endEmitted
            ? null
            : !!(
                r.endEmitted ||
                (!1 === t && !0 === r.ended && 0 === r.length)
              ))
        );
      }
      function x(e) {
        return e && null != e[a]
          ? e[a]
          : "boolean" != typeof e?.readable
          ? null
          : !v(e) && d(e) && e.readable && !b(e);
      }
      function w(e) {
        return e && null != e[l]
          ? e[l]
          : "boolean" != typeof e?.writable
          ? null
          : !v(e) && p(e) && e.writable && !y(e);
      }
      function S(e) {
        return (
          "boolean" == typeof e._closed &&
          "boolean" == typeof e._defaultKeepAlive &&
          "boolean" == typeof e._removedConnection &&
          "boolean" == typeof e._removedContLen
        );
      }
      function E(e) {
        return "boolean" == typeof e._sent100 && S(e);
      }
      t.exports = {
        isDestroyed: v,
        kIsDestroyed: o,
        isDisturbed: function (e) {
          var t;
          return !(
            !e ||
            !(null !== (t = e[c]) && void 0 !== t
              ? t
              : e.readableDidRead || e.readableAborted)
          );
        },
        kIsDisturbed: c,
        isErrored: function (e) {
          var t, r, n, i, o, a, l, c, u, h;
          return !(
            !e ||
            !(null !==
              (t =
                null !==
                  (r =
                    null !==
                      (n =
                        null !==
                          (i =
                            null !==
                              (o =
                                null !== (a = e[s]) && void 0 !== a
                                  ? a
                                  : e.readableErrored) && void 0 !== o
                              ? o
                              : e.writableErrored) && void 0 !== i
                          ? i
                          : null === (l = e._readableState) || void 0 === l
                          ? void 0
                          : l.errorEmitted) && void 0 !== n
                      ? n
                      : null === (c = e._writableState) || void 0 === c
                      ? void 0
                      : c.errorEmitted) && void 0 !== r
                  ? r
                  : null === (u = e._readableState) || void 0 === u
                  ? void 0
                  : u.errored) && void 0 !== t
              ? t
              : null !== (h = e._writableState) && void 0 !== h && h.errored)
          );
        },
        kIsErrored: s,
        isReadable: x,
        kIsReadable: a,
        kIsClosedPromise: u,
        kControllerErrorFunction: h,
        kIsWritable: l,
        isClosed: function (e) {
          if (!f(e)) return null;
          if ("boolean" == typeof e.closed) return e.closed;
          let t = e._writableState,
            r = e._readableState;
          return "boolean" == typeof t?.closed || "boolean" == typeof r?.closed
            ? t?.closed || r?.closed
            : "boolean" == typeof e._closed && S(e)
            ? e._closed
            : null;
        },
        isDuplexNodeStream: function (e) {
          return !(
            !e ||
            "function" != typeof e.pipe ||
            !e._readableState ||
            "function" != typeof e.on ||
            "function" != typeof e.write
          );
        },
        isFinished: function (e, t) {
          return f(e)
            ? !!v(e) ||
                !((!1 !== t?.readable && x(e)) || (!1 !== t?.writable && w(e)))
            : null;
        },
        isIterable: function (e, t) {
          return (
            null != e &&
            (!0 === t
              ? "function" == typeof e[r]
              : !1 === t
              ? "function" == typeof e[n]
              : "function" == typeof e[r] || "function" == typeof e[n])
          );
        },
        isReadableNodeStream: d,
        isReadableStream: m,
        isReadableEnded: function (e) {
          if (!d(e)) return null;
          if (!0 === e.readableEnded) return !0;
          let t = e._readableState;
          return (
            !(!t || t.errored) &&
            ("boolean" != typeof t?.ended ? null : t.ended)
          );
        },
        isReadableFinished: b,
        isReadableErrored: function (e) {
          var t, r;
          return f(e)
            ? e.readableErrored
              ? e.readableErrored
              : null !==
                  (t =
                    null === (r = e._readableState) || void 0 === r
                      ? void 0
                      : r.errored) && void 0 !== t
              ? t
              : null
            : null;
        },
        isNodeStream: f,
        isWebStream: function (e) {
          return m(e) || g(e) || _(e);
        },
        isWritable: w,
        isWritableNodeStream: p,
        isWritableStream: g,
        isWritableEnded: y,
        isWritableFinished: function (e, t) {
          if (!p(e)) return null;
          if (!0 === e.writableFinished) return !0;
          let r = e._writableState;
          return (
            (null == r || !r.errored) &&
            ("boolean" != typeof r?.finished
              ? null
              : !!(
                  r.finished ||
                  (!1 === t && !0 === r.ended && 0 === r.length)
                ))
          );
        },
        isWritableErrored: function (e) {
          var t, r;
          return f(e)
            ? e.writableErrored
              ? e.writableErrored
              : null !==
                  (t =
                    null === (r = e._writableState) || void 0 === r
                      ? void 0
                      : r.errored) && void 0 !== t
              ? t
              : null
            : null;
        },
        isServerRequest: function (e) {
          var t;
          return (
            "boolean" == typeof e._consuming &&
            "boolean" == typeof e._dumped &&
            void 0 ===
              (null === (t = e.req) || void 0 === t
                ? void 0
                : t.upgradeOrConnect)
          );
        },
        isServerResponse: E,
        willEmitClose: function (e) {
          if (!f(e)) return null;
          let t = e._writableState,
            r = e._readableState,
            n = t || r;
          return (
            (!n && E(e)) ||
            !!(n && n.autoDestroy && n.emitClose && !1 === n.closed)
          );
        },
        isTransformStream: _,
      };
    }),
    Ih = dc((e, t) => {
      mc(), lh(), qu();
      var r,
        n = Ph(),
        { AbortError: i, codes: o } = hh(),
        { ERR_INVALID_ARG_TYPE: s, ERR_STREAM_PREMATURE_CLOSE: a } = o,
        { kEmptyObject: l, once: c } = Ah(),
        {
          validateAbortSignal: u,
          validateFunction: h,
          validateObject: d,
          validateBoolean: p,
        } = Rh(),
        { Promise: f, PromisePrototypeThen: m, SymbolDispose: g } = ch(),
        {
          isClosed: _,
          isReadable: v,
          isReadableNodeStream: y,
          isReadableStream: b,
          isReadableFinished: x,
          isReadableErrored: w,
          isWritable: S,
          isWritableNodeStream: E,
          isWritableStream: M,
          isWritableFinished: T,
          isWritableErrored: A,
          isNodeStream: R,
          willEmitClose: P,
          kIsClosedPromise: C,
        } = Ch(),
        I = () => {};
      function L(e, t, o) {
        var p, f;
        if (
          (2 === arguments.length
            ? ((o = t), (t = l))
            : null == t
            ? (t = l)
            : d(t, "options"),
          h(o, "callback"),
          u(t.signal, "options.signal"),
          (o = c(o)),
          b(e) || M(e))
        )
          return (function (e, t, o) {
            let s = !1,
              a = I;
            if (t.signal)
              if (
                ((a = () => {
                  (s = !0),
                    o.call(e, new i(void 0, { cause: t.signal.reason }));
                }),
                t.signal.aborted)
              )
                n.nextTick(a);
              else {
                let n = (r = r || Ah().addAbortListener)(t.signal, a),
                  i = o;
                o = c((...t) => {
                  n[g](), i.apply(e, t);
                });
              }
            let l = (...t) => {
              s || n.nextTick(() => o.apply(e, t));
            };
            return m(e[C].promise, l, l), I;
          })(e, t, o);
        if (!R(e))
          throw new s(
            "stream",
            ["ReadableStream", "WritableStream", "Stream"],
            e
          );
        let L = null !== (p = t.readable) && void 0 !== p ? p : y(e),
          O = null !== (f = t.writable) && void 0 !== f ? f : E(e),
          N = e._writableState,
          U = e._readableState,
          D = () => {
            e.writable || F();
          },
          k = P(e) && y(e) === L && E(e) === O,
          B = T(e, !1),
          F = () => {
            (B = !0),
              e.destroyed && (k = !1),
              (!k || (e.readable && !L)) && (!L || H) && o.call(e);
          },
          H = x(e, !1),
          z = () => {
            (H = !0),
              e.destroyed && (k = !1),
              (!k || (e.writable && !O)) && (!O || B) && o.call(e);
          },
          V = (t) => {
            o.call(e, t);
          },
          j = _(e),
          W = () => {
            j = !0;
            let t = A(e) || w(e);
            return t && "boolean" != typeof t
              ? o.call(e, t)
              : L && !H && y(e, !0) && !x(e, !1)
              ? o.call(e, new a())
              : !O || B || T(e, !1)
              ? void o.call(e)
              : o.call(e, new a());
          },
          G = () => {
            j = !0;
            let t = A(e) || w(e);
            if (t && "boolean" != typeof t) return o.call(e, t);
            o.call(e);
          },
          X = () => {
            e.req.on("finish", F);
          };
        !(function (e) {
          return e.setHeader && "function" == typeof e.abort;
        })(e)
          ? O && !N && (e.on("end", D), e.on("close", D))
          : (e.on("complete", F),
            k || e.on("abort", W),
            e.req ? X() : e.on("request", X)),
          !k && "boolean" == typeof e.aborted && e.on("aborted", W),
          e.on("end", z),
          e.on("finish", F),
          !1 !== t.error && e.on("error", V),
          e.on("close", W),
          j
            ? n.nextTick(W)
            : (null != N && N.errorEmitted) || (null != U && U.errorEmitted)
            ? k || n.nextTick(G)
            : ((!L && (!k || v(e)) && (B || !1 === S(e))) ||
                (!O && (!k || S(e)) && (H || !1 === v(e))) ||
                (U && e.req && e.aborted)) &&
              n.nextTick(G);
        let q = () => {
          (o = I),
            e.removeListener("aborted", W),
            e.removeListener("complete", F),
            e.removeListener("abort", W),
            e.removeListener("request", X),
            e.req && e.req.removeListener("finish", F),
            e.removeListener("end", D),
            e.removeListener("close", D),
            e.removeListener("finish", F),
            e.removeListener("end", z),
            e.removeListener("error", V),
            e.removeListener("close", W);
        };
        if (t.signal && !j) {
          let s = () => {
            let r = o;
            q(), r.call(e, new i(void 0, { cause: t.signal.reason }));
          };
          if (t.signal.aborted) n.nextTick(s);
          else {
            let n = (r = r || Ah().addAbortListener)(t.signal, s),
              i = o;
            o = c((...t) => {
              n[g](), i.apply(e, t);
            });
          }
        }
        return q;
      }
      (t.exports = L),
        (t.exports.finished = function (e, t) {
          var r;
          let n = !1;
          return (
            null === t && (t = l),
            null !== (r = t) &&
              void 0 !== r &&
              r.cleanup &&
              (p(t.cleanup, "cleanup"), (n = t.cleanup)),
            new f((r, i) => {
              let o = L(e, t, (e) => {
                n && o(), e ? i(e) : r();
              });
            })
          );
        });
    }),
    Lh = dc((e, t) => {
      mc(), lh(), qu();
      var r = Ph(),
        {
          aggregateTwoErrors: n,
          codes: { ERR_MULTIPLE_CALLBACK: i },
          AbortError: o,
        } = hh(),
        { Symbol: s } = ch(),
        {
          kIsDestroyed: a,
          isDestroyed: l,
          isFinished: c,
          isServerRequest: u,
        } = Ch(),
        h = s("kDestroy"),
        d = s("kConstruct");
      function p(e, t, r) {
        e &&
          (e.stack,
          t && !t.errored && (t.errored = e),
          r && !r.errored && (r.errored = e));
      }
      function f(e, t, n) {
        let i = !1;
        function o(t) {
          if (i) return;
          i = !0;
          let o = e._readableState,
            s = e._writableState;
          p(t, s, o),
            s && (s.closed = !0),
            o && (o.closed = !0),
            "function" == typeof n && n(t),
            t ? r.nextTick(m, e, t) : r.nextTick(g, e);
        }
        try {
          e._destroy(t || null, o);
        } catch (e) {
          o(e);
        }
      }
      function m(e, t) {
        _(e, t), g(e);
      }
      function g(e) {
        let t = e._readableState,
          r = e._writableState;
        r && (r.closeEmitted = !0),
          t && (t.closeEmitted = !0),
          ((null != r && r.emitClose) || (null != t && t.emitClose)) &&
            e.emit("close");
      }
      function _(e, t) {
        let r = e._readableState,
          n = e._writableState;
        (null != n && n.errorEmitted) ||
          (null != r && r.errorEmitted) ||
          (n && (n.errorEmitted = !0),
          r && (r.errorEmitted = !0),
          e.emit("error", t));
      }
      function v(e, t, n) {
        let i = e._readableState,
          o = e._writableState;
        if ((null != o && o.destroyed) || (null != i && i.destroyed))
          return this;
        (null != i && i.autoDestroy) || (null != o && o.autoDestroy)
          ? e.destroy(t)
          : t &&
            (t.stack,
            o && !o.errored && (o.errored = t),
            i && !i.errored && (i.errored = t),
            n ? r.nextTick(_, e, t) : _(e, t));
      }
      function y(e) {
        let t = !1;
        function n(n) {
          if (t) return void v(e, n ?? new i());
          t = !0;
          let o = e._readableState,
            s = e._writableState,
            a = s || o;
          o && (o.constructed = !0),
            s && (s.constructed = !0),
            a.destroyed ? e.emit(h, n) : n ? v(e, n, !0) : r.nextTick(b, e);
        }
        try {
          e._construct((e) => {
            r.nextTick(n, e);
          });
        } catch (e) {
          r.nextTick(n, e);
        }
      }
      function b(e) {
        e.emit(d);
      }
      function x(e) {
        return e?.setHeader && "function" == typeof e.abort;
      }
      function w(e) {
        e.emit("close");
      }
      function S(e, t) {
        e.emit("error", t), r.nextTick(w, e);
      }
      t.exports = {
        construct: function (e, t) {
          if ("function" != typeof e._construct) return;
          let n = e._readableState,
            i = e._writableState;
          n && (n.constructed = !1),
            i && (i.constructed = !1),
            e.once(d, t),
            !(e.listenerCount(d) > 1) && r.nextTick(y, e);
        },
        destroyer: function (e, t) {
          !e ||
            l(e) ||
            (!t && !c(e) && (t = new o()),
            u(e)
              ? ((e.socket = null), e.destroy(t))
              : x(e)
              ? e.abort()
              : x(e.req)
              ? e.req.abort()
              : "function" == typeof e.destroy
              ? e.destroy(t)
              : "function" == typeof e.close
              ? e.close()
              : t
              ? r.nextTick(S, e, t)
              : r.nextTick(w, e),
            e.destroyed || (e[a] = !0));
        },
        destroy: function (e, t) {
          let r = this._readableState,
            i = this._writableState,
            o = i || r;
          return (null != i && i.destroyed) || (null != r && r.destroyed)
            ? ("function" == typeof t && t(), this)
            : (p(e, i, r),
              i && (i.destroyed = !0),
              r && (r.destroyed = !0),
              o.constructed
                ? f(this, e, t)
                : this.once(h, function (r) {
                    f(this, n(r, e), t);
                  }),
              this);
        },
        undestroy: function () {
          let e = this._readableState,
            t = this._writableState;
          e &&
            ((e.constructed = !0),
            (e.closed = !1),
            (e.closeEmitted = !1),
            (e.destroyed = !1),
            (e.errored = null),
            (e.errorEmitted = !1),
            (e.reading = !1),
            (e.ended = !1 === e.readable),
            (e.endEmitted = !1 === e.readable)),
            t &&
              ((t.constructed = !0),
              (t.destroyed = !1),
              (t.closed = !1),
              (t.closeEmitted = !1),
              (t.errored = null),
              (t.errorEmitted = !1),
              (t.finalCalled = !1),
              (t.prefinished = !1),
              (t.ended = !1 === t.writable),
              (t.ending = !1 === t.writable),
              (t.finished = !1 === t.writable));
        },
        errorOrDestroy: v,
      };
    }),
    Oh = dc((e, t) => {
      mc(), lh(), qu();
      var { ArrayIsArray: r, ObjectSetPrototypeOf: n } = ch(),
        { EventEmitter: i } = (Th(), fc(ph));
      function o(e) {
        i.call(this, e);
      }
      function s(e, t, n) {
        if ("function" == typeof e.prependListener)
          return e.prependListener(t, n);
        e._events && e._events[t]
          ? r(e._events[t])
            ? e._events[t].unshift(n)
            : (e._events[t] = [n, e._events[t]])
          : e.on(t, n);
      }
      n(o.prototype, i.prototype),
        n(o, i),
        (o.prototype.pipe = function (e, t) {
          let r = this;
          function n(t) {
            e.writable && !1 === e.write(t) && r.pause && r.pause();
          }
          function o() {
            r.readable && r.resume && r.resume();
          }
          r.on("data", n),
            e.on("drain", o),
            !e._isStdio &&
              (!t || !1 !== t.end) &&
              (r.on("end", l), r.on("close", c));
          let a = !1;
          function l() {
            a || ((a = !0), e.end());
          }
          function c() {
            a || ((a = !0), "function" == typeof e.destroy && e.destroy());
          }
          function u(e) {
            h(), 0 === i.listenerCount(this, "error") && this.emit("error", e);
          }
          function h() {
            r.removeListener("data", n),
              e.removeListener("drain", o),
              r.removeListener("end", l),
              r.removeListener("close", c),
              r.removeListener("error", u),
              e.removeListener("error", u),
              r.removeListener("end", h),
              r.removeListener("close", h),
              e.removeListener("close", h);
          }
          return (
            s(r, "error", u),
            s(e, "error", u),
            r.on("end", h),
            r.on("close", h),
            e.on("close", h),
            e.emit("pipe", r),
            e
          );
        }),
        (t.exports = { Stream: o, prependListener: s });
    }),
    Nh = dc((e, t) => {
      mc(), lh(), qu();
      var r,
        { SymbolDispose: n } = ch(),
        { AbortError: i, codes: o } = hh(),
        { isNodeStream: s, isWebStream: a, kControllerErrorFunction: l } = Ch(),
        c = Ih(),
        { ERR_INVALID_ARG_TYPE: u } = o;
      (t.exports.addAbortSignal = function (e, r) {
        if (
          (((e) => {
            if ("object" != typeof e || !("aborted" in e))
              throw new u("signal", "AbortSignal", e);
          })(e),
          !s(r) && !a(r))
        )
          throw new u(
            "stream",
            ["ReadableStream", "WritableStream", "Stream"],
            r
          );
        return t.exports.addAbortSignalNoValidate(e, r);
      }),
        (t.exports.addAbortSignalNoValidate = function (e, t) {
          if ("object" != typeof e || !("aborted" in e)) return t;
          let o = s(t)
            ? () => {
                t.destroy(new i(void 0, { cause: e.reason }));
              }
            : () => {
                t[l](new i(void 0, { cause: e.reason }));
              };
          if (e.aborted) o();
          else {
            let i = (r = r || Ah().addAbortListener)(e, o);
            c(t, i[n]);
          }
          return t;
        });
    }),
    Uh = dc((e, t) => {
      mc(), lh(), qu();
      var {
          StringPrototypeSlice: r,
          SymbolIterator: n,
          TypedArrayPrototypeSet: i,
          Uint8Array: o,
        } = ch(),
        { Buffer: s } = (ah(), fc(rh)),
        { inspect: a } = Ah();
      t.exports = class {
        constructor() {
          (this.head = null), (this.tail = null), (this.length = 0);
        }
        push(e) {
          let t = { data: e, next: null };
          this.length > 0 ? (this.tail.next = t) : (this.head = t),
            (this.tail = t),
            ++this.length;
        }
        unshift(e) {
          let t = { data: e, next: this.head };
          0 === this.length && (this.tail = t), (this.head = t), ++this.length;
        }
        shift() {
          if (0 === this.length) return;
          let e = this.head.data;
          return (
            1 === this.length
              ? (this.head = this.tail = null)
              : (this.head = this.head.next),
            --this.length,
            e
          );
        }
        clear() {
          (this.head = this.tail = null), (this.length = 0);
        }
        join(e) {
          if (0 === this.length) return "";
          let t = this.head,
            r = "" + t.data;
          for (; null !== (t = t.next); ) r += e + t.data;
          return r;
        }
        concat(e) {
          if (0 === this.length) return s.alloc(0);
          let t = s.allocUnsafe(e >>> 0),
            r = this.head,
            n = 0;
          for (; r; ) i(t, r.data, n), (n += r.data.length), (r = r.next);
          return t;
        }
        consume(e, t) {
          let r = this.head.data;
          if (e < r.length) {
            let t = r.slice(0, e);
            return (this.head.data = r.slice(e)), t;
          }
          return e === r.length
            ? this.shift()
            : t
            ? this._getString(e)
            : this._getBuffer(e);
        }
        first() {
          return this.head.data;
        }
        *[n]() {
          for (let e = this.head; e; e = e.next) yield e.data;
        }
        _getString(e) {
          let t = "",
            n = this.head,
            i = 0;
          do {
            let o = n.data;
            if (!(e > o.length)) {
              e === o.length
                ? ((t += o),
                  ++i,
                  n.next
                    ? (this.head = n.next)
                    : (this.head = this.tail = null))
                : ((t += r(o, 0, e)), (this.head = n), (n.data = r(o, e)));
              break;
            }
            (t += o), (e -= o.length), ++i;
          } while (null !== (n = n.next));
          return (this.length -= i), t;
        }
        _getBuffer(e) {
          let t = s.allocUnsafe(e),
            r = e,
            n = this.head,
            a = 0;
          do {
            let s = n.data;
            if (!(e > s.length)) {
              e === s.length
                ? (i(t, s, r - e),
                  ++a,
                  n.next
                    ? (this.head = n.next)
                    : (this.head = this.tail = null))
                : (i(t, new o(s.buffer, s.byteOffset, e), r - e),
                  (this.head = n),
                  (n.data = s.slice(e)));
              break;
            }
            i(t, s, r - e), (e -= s.length), ++a;
          } while (null !== (n = n.next));
          return (this.length -= a), t;
        }
        [Symbol.for("nodejs.util.inspect.custom")](e, t) {
          return a(this, { ...t, depth: 0, customInspect: !1 });
        }
      };
    }),
    Dh = dc((e, t) => {
      mc(), lh(), qu();
      var { MathFloor: r, NumberIsInteger: n } = ch(),
        { validateInteger: i } = Rh(),
        { ERR_INVALID_ARG_VALUE: o } = hh().codes,
        s = 16384,
        a = 16;
      function l(e) {
        return e ? a : s;
      }
      t.exports = {
        getHighWaterMark: function (e, t, i, s) {
          let a = (function (e, t, r) {
            return null != e.highWaterMark ? e.highWaterMark : t ? e[r] : null;
          })(t, s, i);
          if (null != a) {
            if (!n(a) || a < 0)
              throw new o(s ? `options.${i}` : "options.highWaterMark", a);
            return r(a);
          }
          return l(e.objectMode);
        },
        getDefaultHighWaterMark: l,
        setDefaultHighWaterMark: function (e, t) {
          i(t, "value", 0), e ? (a = t) : (s = t);
        },
      };
    }),
    kh = dc((e, t) => {
      mc(), lh(), qu();
      var r = (ah(), fc(rh)),
        n = r.Buffer;
      function i(e, t) {
        for (var r in e) t[r] = e[r];
      }
      function o(e, t, r) {
        return n(e, t, r);
      }
      n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow
        ? (t.exports = r)
        : (i(r, e), (e.Buffer = o)),
        (o.prototype = Object.create(n.prototype)),
        i(n, o),
        (o.from = function (e, t, r) {
          if ("number" == typeof e)
            throw new TypeError("Argument must not be a number");
          return n(e, t, r);
        }),
        (o.alloc = function (e, t, r) {
          if ("number" != typeof e)
            throw new TypeError("Argument must be a number");
          var i = n(e);
          return (
            void 0 !== t
              ? "string" == typeof r
                ? i.fill(t, r)
                : i.fill(t)
              : i.fill(0),
            i
          );
        }),
        (o.allocUnsafe = function (e) {
          if ("number" != typeof e)
            throw new TypeError("Argument must be a number");
          return n(e);
        }),
        (o.allocUnsafeSlow = function (e) {
          if ("number" != typeof e)
            throw new TypeError("Argument must be a number");
          return r.SlowBuffer(e);
        });
    }),
    Bh = dc((e) => {
      mc(), lh(), qu();
      var t = kh().Buffer,
        r =
          t.isEncoding ||
          function (e) {
            switch ((e = "" + e) && e.toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
              case "raw":
                return !0;
              default:
                return !1;
            }
          };
      function n(e) {
        var n;
        switch (
          ((this.encoding = (function (e) {
            var n = (function (e) {
              if (!e) return "utf8";
              for (var t; ; )
                switch (e) {
                  case "utf8":
                  case "utf-8":
                    return "utf8";
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return "utf16le";
                  case "latin1":
                  case "binary":
                    return "latin1";
                  case "base64":
                  case "ascii":
                  case "hex":
                    return e;
                  default:
                    if (t) return;
                    (e = ("" + e).toLowerCase()), (t = !0);
                }
            })(e);
            if ("string" != typeof n && (t.isEncoding === r || !r(e)))
              throw new Error("Unknown encoding: " + e);
            return n || e;
          })(e)),
          this.encoding)
        ) {
          case "utf16le":
            (this.text = s), (this.end = a), (n = 4);
            break;
          case "utf8":
            (this.fillLast = o), (n = 4);
            break;
          case "base64":
            (this.text = l), (this.end = c), (n = 3);
            break;
          default:
            return (this.write = u), void (this.end = h);
        }
        (this.lastNeed = 0),
          (this.lastTotal = 0),
          (this.lastChar = t.allocUnsafe(n));
      }
      function i(e) {
        return e <= 127
          ? 0
          : e >> 5 == 6
          ? 2
          : e >> 4 == 14
          ? 3
          : e >> 3 == 30
          ? 4
          : e >> 6 == 2
          ? -1
          : -2;
      }
      function o(e) {
        var t = this.lastTotal - this.lastNeed,
          r = (function (e, t) {
            if (128 != (192 & t[0])) return (e.lastNeed = 0), "";
            if (e.lastNeed > 1 && t.length > 1) {
              if (128 != (192 & t[1])) return (e.lastNeed = 1), "";
              if (e.lastNeed > 2 && t.length > 2 && 128 != (192 & t[2]))
                return (e.lastNeed = 2), "";
            }
          })(this, e);
        return void 0 !== r
          ? r
          : this.lastNeed <= e.length
          ? (e.copy(this.lastChar, t, 0, this.lastNeed),
            this.lastChar.toString(this.encoding, 0, this.lastTotal))
          : (e.copy(this.lastChar, t, 0, e.length),
            void (this.lastNeed -= e.length));
      }
      function s(e, t) {
        if ((e.length - t) % 2 == 0) {
          var r = e.toString("utf16le", t);
          if (r) {
            var n = r.charCodeAt(r.length - 1);
            if (n >= 55296 && n <= 56319)
              return (
                (this.lastNeed = 2),
                (this.lastTotal = 4),
                (this.lastChar[0] = e[e.length - 2]),
                (this.lastChar[1] = e[e.length - 1]),
                r.slice(0, -1)
              );
          }
          return r;
        }
        return (
          (this.lastNeed = 1),
          (this.lastTotal = 2),
          (this.lastChar[0] = e[e.length - 1]),
          e.toString("utf16le", t, e.length - 1)
        );
      }
      function a(e) {
        var t = e && e.length ? this.write(e) : "";
        if (this.lastNeed) {
          var r = this.lastTotal - this.lastNeed;
          return t + this.lastChar.toString("utf16le", 0, r);
        }
        return t;
      }
      function l(e, t) {
        var r = (e.length - t) % 3;
        return 0 === r
          ? e.toString("base64", t)
          : ((this.lastNeed = 3 - r),
            (this.lastTotal = 3),
            1 === r
              ? (this.lastChar[0] = e[e.length - 1])
              : ((this.lastChar[0] = e[e.length - 2]),
                (this.lastChar[1] = e[e.length - 1])),
            e.toString("base64", t, e.length - r));
      }
      function c(e) {
        var t = e && e.length ? this.write(e) : "";
        return this.lastNeed
          ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed)
          : t;
      }
      function u(e) {
        return e.toString(this.encoding);
      }
      function h(e) {
        return e && e.length ? this.write(e) : "";
      }
      (e.StringDecoder = n),
        (n.prototype.write = function (e) {
          if (0 === e.length) return "";
          var t, r;
          if (this.lastNeed) {
            if (void 0 === (t = this.fillLast(e))) return "";
            (r = this.lastNeed), (this.lastNeed = 0);
          } else r = 0;
          return r < e.length
            ? t
              ? t + this.text(e, r)
              : this.text(e, r)
            : t || "";
        }),
        (n.prototype.end = function (e) {
          var t = e && e.length ? this.write(e) : "";
          return this.lastNeed ? t + "" : t;
        }),
        (n.prototype.text = function (e, t) {
          var r = (function (e, t, r) {
            var n = t.length - 1;
            if (n < r) return 0;
            var o = i(t[n]);
            return o >= 0
              ? (o > 0 && (e.lastNeed = o - 1), o)
              : --n < r || -2 === o
              ? 0
              : (o = i(t[n])) >= 0
              ? (o > 0 && (e.lastNeed = o - 2), o)
              : --n < r || -2 === o
              ? 0
              : (o = i(t[n])) >= 0
              ? (o > 0 && (2 === o ? (o = 0) : (e.lastNeed = o - 3)), o)
              : 0;
          })(this, e, t);
          if (!this.lastNeed) return e.toString("utf8", t);
          this.lastTotal = r;
          var n = e.length - (r - this.lastNeed);
          return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n);
        }),
        (n.prototype.fillLast = function (e) {
          if (this.lastNeed <= e.length)
            return (
              e.copy(
                this.lastChar,
                this.lastTotal - this.lastNeed,
                0,
                this.lastNeed
              ),
              this.lastChar.toString(this.encoding, 0, this.lastTotal)
            );
          e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length),
            (this.lastNeed -= e.length);
        });
    }),
    Fh = dc((e, t) => {
      mc(), lh(), qu();
      var r = Ph(),
        {
          PromisePrototypeThen: n,
          SymbolAsyncIterator: i,
          SymbolIterator: o,
        } = ch(),
        { Buffer: s } = (ah(), fc(rh)),
        { ERR_INVALID_ARG_TYPE: a, ERR_STREAM_NULL_VALUES: l } = hh().codes;
      t.exports = function (e, t, c) {
        let u, h;
        if ("string" == typeof t || t instanceof s)
          return new e({
            objectMode: !0,
            ...c,
            read() {
              this.push(t), this.push(null);
            },
          });
        if (t && t[i]) (h = !0), (u = t[i]());
        else {
          if (!t || !t[o]) throw new a("iterable", ["Iterable"], t);
          (h = !1), (u = t[o]());
        }
        let d = new e({ objectMode: !0, highWaterMark: 1, ...c }),
          p = !1;
        return (
          (d._read = function () {
            p ||
              ((p = !0),
              (async function () {
                for (;;) {
                  try {
                    let { value: e, done: t } = h ? await u.next() : u.next();
                    if (t) d.push(null);
                    else {
                      let t = e && "function" == typeof e.then ? await e : e;
                      if (null === t) throw ((p = !1), new l());
                      if (d.push(t)) continue;
                      p = !1;
                    }
                  } catch (e) {
                    d.destroy(e);
                  }
                  break;
                }
              })());
          }),
          (d._destroy = function (e, t) {
            n(
              (async function (e) {
                let t = null != e,
                  r = "function" == typeof u.throw;
                if (t && r) {
                  let { value: t, done: r } = await u.throw(e);
                  if ((await t, r)) return;
                }
                if ("function" == typeof u.return) {
                  let { value: e } = await u.return();
                  await e;
                }
              })(e),
              () => r.nextTick(t, e),
              (n) => r.nextTick(t, n || e)
            );
          }),
          d
        );
      };
    }),
    Hh = dc((e, t) => {
      mc(), lh(), qu();
      var r = Ph(),
        {
          ArrayPrototypeIndexOf: n,
          NumberIsInteger: i,
          NumberIsNaN: o,
          NumberParseInt: s,
          ObjectDefineProperties: a,
          ObjectKeys: l,
          ObjectSetPrototypeOf: c,
          Promise: u,
          SafeSet: h,
          SymbolAsyncDispose: d,
          SymbolAsyncIterator: p,
          Symbol: f,
        } = ch();
      (t.exports = q), (q.ReadableState = X);
      var { EventEmitter: m } = (Th(), fc(ph)),
        { Stream: g, prependListener: _ } = Oh(),
        { Buffer: v } = (ah(), fc(rh)),
        { addAbortSignal: y } = Nh(),
        b = Ih(),
        x = Ah().debuglog("stream", (e) => {
          x = e;
        }),
        w = Uh(),
        S = Lh(),
        { getHighWaterMark: E, getDefaultHighWaterMark: M } = Dh(),
        {
          aggregateTwoErrors: T,
          codes: {
            ERR_INVALID_ARG_TYPE: A,
            ERR_METHOD_NOT_IMPLEMENTED: R,
            ERR_OUT_OF_RANGE: P,
            ERR_STREAM_PUSH_AFTER_EOF: C,
            ERR_STREAM_UNSHIFT_AFTER_END_EVENT: I,
          },
          AbortError: L,
        } = hh(),
        { validateObject: O } = Rh(),
        N = f("kPaused"),
        { StringDecoder: U } = Bh(),
        D = Fh();
      c(q.prototype, g.prototype), c(q, g);
      var k,
        B = () => {},
        { errorOrDestroy: F } = S,
        H = 1,
        z = 16,
        V = 32,
        j = 2048,
        W = 4096;
      function G(e) {
        return {
          enumerable: !1,
          get() {
            return 0 !== (this.state & e);
          },
          set(t) {
            t ? (this.state |= e) : (this.state &= ~e);
          },
        };
      }
      function X(e, t, r) {
        "boolean" != typeof r && (r = t instanceof jh()),
          (this.state = j | W | z | V),
          e && e.objectMode && (this.state |= H),
          r && e && e.readableObjectMode && (this.state |= H),
          (this.highWaterMark = e
            ? E(this, e, "readableHighWaterMark", r)
            : M(!1)),
          (this.buffer = new w()),
          (this.length = 0),
          (this.pipes = []),
          (this.flowing = null),
          (this[N] = null),
          e && !1 === e.emitClose && (this.state &= ~j),
          e && !1 === e.autoDestroy && (this.state &= ~W),
          (this.errored = null),
          (this.defaultEncoding = (e && e.defaultEncoding) || "utf8"),
          (this.awaitDrainWriters = null),
          (this.decoder = null),
          (this.encoding = null),
          e &&
            e.encoding &&
            ((this.decoder = new U(e.encoding)), (this.encoding = e.encoding));
      }
      function q(e) {
        if (!(this instanceof q)) return new q(e);
        let t = this instanceof jh();
        (this._readableState = new X(e, this, t)),
          e &&
            ("function" == typeof e.read && (this._read = e.read),
            "function" == typeof e.destroy && (this._destroy = e.destroy),
            "function" == typeof e.construct && (this._construct = e.construct),
            e.signal && !t && y(e.signal, this)),
          g.call(this, e),
          S.construct(this, () => {
            this._readableState.needReadable && Z(this, this._readableState);
          });
      }
      function Y(e, t, r, n) {
        x("readableAddChunk", t);
        let i,
          o = e._readableState;
        if (
          (0 === (o.state & H) &&
            ("string" == typeof t
              ? ((r = r || o.defaultEncoding),
                o.encoding !== r &&
                  (n && o.encoding
                    ? (t = v.from(t, r).toString(o.encoding))
                    : ((t = v.from(t, r)), (r = ""))))
              : t instanceof v
              ? (r = "")
              : g._isUint8Array(t)
              ? ((t = g._uint8ArrayToBuffer(t)), (r = ""))
              : null != t &&
                (i = new A("chunk", ["string", "Buffer", "Uint8Array"], t))),
          i)
        )
          F(e, i);
        else if (null === t)
          (o.state &= -9),
            (function (e, t) {
              if ((x("onEofChunk"), !t.ended)) {
                if (t.decoder) {
                  let e = t.decoder.end();
                  e &&
                    e.length &&
                    (t.buffer.push(e),
                    (t.length += t.objectMode ? 1 : e.length));
                }
                (t.ended = !0),
                  t.sync
                    ? Q(e)
                    : ((t.needReadable = !1), (t.emittedReadable = !0), J(e));
              }
            })(e, o);
        else if (0 !== (o.state & H) || (t && t.length > 0))
          if (n)
            if (4 & o.state) F(e, new I());
            else {
              if (o.destroyed || o.errored) return !1;
              K(e, o, t, !0);
            }
          else if (o.ended) F(e, new C());
          else {
            if (o.destroyed || o.errored) return !1;
            (o.state &= -9),
              o.decoder && !r
                ? ((t = o.decoder.write(t)),
                  o.objectMode || 0 !== t.length ? K(e, o, t, !1) : Z(e, o))
                : K(e, o, t, !1);
          }
        else n || ((o.state &= -9), Z(e, o));
        return !o.ended && (o.length < o.highWaterMark || 0 === o.length);
      }
      function K(e, t, r, n) {
        t.flowing && 0 === t.length && !t.sync && e.listenerCount("data") > 0
          ? (65536 & t.state
              ? t.awaitDrainWriters.clear()
              : (t.awaitDrainWriters = null),
            (t.dataEmitted = !0),
            e.emit("data", r))
          : ((t.length += t.objectMode ? 1 : r.length),
            n ? t.buffer.unshift(r) : t.buffer.push(r),
            !!(64 & t.state) && Q(e)),
          Z(e, t);
      }
      function $(e, t) {
        return e <= 0 || (0 === t.length && t.ended)
          ? 0
          : 0 !== (t.state & H)
          ? 1
          : o(e)
          ? t.flowing && t.length
            ? t.buffer.first().length
            : t.length
          : e <= t.length
          ? e
          : t.ended
          ? t.length
          : 0;
      }
      function Q(e) {
        let t = e._readableState;
        x("emitReadable", t.needReadable, t.emittedReadable),
          (t.needReadable = !1),
          t.emittedReadable ||
            (x("emitReadable", t.flowing),
            (t.emittedReadable = !0),
            r.nextTick(J, e));
      }
      function J(e) {
        let t = e._readableState;
        x("emitReadable_", t.destroyed, t.length, t.ended),
          !t.destroyed &&
            !t.errored &&
            (t.length || t.ended) &&
            (e.emit("readable"), (t.emittedReadable = !1)),
          (t.needReadable =
            !t.flowing && !t.ended && t.length <= t.highWaterMark),
          ie(e);
      }
      function Z(e, t) {
        !t.readingMore &&
          t.constructed &&
          ((t.readingMore = !0), r.nextTick(ee, e, t));
      }
      function ee(e, t) {
        for (
          ;
          !t.reading &&
          !t.ended &&
          (t.length < t.highWaterMark || (t.flowing && 0 === t.length));

        ) {
          let r = t.length;
          if ((x("maybeReadMore read 0"), e.read(0), r === t.length)) break;
        }
        t.readingMore = !1;
      }
      function te(e) {
        let t = e._readableState;
        (t.readableListening = e.listenerCount("readable") > 0),
          t.resumeScheduled && !1 === t[N]
            ? (t.flowing = !0)
            : e.listenerCount("data") > 0
            ? e.resume()
            : t.readableListening || (t.flowing = null);
      }
      function re(e) {
        x("readable nexttick read 0"), e.read(0);
      }
      function ne(e, t) {
        x("resume", t.reading),
          t.reading || e.read(0),
          (t.resumeScheduled = !1),
          e.emit("resume"),
          ie(e),
          t.flowing && !t.reading && e.read(0);
      }
      function ie(e) {
        let t = e._readableState;
        for (x("flow", t.flowing); t.flowing && null !== e.read(); );
      }
      function oe(e, t) {
        "function" != typeof e.read && (e = q.wrap(e, { objectMode: !0 }));
        let r = (async function* (e, t) {
          let r = B;
          function n(t) {
            this === e ? (r(), (r = B)) : (r = t);
          }
          e.on("readable", n);
          let i,
            o = b(e, { writable: !1 }, (e) => {
              (i = e ? T(i, e) : null), r(), (r = B);
            });
          try {
            for (;;) {
              let t = e.destroyed ? null : e.read();
              if (null !== t) yield t;
              else {
                if (i) throw i;
                if (null === i) return;
                await new u(n);
              }
            }
          } catch (e) {
            throw ((i = T(i, e)), i);
          } finally {
            (!i && !1 === t?.destroyOnReturn) ||
            (void 0 !== i && !e._readableState.autoDestroy)
              ? (e.off("readable", n), o())
              : S.destroyer(e, null);
          }
        })(e, t);
        return (r.stream = e), r;
      }
      function se(e, t) {
        if (0 === t.length) return null;
        let r;
        return (
          t.objectMode
            ? (r = t.buffer.shift())
            : !e || e >= t.length
            ? ((r = t.decoder
                ? t.buffer.join("")
                : 1 === t.buffer.length
                ? t.buffer.first()
                : t.buffer.concat(t.length)),
              t.buffer.clear())
            : (r = t.buffer.consume(e, t.decoder)),
          r
        );
      }
      function ae(e) {
        let t = e._readableState;
        x("endReadable", t.endEmitted),
          t.endEmitted || ((t.ended = !0), r.nextTick(le, t, e));
      }
      function le(e, t) {
        if (
          (x("endReadableNT", e.endEmitted, e.length),
          !e.errored && !e.closeEmitted && !e.endEmitted && 0 === e.length)
        )
          if (
            ((e.endEmitted = !0),
            t.emit("end"),
            t.writable && !1 === t.allowHalfOpen)
          )
            r.nextTick(ce, t);
          else if (e.autoDestroy) {
            let e = t._writableState;
            (!e || (e.autoDestroy && (e.finished || !1 === e.writable))) &&
              t.destroy();
          }
      }
      function ce(e) {
        e.writable && !e.writableEnded && !e.destroyed && e.end();
      }
      function ue() {
        return void 0 === k && (k = {}), k;
      }
      a(X.prototype, {
        objectMode: G(H),
        ended: G(2),
        endEmitted: G(4),
        reading: G(8),
        constructed: G(z),
        sync: G(V),
        needReadable: G(64),
        emittedReadable: G(128),
        readableListening: G(256),
        resumeScheduled: G(512),
        errorEmitted: G(1024),
        emitClose: G(j),
        autoDestroy: G(W),
        destroyed: G(8192),
        closed: G(16384),
        closeEmitted: G(32768),
        multiAwaitDrain: G(65536),
        readingMore: G(1 << 17),
        dataEmitted: G(1 << 18),
      }),
        (q.prototype.destroy = S.destroy),
        (q.prototype._undestroy = S.undestroy),
        (q.prototype._destroy = function (e, t) {
          t(e);
        }),
        (q.prototype[m.captureRejectionSymbol] = function (e) {
          this.destroy(e);
        }),
        (q.prototype[d] = function () {
          let e;
          return (
            this.destroyed ||
              ((e = this.readableEnded ? null : new L()), this.destroy(e)),
            new u((t, r) => b(this, (n) => (n && n !== e ? r(n) : t(null))))
          );
        }),
        (q.prototype.push = function (e, t) {
          return Y(this, e, t, !1);
        }),
        (q.prototype.unshift = function (e, t) {
          return Y(this, e, t, !0);
        }),
        (q.prototype.isPaused = function () {
          let e = this._readableState;
          return !0 === e[N] || !1 === e.flowing;
        }),
        (q.prototype.setEncoding = function (e) {
          let t = new U(e);
          (this._readableState.decoder = t),
            (this._readableState.encoding =
              this._readableState.decoder.encoding);
          let r = this._readableState.buffer,
            n = "";
          for (let e of r) n += t.write(e);
          return (
            r.clear(),
            "" !== n && r.push(n),
            (this._readableState.length = n.length),
            this
          );
        }),
        (q.prototype.read = function (e) {
          x("read", e), void 0 === e ? (e = NaN) : i(e) || (e = s(e, 10));
          let t = this._readableState,
            r = e;
          if (
            (e > t.highWaterMark &&
              (t.highWaterMark = (function (e) {
                if (e > 1073741824) throw new P("size", "<= 1GiB", e);
                return (
                  e--,
                  (e |= e >>> 1),
                  (e |= e >>> 2),
                  (e |= e >>> 4),
                  (e |= e >>> 8),
                  (e |= e >>> 16),
                  ++e
                );
              })(e)),
            0 !== e && (t.state &= -129),
            0 === e &&
              t.needReadable &&
              ((0 !== t.highWaterMark
                ? t.length >= t.highWaterMark
                : t.length > 0) ||
                t.ended))
          )
            return (
              x("read: emitReadable", t.length, t.ended),
              0 === t.length && t.ended ? ae(this) : Q(this),
              null
            );
          if (0 === (e = $(e, t)) && t.ended)
            return 0 === t.length && ae(this), null;
          let n,
            o = !!(64 & t.state);
          if (
            (x("need readable", o),
            (0 === t.length || t.length - e < t.highWaterMark) &&
              ((o = !0), x("length less than watermark", o)),
            t.ended || t.reading || t.destroyed || t.errored || !t.constructed)
          )
            (o = !1), x("reading, ended or constructing", o);
          else if (o) {
            x("do read"), (t.state |= 8 | V), 0 === t.length && (t.state |= 64);
            try {
              this._read(t.highWaterMark);
            } catch (e) {
              F(this, e);
            }
            (t.state &= ~V), t.reading || (e = $(r, t));
          }
          return (
            (n = e > 0 ? se(e, t) : null),
            null === n
              ? ((t.needReadable = t.length <= t.highWaterMark), (e = 0))
              : ((t.length -= e),
                t.multiAwaitDrain
                  ? t.awaitDrainWriters.clear()
                  : (t.awaitDrainWriters = null)),
            0 === t.length &&
              (t.ended || (t.needReadable = !0),
              r !== e && t.ended && ae(this)),
            null !== n &&
              !t.errorEmitted &&
              !t.closeEmitted &&
              ((t.dataEmitted = !0), this.emit("data", n)),
            n
          );
        }),
        (q.prototype._read = function (e) {
          throw new R("_read()");
        }),
        (q.prototype.pipe = function (e, t) {
          let n = this,
            i = this._readableState;
          1 === i.pipes.length &&
            (i.multiAwaitDrain ||
              ((i.multiAwaitDrain = !0),
              (i.awaitDrainWriters = new h(
                i.awaitDrainWriters ? [i.awaitDrainWriters] : []
              )))),
            i.pipes.push(e),
            x("pipe count=%d opts=%j", i.pipes.length, t);
          let o =
            (t && !1 === t.end) || e === r.stdout || e === r.stderr ? m : s;
          function s() {
            x("onend"), e.end();
          }
          i.endEmitted ? r.nextTick(o) : n.once("end", o),
            e.on("unpipe", function t(r, o) {
              x("onunpipe"),
                r === n &&
                  o &&
                  !1 === o.hasUnpiped &&
                  ((o.hasUnpiped = !0),
                  x("cleanup"),
                  e.removeListener("close", p),
                  e.removeListener("finish", f),
                  a && e.removeListener("drain", a),
                  e.removeListener("error", d),
                  e.removeListener("unpipe", t),
                  n.removeListener("end", s),
                  n.removeListener("end", m),
                  n.removeListener("data", u),
                  (l = !0),
                  a &&
                    i.awaitDrainWriters &&
                    (!e._writableState || e._writableState.needDrain) &&
                    a());
            });
          let a,
            l = !1;
          function c() {
            l ||
              (1 === i.pipes.length && i.pipes[0] === e
                ? (x("false write response, pause", 0),
                  (i.awaitDrainWriters = e),
                  (i.multiAwaitDrain = !1))
                : i.pipes.length > 1 &&
                  i.pipes.includes(e) &&
                  (x("false write response, pause", i.awaitDrainWriters.size),
                  i.awaitDrainWriters.add(e)),
              n.pause()),
              a ||
                ((a = (function (e, t) {
                  return function () {
                    let r = e._readableState;
                    r.awaitDrainWriters === t
                      ? (x("pipeOnDrain", 1), (r.awaitDrainWriters = null))
                      : r.multiAwaitDrain &&
                        (x("pipeOnDrain", r.awaitDrainWriters.size),
                        r.awaitDrainWriters.delete(t)),
                      (!r.awaitDrainWriters ||
                        0 === r.awaitDrainWriters.size) &&
                        e.listenerCount("data") &&
                        e.resume();
                  };
                })(n, e)),
                e.on("drain", a));
          }
          function u(t) {
            x("ondata");
            let r = e.write(t);
            x("dest.write", r), !1 === r && c();
          }
          function d(t) {
            if (
              (x("onerror", t),
              m(),
              e.removeListener("error", d),
              0 === e.listenerCount("error"))
            ) {
              let r = e._writableState || e._readableState;
              r && !r.errorEmitted ? F(e, t) : e.emit("error", t);
            }
          }
          function p() {
            e.removeListener("finish", f), m();
          }
          function f() {
            x("onfinish"), e.removeListener("close", p), m();
          }
          function m() {
            x("unpipe"), n.unpipe(e);
          }
          return (
            n.on("data", u),
            _(e, "error", d),
            e.once("close", p),
            e.once("finish", f),
            e.emit("pipe", n),
            !0 === e.writableNeedDrain
              ? c()
              : i.flowing || (x("pipe resume"), n.resume()),
            e
          );
        }),
        (q.prototype.unpipe = function (e) {
          let t = this._readableState;
          if (0 === t.pipes.length) return this;
          if (!e) {
            let e = t.pipes;
            (t.pipes = []), this.pause();
            for (let t = 0; t < e.length; t++)
              e[t].emit("unpipe", this, { hasUnpiped: !1 });
            return this;
          }
          let r = n(t.pipes, e);
          return (
            -1 === r ||
              (t.pipes.splice(r, 1),
              0 === t.pipes.length && this.pause(),
              e.emit("unpipe", this, { hasUnpiped: !1 })),
            this
          );
        }),
        (q.prototype.on = function (e, t) {
          let n = g.prototype.on.call(this, e, t),
            i = this._readableState;
          return (
            "data" === e
              ? ((i.readableListening = this.listenerCount("readable") > 0),
                !1 !== i.flowing && this.resume())
              : "readable" === e &&
                !i.endEmitted &&
                !i.readableListening &&
                ((i.readableListening = i.needReadable = !0),
                (i.flowing = !1),
                (i.emittedReadable = !1),
                x("on readable", i.length, i.reading),
                i.length ? Q(this) : i.reading || r.nextTick(re, this)),
            n
          );
        }),
        (q.prototype.addListener = q.prototype.on),
        (q.prototype.removeListener = function (e, t) {
          let n = g.prototype.removeListener.call(this, e, t);
          return "readable" === e && r.nextTick(te, this), n;
        }),
        (q.prototype.off = q.prototype.removeListener),
        (q.prototype.removeAllListeners = function (e) {
          let t = g.prototype.removeAllListeners.apply(this, arguments);
          return ("readable" === e || void 0 === e) && r.nextTick(te, this), t;
        }),
        (q.prototype.resume = function () {
          let e = this._readableState;
          return (
            e.flowing ||
              (x("resume"),
              (e.flowing = !e.readableListening),
              (function (e, t) {
                t.resumeScheduled ||
                  ((t.resumeScheduled = !0), r.nextTick(ne, e, t));
              })(this, e)),
            (e[N] = !1),
            this
          );
        }),
        (q.prototype.pause = function () {
          return (
            x("call pause flowing=%j", this._readableState.flowing),
            !1 !== this._readableState.flowing &&
              (x("pause"),
              (this._readableState.flowing = !1),
              this.emit("pause")),
            (this._readableState[N] = !0),
            this
          );
        }),
        (q.prototype.wrap = function (e) {
          let t = !1;
          e.on("data", (r) => {
            !this.push(r) && e.pause && ((t = !0), e.pause());
          }),
            e.on("end", () => {
              this.push(null);
            }),
            e.on("error", (e) => {
              F(this, e);
            }),
            e.on("close", () => {
              this.destroy();
            }),
            e.on("destroy", () => {
              this.destroy();
            }),
            (this._read = () => {
              t && e.resume && ((t = !1), e.resume());
            });
          let r = l(e);
          for (let t = 1; t < r.length; t++) {
            let n = r[t];
            void 0 === this[n] &&
              "function" == typeof e[n] &&
              (this[n] = e[n].bind(e));
          }
          return this;
        }),
        (q.prototype[p] = function () {
          return oe(this);
        }),
        (q.prototype.iterator = function (e) {
          return void 0 !== e && O(e, "options"), oe(this, e);
        }),
        a(q.prototype, {
          readable: {
            __proto__: null,
            get() {
              let e = this._readableState;
              return !(
                !e ||
                !1 === e.readable ||
                e.destroyed ||
                e.errorEmitted ||
                e.endEmitted
              );
            },
            set(e) {
              this._readableState && (this._readableState.readable = !!e);
            },
          },
          readableDidRead: {
            __proto__: null,
            enumerable: !1,
            get: function () {
              return this._readableState.dataEmitted;
            },
          },
          readableAborted: {
            __proto__: null,
            enumerable: !1,
            get: function () {
              return !(
                !1 === this._readableState.readable ||
                (!this._readableState.destroyed &&
                  !this._readableState.errored) ||
                this._readableState.endEmitted
              );
            },
          },
          readableHighWaterMark: {
            __proto__: null,
            enumerable: !1,
            get: function () {
              return this._readableState.highWaterMark;
            },
          },
          readableBuffer: {
            __proto__: null,
            enumerable: !1,
            get: function () {
              return this._readableState && this._readableState.buffer;
            },
          },
          readableFlowing: {
            __proto__: null,
            enumerable: !1,
            get: function () {
              return this._readableState.flowing;
            },
            set: function (e) {
              this._readableState && (this._readableState.flowing = e);
            },
          },
          readableLength: {
            __proto__: null,
            enumerable: !1,
            get() {
              return this._readableState.length;
            },
          },
          readableObjectMode: {
            __proto__: null,
            enumerable: !1,
            get() {
              return !!this._readableState && this._readableState.objectMode;
            },
          },
          readableEncoding: {
            __proto__: null,
            enumerable: !1,
            get() {
              return this._readableState ? this._readableState.encoding : null;
            },
          },
          errored: {
            __proto__: null,
            enumerable: !1,
            get() {
              return this._readableState ? this._readableState.errored : null;
            },
          },
          closed: {
            __proto__: null,
            get() {
              return !!this._readableState && this._readableState.closed;
            },
          },
          destroyed: {
            __proto__: null,
            enumerable: !1,
            get() {
              return !!this._readableState && this._readableState.destroyed;
            },
            set(e) {
              this._readableState && (this._readableState.destroyed = e);
            },
          },
          readableEnded: {
            __proto__: null,
            enumerable: !1,
            get() {
              return !!this._readableState && this._readableState.endEmitted;
            },
          },
        }),
        a(X.prototype, {
          pipesCount: {
            __proto__: null,
            get() {
              return this.pipes.length;
            },
          },
          paused: {
            __proto__: null,
            get() {
              return !1 !== this[N];
            },
            set(e) {
              this[N] = !!e;
            },
          },
        }),
        (q._fromList = se),
        (q.from = function (e, t) {
          return D(q, e, t);
        }),
        (q.fromWeb = function (e, t) {
          return ue().newStreamReadableFromReadableStream(e, t);
        }),
        (q.toWeb = function (e, t) {
          return ue().newReadableStreamFromStreamReadable(e, t);
        }),
        (q.wrap = function (e, t) {
          var r, n;
          return new q({
            objectMode:
              null ===
                (r =
                  null !== (n = e.readableObjectMode) && void 0 !== n
                    ? n
                    : e.objectMode) ||
              void 0 === r ||
              r,
            ...t,
            destroy(t, r) {
              S.destroyer(e, t), r(t);
            },
          }).wrap(e);
        });
    }),
    zh = dc((e, t) => {
      mc(), lh(), qu();
      var r = Ph(),
        {
          ArrayPrototypeSlice: n,
          Error: i,
          FunctionPrototypeSymbolHasInstance: o,
          ObjectDefineProperty: s,
          ObjectDefineProperties: a,
          ObjectSetPrototypeOf: l,
          StringPrototypeToLowerCase: c,
          Symbol: u,
          SymbolHasInstance: h,
        } = ch();
      (t.exports = O), (O.WritableState = I);
      var { EventEmitter: d } = (Th(), fc(ph)),
        p = Oh().Stream,
        { Buffer: f } = (ah(), fc(rh)),
        m = Lh(),
        { addAbortSignal: g } = Nh(),
        { getHighWaterMark: _, getDefaultHighWaterMark: v } = Dh(),
        {
          ERR_INVALID_ARG_TYPE: y,
          ERR_METHOD_NOT_IMPLEMENTED: b,
          ERR_MULTIPLE_CALLBACK: x,
          ERR_STREAM_CANNOT_PIPE: w,
          ERR_STREAM_DESTROYED: S,
          ERR_STREAM_ALREADY_FINISHED: E,
          ERR_STREAM_NULL_VALUES: M,
          ERR_STREAM_WRITE_AFTER_END: T,
          ERR_UNKNOWN_ENCODING: A,
        } = hh().codes,
        { errorOrDestroy: R } = m;
      function P() {}
      l(O.prototype, p.prototype), l(O, p);
      var C = u("kOnFinished");
      function I(e, t, r) {
        "boolean" != typeof r && (r = t instanceof jh()),
          (this.objectMode = !(!e || !e.objectMode)),
          r &&
            (this.objectMode =
              this.objectMode || !(!e || !e.writableObjectMode)),
          (this.highWaterMark = e
            ? _(this, e, "writableHighWaterMark", r)
            : v(!1)),
          (this.finalCalled = !1),
          (this.needDrain = !1),
          (this.ending = !1),
          (this.ended = !1),
          (this.finished = !1),
          (this.destroyed = !1);
        let n = !(!e || !1 !== e.decodeStrings);
        (this.decodeStrings = !n),
          (this.defaultEncoding = (e && e.defaultEncoding) || "utf8"),
          (this.length = 0),
          (this.writing = !1),
          (this.corked = 0),
          (this.sync = !0),
          (this.bufferProcessing = !1),
          (this.onwrite = k.bind(void 0, t)),
          (this.writecb = null),
          (this.writelen = 0),
          (this.afterWriteTickInfo = null),
          L(this),
          (this.pendingcb = 0),
          (this.constructed = !0),
          (this.prefinished = !1),
          (this.errorEmitted = !1),
          (this.emitClose = !e || !1 !== e.emitClose),
          (this.autoDestroy = !e || !1 !== e.autoDestroy),
          (this.errored = null),
          (this.closed = !1),
          (this.closeEmitted = !1),
          (this[C] = []);
      }
      function L(e) {
        (e.buffered = []),
          (e.bufferedIndex = 0),
          (e.allBuffers = !0),
          (e.allNoop = !0);
      }
      function O(e) {
        let t = this instanceof jh();
        if (!t && !o(O, this)) return new O(e);
        (this._writableState = new I(e, this, t)),
          e &&
            ("function" == typeof e.write && (this._write = e.write),
            "function" == typeof e.writev && (this._writev = e.writev),
            "function" == typeof e.destroy && (this._destroy = e.destroy),
            "function" == typeof e.final && (this._final = e.final),
            "function" == typeof e.construct && (this._construct = e.construct),
            e.signal && g(e.signal, this)),
          p.call(this, e),
          m.construct(this, () => {
            let e = this._writableState;
            e.writing || z(this, e), j(this, e);
          });
      }
      function N(e, t, n, i) {
        let o,
          s = e._writableState;
        if ("function" == typeof n) (i = n), (n = s.defaultEncoding);
        else {
          if (n) {
            if ("buffer" !== n && !f.isEncoding(n)) throw new A(n);
          } else n = s.defaultEncoding;
          "function" != typeof i && (i = P);
        }
        if (null === t) throw new M();
        if (!s.objectMode)
          if ("string" == typeof t)
            !1 !== s.decodeStrings && ((t = f.from(t, n)), (n = "buffer"));
          else if (t instanceof f) n = "buffer";
          else {
            if (!p._isUint8Array(t))
              throw new y("chunk", ["string", "Buffer", "Uint8Array"], t);
            (t = p._uint8ArrayToBuffer(t)), (n = "buffer");
          }
        return (
          s.ending ? (o = new T()) : s.destroyed && (o = new S("write")),
          o
            ? (r.nextTick(i, o), R(e, o, !0), o)
            : (s.pendingcb++,
              (function (e, t, r, n, i) {
                let o = t.objectMode ? 1 : r.length;
                t.length += o;
                let s = t.length < t.highWaterMark;
                return (
                  s || (t.needDrain = !0),
                  t.writing || t.corked || t.errored || !t.constructed
                    ? (t.buffered.push({ chunk: r, encoding: n, callback: i }),
                      t.allBuffers && "buffer" !== n && (t.allBuffers = !1),
                      t.allNoop && i !== P && (t.allNoop = !1))
                    : ((t.writelen = o),
                      (t.writecb = i),
                      (t.writing = !0),
                      (t.sync = !0),
                      e._write(r, n, t.onwrite),
                      (t.sync = !1)),
                  s && !t.errored && !t.destroyed
                );
              })(e, s, t, n, i))
        );
      }
      function U(e, t, r, n, i, o, s) {
        (t.writelen = n),
          (t.writecb = s),
          (t.writing = !0),
          (t.sync = !0),
          t.destroyed
            ? t.onwrite(new S("write"))
            : r
            ? e._writev(i, t.onwrite)
            : e._write(i, o, t.onwrite),
          (t.sync = !1);
      }
      function D(e, t, r, n) {
        --t.pendingcb, n(r), H(t), R(e, r);
      }
      function k(e, t) {
        let n = e._writableState,
          i = n.sync,
          o = n.writecb;
        "function" == typeof o
          ? ((n.writing = !1),
            (n.writecb = null),
            (n.length -= n.writelen),
            (n.writelen = 0),
            t
              ? (t.stack,
                n.errored || (n.errored = t),
                e._readableState &&
                  !e._readableState.errored &&
                  (e._readableState.errored = t),
                i ? r.nextTick(D, e, n, t, o) : D(e, n, t, o))
              : (n.buffered.length > n.bufferedIndex && z(e, n),
                i
                  ? null !== n.afterWriteTickInfo &&
                    n.afterWriteTickInfo.cb === o
                    ? n.afterWriteTickInfo.count++
                    : ((n.afterWriteTickInfo = {
                        count: 1,
                        cb: o,
                        stream: e,
                        state: n,
                      }),
                      r.nextTick(B, n.afterWriteTickInfo))
                  : F(e, n, 1, o)))
          : R(e, new x());
      }
      function B({ stream: e, state: t, count: r, cb: n }) {
        return (t.afterWriteTickInfo = null), F(e, t, r, n);
      }
      function F(e, t, r, n) {
        for (
          !t.ending &&
          !e.destroyed &&
          0 === t.length &&
          t.needDrain &&
          ((t.needDrain = !1), e.emit("drain"));
          r-- > 0;

        )
          t.pendingcb--, n();
        t.destroyed && H(t), j(e, t);
      }
      function H(e) {
        if (e.writing) return;
        for (let r = e.bufferedIndex; r < e.buffered.length; ++r) {
          var t;
          let { chunk: n, callback: i } = e.buffered[r],
            o = e.objectMode ? 1 : n.length;
          (e.length -= o),
            i(null !== (t = e.errored) && void 0 !== t ? t : new S("write"));
        }
        let r = e[C].splice(0);
        for (let t = 0; t < r.length; t++) {
          var n;
          r[t](null !== (n = e.errored) && void 0 !== n ? n : new S("end"));
        }
        L(e);
      }
      function z(e, t) {
        if (t.corked || t.bufferProcessing || t.destroyed || !t.constructed)
          return;
        let { buffered: r, bufferedIndex: i, objectMode: o } = t,
          s = r.length - i;
        if (!s) return;
        let a = i;
        if (((t.bufferProcessing = !0), s > 1 && e._writev)) {
          t.pendingcb -= s - 1;
          let i = t.allNoop
              ? P
              : (e) => {
                  for (let t = a; t < r.length; ++t) r[t].callback(e);
                },
            o = t.allNoop && 0 === a ? r : n(r, a);
          (o.allBuffers = t.allBuffers), U(e, t, !0, t.length, o, "", i), L(t);
        } else {
          do {
            let { chunk: n, encoding: i, callback: s } = r[a];
            (r[a++] = null), U(e, t, !1, o ? 1 : n.length, n, i, s);
          } while (a < r.length && !t.writing);
          a === r.length
            ? L(t)
            : a > 256
            ? (r.splice(0, a), (t.bufferedIndex = 0))
            : (t.bufferedIndex = a);
        }
        t.bufferProcessing = !1;
      }
      function V(e) {
        return (
          e.ending &&
          !e.destroyed &&
          e.constructed &&
          0 === e.length &&
          !e.errored &&
          0 === e.buffered.length &&
          !e.finished &&
          !e.writing &&
          !e.errorEmitted &&
          !e.closeEmitted
        );
      }
      function j(e, t, n) {
        V(t) &&
          ((function (e, t) {
            !t.prefinished &&
              !t.finalCalled &&
              ("function" != typeof e._final || t.destroyed
                ? ((t.prefinished = !0), e.emit("prefinish"))
                : ((t.finalCalled = !0),
                  (function (e, t) {
                    let n = !1;
                    function i(i) {
                      if (n) R(e, i ?? x());
                      else if (((n = !0), t.pendingcb--, i)) {
                        let r = t[C].splice(0);
                        for (let e = 0; e < r.length; e++) r[e](i);
                        R(e, i, t.sync);
                      } else
                        V(t) &&
                          ((t.prefinished = !0),
                          e.emit("prefinish"),
                          t.pendingcb++,
                          r.nextTick(W, e, t));
                    }
                    (t.sync = !0), t.pendingcb++;
                    try {
                      e._final(i);
                    } catch (e) {
                      i(e);
                    }
                    t.sync = !1;
                  })(e, t)));
          })(e, t),
          0 === t.pendingcb &&
            (n
              ? (t.pendingcb++,
                r.nextTick(
                  (e, t) => {
                    V(t) ? W(e, t) : t.pendingcb--;
                  },
                  e,
                  t
                ))
              : V(t) && (t.pendingcb++, W(e, t))));
      }
      function W(e, t) {
        t.pendingcb--, (t.finished = !0);
        let r = t[C].splice(0);
        for (let e = 0; e < r.length; e++) r[e]();
        if ((e.emit("finish"), t.autoDestroy)) {
          let t = e._readableState;
          (!t || (t.autoDestroy && (t.endEmitted || !1 === t.readable))) &&
            e.destroy();
        }
      }
      (I.prototype.getBuffer = function () {
        return n(this.buffered, this.bufferedIndex);
      }),
        s(I.prototype, "bufferedRequestCount", {
          __proto__: null,
          get() {
            return this.buffered.length - this.bufferedIndex;
          },
        }),
        s(O, h, {
          __proto__: null,
          value: function (e) {
            return (
              !!o(this, e) || (this === O && e && e._writableState instanceof I)
            );
          },
        }),
        (O.prototype.pipe = function () {
          R(this, new w());
        }),
        (O.prototype.write = function (e, t, r) {
          return !0 === N(this, e, t, r);
        }),
        (O.prototype.cork = function () {
          this._writableState.corked++;
        }),
        (O.prototype.uncork = function () {
          let e = this._writableState;
          e.corked && (e.corked--, e.writing || z(this, e));
        }),
        (O.prototype.setDefaultEncoding = function (e) {
          if (("string" == typeof e && (e = c(e)), !f.isEncoding(e)))
            throw new A(e);
          return (this._writableState.defaultEncoding = e), this;
        }),
        (O.prototype._write = function (e, t, r) {
          if (!this._writev) throw new b("_write()");
          this._writev([{ chunk: e, encoding: t }], r);
        }),
        (O.prototype._writev = null),
        (O.prototype.end = function (e, t, n) {
          let o,
            s = this._writableState;
          if (
            ("function" == typeof e
              ? ((n = e), (e = null), (t = null))
              : "function" == typeof t && ((n = t), (t = null)),
            null != e)
          ) {
            let r = N(this, e, t);
            r instanceof i && (o = r);
          }
          return (
            s.corked && ((s.corked = 1), this.uncork()),
            o ||
              (s.errored || s.ending
                ? s.finished
                  ? (o = new E("end"))
                  : s.destroyed && (o = new S("end"))
                : ((s.ending = !0), j(this, s, !0), (s.ended = !0))),
            "function" == typeof n &&
              (o || s.finished ? r.nextTick(n, o) : s[C].push(n)),
            this
          );
        }),
        a(O.prototype, {
          closed: {
            __proto__: null,
            get() {
              return !!this._writableState && this._writableState.closed;
            },
          },
          destroyed: {
            __proto__: null,
            get() {
              return !!this._writableState && this._writableState.destroyed;
            },
            set(e) {
              this._writableState && (this._writableState.destroyed = e);
            },
          },
          writable: {
            __proto__: null,
            get() {
              let e = this._writableState;
              return !(
                !e ||
                !1 === e.writable ||
                e.destroyed ||
                e.errored ||
                e.ending ||
                e.ended
              );
            },
            set(e) {
              this._writableState && (this._writableState.writable = !!e);
            },
          },
          writableFinished: {
            __proto__: null,
            get() {
              return !!this._writableState && this._writableState.finished;
            },
          },
          writableObjectMode: {
            __proto__: null,
            get() {
              return !!this._writableState && this._writableState.objectMode;
            },
          },
          writableBuffer: {
            __proto__: null,
            get() {
              return this._writableState && this._writableState.getBuffer();
            },
          },
          writableEnded: {
            __proto__: null,
            get() {
              return !!this._writableState && this._writableState.ending;
            },
          },
          writableNeedDrain: {
            __proto__: null,
            get() {
              let e = this._writableState;
              return !!e && !e.destroyed && !e.ending && e.needDrain;
            },
          },
          writableHighWaterMark: {
            __proto__: null,
            get() {
              return this._writableState && this._writableState.highWaterMark;
            },
          },
          writableCorked: {
            __proto__: null,
            get() {
              return this._writableState ? this._writableState.corked : 0;
            },
          },
          writableLength: {
            __proto__: null,
            get() {
              return this._writableState && this._writableState.length;
            },
          },
          errored: {
            __proto__: null,
            enumerable: !1,
            get() {
              return this._writableState ? this._writableState.errored : null;
            },
          },
          writableAborted: {
            __proto__: null,
            enumerable: !1,
            get: function () {
              return !(
                !1 === this._writableState.writable ||
                (!this._writableState.destroyed &&
                  !this._writableState.errored) ||
                this._writableState.finished
              );
            },
          },
        });
      var G,
        X = m.destroy;
      function q() {
        return void 0 === G && (G = {}), G;
      }
      (O.prototype.destroy = function (e, t) {
        let n = this._writableState;
        return (
          !n.destroyed &&
            (n.bufferedIndex < n.buffered.length || n[C].length) &&
            r.nextTick(H, n),
          X.call(this, e, t),
          this
        );
      }),
        (O.prototype._undestroy = m.undestroy),
        (O.prototype._destroy = function (e, t) {
          t(e);
        }),
        (O.prototype[d.captureRejectionSymbol] = function (e) {
          this.destroy(e);
        }),
        (O.fromWeb = function (e, t) {
          return q().newStreamWritableFromWritableStream(e, t);
        }),
        (O.toWeb = function (e) {
          return q().newWritableStreamFromStreamWritable(e);
        });
    }),
    Vh = dc((e, t) => {
      mc(), lh(), qu();
      var r = Ph(),
        n = (ah(), fc(rh)),
        {
          isReadable: i,
          isWritable: o,
          isIterable: s,
          isNodeStream: a,
          isReadableNodeStream: l,
          isWritableNodeStream: c,
          isDuplexNodeStream: u,
          isReadableStream: h,
          isWritableStream: d,
        } = Ch(),
        p = Ih(),
        {
          AbortError: f,
          codes: { ERR_INVALID_ARG_TYPE: m, ERR_INVALID_RETURN_VALUE: g },
        } = hh(),
        { destroyer: _ } = Lh(),
        v = jh(),
        y = Hh(),
        b = zh(),
        { createDeferredPromise: x } = Ah(),
        w = Fh(),
        S = globalThis.Blob || n.Blob,
        E =
          typeof S < "u"
            ? function (e) {
                return e instanceof S;
              }
            : function (e) {
                return !1;
              },
        M = globalThis.AbortController || dh().AbortController,
        { FunctionPrototypeCall: T } = ch(),
        A = class extends v {
          constructor(e) {
            super(e),
              !1 === e?.readable &&
                ((this._readableState.readable = !1),
                (this._readableState.ended = !0),
                (this._readableState.endEmitted = !0)),
              !1 === e?.writable &&
                ((this._writableState.writable = !1),
                (this._writableState.ending = !0),
                (this._writableState.ended = !0),
                (this._writableState.finished = !0));
          }
        };
      function R(e) {
        let t,
          r,
          n,
          s,
          a,
          l =
            e.readable && "function" != typeof e.readable.read
              ? y.wrap(e.readable)
              : e.readable,
          c = e.writable,
          u = !!i(l),
          h = !!o(c);
        function d(e) {
          let t = s;
          (s = null), t ? t(e) : e && a.destroy(e);
        }
        return (
          (a = new A({
            readableObjectMode: !(null == l || !l.readableObjectMode),
            writableObjectMode: !(null == c || !c.writableObjectMode),
            readable: u,
            writable: h,
          })),
          h &&
            (p(c, (e) => {
              (h = !1), e && _(l, e), d(e);
            }),
            (a._write = function (e, r, n) {
              c.write(e, r) ? n() : (t = n);
            }),
            (a._final = function (e) {
              c.end(), (r = e);
            }),
            c.on("drain", function () {
              if (t) {
                let e = t;
                (t = null), e();
              }
            }),
            c.on("finish", function () {
              if (r) {
                let e = r;
                (r = null), e();
              }
            })),
          u &&
            (p(l, (e) => {
              (u = !1), e && _(l, e), d(e);
            }),
            l.on("readable", function () {
              if (n) {
                let e = n;
                (n = null), e();
              }
            }),
            l.on("end", function () {
              a.push(null);
            }),
            (a._read = function () {
              for (;;) {
                let e = l.read();
                if (null === e) return void (n = a._read);
                if (!a.push(e)) return;
              }
            })),
          (a._destroy = function (e, i) {
            !e && null !== s && (e = new f()),
              (n = null),
              (t = null),
              (r = null),
              null === s ? i(e) : ((s = i), _(c, e), _(l, e));
          }),
          a
        );
      }
      t.exports = function e(t, n) {
        if (u(t)) return t;
        if (l(t)) return R({ readable: t });
        if (c(t)) return R({ writable: t });
        if (a(t)) return R({ writable: !1, readable: !1 });
        if (h(t)) return R({ readable: y.fromWeb(t) });
        if (d(t)) return R({ writable: b.fromWeb(t) });
        if ("function" == typeof t) {
          let {
            value: e,
            write: i,
            final: o,
            destroy: a,
          } = (function (e) {
            let { promise: t, resolve: n } = x(),
              i = new M(),
              o = i.signal;
            return {
              value: e(
                (async function* () {
                  for (;;) {
                    let e = t;
                    t = null;
                    let { chunk: i, done: s, cb: a } = await e;
                    if ((r.nextTick(a), s)) return;
                    if (o.aborted) throw new f(void 0, { cause: o.reason });
                    ({ promise: t, resolve: n } = x()), yield i;
                  }
                })(),
                { signal: o }
              ),
              write(e, t, r) {
                let i = n;
                (n = null), i({ chunk: e, done: !1, cb: r });
              },
              final(e) {
                let t = n;
                (n = null), t({ done: !0, cb: e });
              },
              destroy(e, t) {
                i.abort(), t(e);
              },
            };
          })(t);
          if (s(e))
            return w(A, e, { objectMode: !0, write: i, final: o, destroy: a });
          let l = e?.then;
          if ("function" == typeof l) {
            let t,
              n = T(
                l,
                e,
                (e) => {
                  if (null != e) throw new g("nully", "body", e);
                },
                (e) => {
                  _(t, e);
                }
              );
            return (t = new A({
              objectMode: !0,
              readable: !1,
              write: i,
              final(e) {
                o(async () => {
                  try {
                    await n, r.nextTick(e, null);
                  } catch (t) {
                    r.nextTick(e, t);
                  }
                });
              },
              destroy: a,
            }));
          }
          throw new g("Iterable, AsyncIterable or AsyncFunction", n, e);
        }
        if (E(t)) return e(t.arrayBuffer());
        if (s(t)) return w(A, t, { objectMode: !0, writable: !1 });
        if (h(t?.readable) && d(t?.writable)) return A.fromWeb(t);
        if ("object" == typeof t?.writable || "object" == typeof t?.readable)
          return R({
            readable:
              null != t && t.readable
                ? l(t?.readable)
                  ? t?.readable
                  : e(t.readable)
                : void 0,
            writable:
              null != t && t.writable
                ? c(t?.writable)
                  ? t?.writable
                  : e(t.writable)
                : void 0,
          });
        let i = t?.then;
        if ("function" == typeof i) {
          let e;
          return (
            T(
              i,
              t,
              (t) => {
                null != t && e.push(t), e.push(null);
              },
              (t) => {
                _(e, t);
              }
            ),
            (e = new A({ objectMode: !0, writable: !1, read() {} }))
          );
        }
        throw new m(
          n,
          [
            "Blob",
            "ReadableStream",
            "WritableStream",
            "Stream",
            "Iterable",
            "AsyncIterable",
            "Function",
            "{ readable, writable } pair",
            "Promise",
          ],
          t
        );
      };
    }),
    jh = dc((e, t) => {
      mc(), lh(), qu();
      var {
        ObjectDefineProperties: r,
        ObjectGetOwnPropertyDescriptor: n,
        ObjectKeys: i,
        ObjectSetPrototypeOf: o,
      } = ch();
      t.exports = u;
      var s,
        a,
        l = Hh(),
        c = zh();
      o(u.prototype, l.prototype), o(u, l);
      {
        let e = i(c.prototype);
        for (let t = 0; t < e.length; t++) {
          let r = e[t];
          u.prototype[r] || (u.prototype[r] = c.prototype[r]);
        }
      }
      function u(e) {
        if (!(this instanceof u)) return new u(e);
        l.call(this, e),
          c.call(this, e),
          e
            ? ((this.allowHalfOpen = !1 !== e.allowHalfOpen),
              !1 === e.readable &&
                ((this._readableState.readable = !1),
                (this._readableState.ended = !0),
                (this._readableState.endEmitted = !0)),
              !1 === e.writable &&
                ((this._writableState.writable = !1),
                (this._writableState.ending = !0),
                (this._writableState.ended = !0),
                (this._writableState.finished = !0)))
            : (this.allowHalfOpen = !0);
      }
      function h() {
        return void 0 === s && (s = {}), s;
      }
      r(u.prototype, {
        writable: { __proto__: null, ...n(c.prototype, "writable") },
        writableHighWaterMark: {
          __proto__: null,
          ...n(c.prototype, "writableHighWaterMark"),
        },
        writableObjectMode: {
          __proto__: null,
          ...n(c.prototype, "writableObjectMode"),
        },
        writableBuffer: {
          __proto__: null,
          ...n(c.prototype, "writableBuffer"),
        },
        writableLength: {
          __proto__: null,
          ...n(c.prototype, "writableLength"),
        },
        writableFinished: {
          __proto__: null,
          ...n(c.prototype, "writableFinished"),
        },
        writableCorked: {
          __proto__: null,
          ...n(c.prototype, "writableCorked"),
        },
        writableEnded: { __proto__: null, ...n(c.prototype, "writableEnded") },
        writableNeedDrain: {
          __proto__: null,
          ...n(c.prototype, "writableNeedDrain"),
        },
        destroyed: {
          __proto__: null,
          get() {
            return (
              void 0 !== this._readableState &&
              void 0 !== this._writableState &&
              this._readableState.destroyed &&
              this._writableState.destroyed
            );
          },
          set(e) {
            this._readableState &&
              this._writableState &&
              ((this._readableState.destroyed = e),
              (this._writableState.destroyed = e));
          },
        },
      }),
        (u.fromWeb = function (e, t) {
          return h().newStreamDuplexFromReadableWritablePair(e, t);
        }),
        (u.toWeb = function (e) {
          return h().newReadableWritablePairFromDuplex(e);
        }),
        (u.from = function (e) {
          return a || (a = Vh()), a(e, "body");
        });
    }),
    Wh = dc((e, t) => {
      mc(), lh(), qu();
      var { ObjectSetPrototypeOf: r, Symbol: n } = ch();
      t.exports = l;
      var { ERR_METHOD_NOT_IMPLEMENTED: i } = hh().codes,
        o = jh(),
        { getHighWaterMark: s } = Dh();
      r(l.prototype, o.prototype), r(l, o);
      var a = n("kCallback");
      function l(e) {
        if (!(this instanceof l)) return new l(e);
        let t = e ? s(this, e, "readableHighWaterMark", !0) : null;
        0 === t &&
          (e = {
            ...e,
            highWaterMark: null,
            readableHighWaterMark: t,
            writableHighWaterMark: e.writableHighWaterMark || 0,
          }),
          o.call(this, e),
          (this._readableState.sync = !1),
          (this[a] = null),
          e &&
            ("function" == typeof e.transform &&
              (this._transform = e.transform),
            "function" == typeof e.flush && (this._flush = e.flush)),
          this.on("prefinish", u);
      }
      function c(e) {
        "function" != typeof this._flush || this.destroyed
          ? (this.push(null), e && e())
          : this._flush((t, r) => {
              t
                ? e
                  ? e(t)
                  : this.destroy(t)
                : (null != r && this.push(r), this.push(null), e && e());
            });
      }
      function u() {
        this._final !== c && c.call(this);
      }
      (l.prototype._final = c),
        (l.prototype._transform = function (e, t, r) {
          throw new i("_transform()");
        }),
        (l.prototype._write = function (e, t, r) {
          let n = this._readableState,
            i = this._writableState,
            o = n.length;
          this._transform(e, t, (e, t) => {
            e
              ? r(e)
              : (null != t && this.push(t),
                i.ended || o === n.length || n.length < n.highWaterMark
                  ? r()
                  : (this[a] = r));
          });
        }),
        (l.prototype._read = function () {
          if (this[a]) {
            let e = this[a];
            (this[a] = null), e();
          }
        });
    }),
    Gh = dc((e, t) => {
      mc(), lh(), qu();
      var { ObjectSetPrototypeOf: r } = ch();
      t.exports = i;
      var n = Wh();
      function i(e) {
        if (!(this instanceof i)) return new i(e);
        n.call(this, e);
      }
      r(i.prototype, n.prototype),
        r(i, n),
        (i.prototype._transform = function (e, t, r) {
          r(null, e);
        });
    }),
    Xh = dc((e, t) => {
      mc(), lh(), qu();
      var r,
        n,
        i,
        o = Ph(),
        {
          ArrayIsArray: s,
          Promise: a,
          SymbolAsyncIterator: l,
          SymbolDispose: c,
        } = ch(),
        u = Ih(),
        { once: h } = Ah(),
        d = Lh(),
        p = jh(),
        {
          aggregateTwoErrors: f,
          codes: {
            ERR_INVALID_ARG_TYPE: m,
            ERR_INVALID_RETURN_VALUE: g,
            ERR_MISSING_ARGS: _,
            ERR_STREAM_DESTROYED: v,
            ERR_STREAM_PREMATURE_CLOSE: y,
          },
          AbortError: b,
        } = hh(),
        { validateFunction: x, validateAbortSignal: w } = Rh(),
        {
          isIterable: S,
          isReadable: E,
          isReadableNodeStream: M,
          isNodeStream: T,
          isTransformStream: A,
          isWebStream: R,
          isReadableStream: P,
          isReadableFinished: C,
        } = Ch(),
        I = globalThis.AbortController || dh().AbortController;
      function L(e, t, r) {
        let n = !1;
        return (
          e.on("close", () => {
            n = !0;
          }),
          {
            destroy: (t) => {
              n || ((n = !0), d.destroyer(e, t || new v("pipe")));
            },
            cleanup: u(e, { readable: t, writable: r }, (e) => {
              n = !e;
            }),
          }
        );
      }
      function O(e) {
        if (S(e)) return e;
        if (M(e))
          return (async function* (e) {
            n || (n = Hh()), yield* n.prototype[l].call(e);
          })(e);
        throw new m("val", ["Readable", "Iterable", "AsyncIterable"], e);
      }
      async function N(e, t, r, { end: n }) {
        let i,
          o = null,
          s = (e) => {
            if ((e && (i = e), o)) {
              let e = o;
              (o = null), e();
            }
          },
          l = () =>
            new a((e, t) => {
              i
                ? t(i)
                : (o = () => {
                    i ? t(i) : e();
                  });
            });
        t.on("drain", s);
        let c = u(t, { readable: !1 }, s);
        try {
          t.writableNeedDrain && (await l());
          for await (let r of e) t.write(r) || (await l());
          n && (t.end(), await l()), r();
        } catch (e) {
          r(i !== e ? f(i, e) : e);
        } finally {
          c(), t.off("drain", s);
        }
      }
      async function U(e, t, r, { end: n }) {
        A(t) && (t = t.writable);
        let i = t.getWriter();
        try {
          for await (let t of e) await i.ready, i.write(t).catch(() => {});
          await i.ready, n && (await i.close()), r();
        } catch (e) {
          try {
            await i.abort(e), r(e);
          } catch (e) {
            r(e);
          }
        }
      }
      function D(e, t, n) {
        if ((1 === e.length && s(e[0]) && (e = e[0]), e.length < 2))
          throw new _("streams");
        let a,
          l = new I(),
          u = l.signal,
          h = n?.signal,
          d = [];
        function f() {
          F(new b());
        }
        w(h, "options.signal"),
          (i = i || Ah().addAbortListener),
          h && (a = i(h, f));
        let v,
          y,
          x,
          C = [],
          D = 0;
        function B(e) {
          F(e, 0 === --D);
        }
        function F(e, r) {
          var n;
          if (
            (e && (!v || "ERR_STREAM_PREMATURE_CLOSE" === v.code) && (v = e),
            v || r)
          ) {
            for (; C.length; ) C.shift()(v);
            null === (n = a) || void 0 === n || n[c](),
              l.abort(),
              r && (v || d.forEach((e) => e()), o.nextTick(t, v, y));
          }
        }
        for (let t = 0; t < e.length; t++) {
          let i = e[t],
            s = t < e.length - 1,
            a = t > 0,
            l = s || !1 !== n?.end,
            c = t === e.length - 1;
          if (T(i)) {
            let e = function (e) {
              e &&
                "AbortError" !== e.name &&
                "ERR_STREAM_PREMATURE_CLOSE" !== e.code &&
                B(e);
            };
            if (l) {
              let { destroy: e, cleanup: t } = L(i, s, a);
              C.push(e), E(i) && c && d.push(t);
            }
            i.on("error", e),
              E(i) &&
                c &&
                d.push(() => {
                  i.removeListener("error", e);
                });
          }
          if (0 === t)
            if ("function" == typeof i) {
              if (((x = i({ signal: u })), !S(x)))
                throw new g("Iterable, AsyncIterable or Stream", "source", x);
            } else x = S(i) || M(i) || A(i) ? i : p.from(i);
          else if ("function" == typeof i) {
            var H;
            if (
              ((x = A(x)
                ? O(null === (H = x) || void 0 === H ? void 0 : H.readable)
                : O(x)),
              (x = i(x, { signal: u })),
              s)
            ) {
              if (!S(x, !0))
                throw new g("AsyncIterable", `transform[${t - 1}]`, x);
            } else {
              var z;
              r || (r = Gh());
              let e = new r({ objectMode: !0 }),
                t = null === (z = x) || void 0 === z ? void 0 : z.then;
              if ("function" == typeof t)
                D++,
                  t.call(
                    x,
                    (t) => {
                      (y = t),
                        null != t && e.write(t),
                        l && e.end(),
                        o.nextTick(B);
                    },
                    (t) => {
                      e.destroy(t), o.nextTick(B, t);
                    }
                  );
              else if (S(x, !0)) D++, N(x, e, B, { end: l });
              else {
                if (!P(x) && !A(x))
                  throw new g("AsyncIterable or Promise", "destination", x);
                {
                  let t = x.readable || x;
                  D++, N(t, e, B, { end: l });
                }
              }
              x = e;
              let { destroy: n, cleanup: i } = L(x, !1, !0);
              C.push(n), c && d.push(i);
            }
          } else if (T(i)) {
            if (M(x)) {
              D += 2;
              let e = k(x, i, B, { end: l });
              E(i) && c && d.push(e);
            } else if (A(x) || P(x)) {
              let e = x.readable || x;
              D++, N(e, i, B, { end: l });
            } else {
              if (!S(x))
                throw new m(
                  "val",
                  [
                    "Readable",
                    "Iterable",
                    "AsyncIterable",
                    "ReadableStream",
                    "TransformStream",
                  ],
                  x
                );
              D++, N(x, i, B, { end: l });
            }
            x = i;
          } else if (R(i)) {
            if (M(x)) D++, U(O(x), i, B, { end: l });
            else if (P(x) || S(x)) D++, U(x, i, B, { end: l });
            else {
              if (!A(x))
                throw new m(
                  "val",
                  [
                    "Readable",
                    "Iterable",
                    "AsyncIterable",
                    "ReadableStream",
                    "TransformStream",
                  ],
                  x
                );
              D++, U(x.readable, i, B, { end: l });
            }
            x = i;
          } else x = p.from(i);
        }
        return (
          ((null != u && u.aborted) || (null != h && h.aborted)) &&
            o.nextTick(f),
          x
        );
      }
      function k(e, t, r, { end: n }) {
        let i = !1;
        if (
          (t.on("close", () => {
            i || r(new y());
          }),
          e.pipe(t, { end: !1 }),
          n)
        ) {
          let r = function () {
            (i = !0), t.end();
          };
          C(e) ? o.nextTick(r) : e.once("end", r);
        } else r();
        return (
          u(e, { readable: !0, writable: !1 }, (t) => {
            let n = e._readableState;
            t &&
            "ERR_STREAM_PREMATURE_CLOSE" === t.code &&
            n &&
            n.ended &&
            !n.errored &&
            !n.errorEmitted
              ? e.once("end", r).once("error", r)
              : r(t);
          }),
          u(t, { readable: !1, writable: !0 }, r)
        );
      }
      t.exports = {
        pipelineImpl: D,
        pipeline: function (...e) {
          return D(
            e,
            h(
              (function (e) {
                return (
                  x(e[e.length - 1], "streams[stream.length - 1]"), e.pop()
                );
              })(e)
            )
          );
        },
      };
    }),
    qh = dc((e, t) => {
      mc(), lh(), qu();
      var { pipeline: r } = Xh(),
        n = jh(),
        { destroyer: i } = Lh(),
        {
          isNodeStream: o,
          isReadable: s,
          isWritable: a,
          isWebStream: l,
          isTransformStream: c,
          isWritableStream: u,
          isReadableStream: h,
        } = Ch(),
        {
          AbortError: d,
          codes: { ERR_INVALID_ARG_VALUE: p, ERR_MISSING_ARGS: f },
        } = hh(),
        m = Ih();
      t.exports = function (...e) {
        if (0 === e.length) throw new f("streams");
        if (1 === e.length) return n.from(e[0]);
        let t,
          g,
          _,
          v,
          y,
          b = [...e];
        if (
          ("function" == typeof e[0] && (e[0] = n.from(e[0])),
          "function" == typeof e[e.length - 1])
        ) {
          let t = e.length - 1;
          e[t] = n.from(e[t]);
        }
        for (let t = 0; t < e.length; ++t)
          if (o(e[t]) || l(e[t])) {
            if (t < e.length - 1 && !(s(e[t]) || h(e[t]) || c(e[t])))
              throw new p(`streams[${t}]`, b[t], "must be readable");
            if (t > 0 && !(a(e[t]) || u(e[t]) || c(e[t])))
              throw new p(`streams[${t}]`, b[t], "must be writable");
          }
        let x = e[0],
          w = r(e, function (e) {
            let t = v;
            (v = null), t ? t(e) : e ? y.destroy(e) : !E && !S && y.destroy();
          }),
          S = !!(a(x) || u(x) || c(x)),
          E = !!(s(w) || h(w) || c(w));
        if (
          ((y = new n({
            writableObjectMode: !(null == x || !x.writableObjectMode),
            readableObjectMode: !(null == w || !w.readableObjectMode),
            writable: S,
            readable: E,
          })),
          S)
        ) {
          if (o(x))
            (y._write = function (e, r, n) {
              x.write(e, r) ? n() : (t = n);
            }),
              (y._final = function (e) {
                x.end(), (g = e);
              }),
              x.on("drain", function () {
                if (t) {
                  let e = t;
                  (t = null), e();
                }
              });
          else if (l(x)) {
            let e = (c(x) ? x.writable : x).getWriter();
            (y._write = async function (t, r, n) {
              try {
                await e.ready, e.write(t).catch(() => {}), n();
              } catch (e) {
                n(e);
              }
            }),
              (y._final = async function (t) {
                try {
                  await e.ready, e.close().catch(() => {}), (g = t);
                } catch (e) {
                  t(e);
                }
              });
          }
          let e = c(w) ? w.readable : w;
          m(e, () => {
            if (g) {
              let e = g;
              (g = null), e();
            }
          });
        }
        if (E)
          if (o(w))
            w.on("readable", function () {
              if (_) {
                let e = _;
                (_ = null), e();
              }
            }),
              w.on("end", function () {
                y.push(null);
              }),
              (y._read = function () {
                for (;;) {
                  let e = w.read();
                  if (null === e) return void (_ = y._read);
                  if (!y.push(e)) return;
                }
              });
          else if (l(w)) {
            let e = (c(w) ? w.readable : w).getReader();
            y._read = async function () {
              for (;;)
                try {
                  let { value: t, done: r } = await e.read();
                  if (!y.push(t)) return;
                  if (r) return void y.push(null);
                } catch {
                  return;
                }
            };
          }
        return (
          (y._destroy = function (e, r) {
            !e && null !== v && (e = new d()),
              (_ = null),
              (t = null),
              (g = null),
              null === v ? r(e) : ((v = r), o(w) && i(w, e));
          }),
          y
        );
      };
    }),
    Yh = dc((e, t) => {
      mc(), lh(), qu();
      var r = globalThis.AbortController || dh().AbortController,
        {
          codes: {
            ERR_INVALID_ARG_VALUE: n,
            ERR_INVALID_ARG_TYPE: i,
            ERR_MISSING_ARGS: o,
            ERR_OUT_OF_RANGE: s,
          },
          AbortError: a,
        } = hh(),
        {
          validateAbortSignal: l,
          validateInteger: c,
          validateObject: u,
        } = Rh(),
        h = ch().Symbol("kWeak"),
        d = ch().Symbol("kResistStopPropagation"),
        { finished: p } = Ih(),
        f = qh(),
        { addAbortSignalNoValidate: m } = Nh(),
        { isWritable: g, isNodeStream: _ } = Ch(),
        { deprecate: v } = Ah(),
        {
          ArrayPrototypePush: y,
          Boolean: b,
          MathFloor: x,
          Number: w,
          NumberIsNaN: S,
          Promise: E,
          PromiseReject: M,
          PromiseResolve: T,
          PromisePrototypeThen: A,
          Symbol: R,
        } = ch(),
        P = R("kEmpty"),
        C = R("kEof");
      function I(e, t) {
        if ("function" != typeof e)
          throw new i("fn", ["Function", "AsyncFunction"], e);
        null != t && u(t, "options"),
          null != t?.signal && l(t.signal, "options.signal");
        let r = 1;
        null != t?.concurrency && (r = x(t.concurrency));
        let n = r - 1;
        return (
          null != t?.highWaterMark && (n = x(t.highWaterMark)),
          c(r, "options.concurrency", 1),
          c(n, "options.highWaterMark", 0),
          (n += r),
          async function* () {
            let i,
              o,
              s = Ah().AbortSignalAny([t?.signal].filter(b)),
              l = this,
              c = [],
              u = { signal: s },
              h = !1,
              d = 0;
            function p() {
              (h = !0), f();
            }
            function f() {
              (d -= 1), m();
            }
            function m() {
              o && !h && d < r && c.length < n && (o(), (o = null));
            }
            !(async function () {
              try {
                for await (let t of l) {
                  if (h) return;
                  if (s.aborted) throw new a();
                  try {
                    if (((t = e(t, u)), t === P)) continue;
                    t = T(t);
                  } catch (e) {
                    t = M(e);
                  }
                  (d += 1),
                    A(t, f, p),
                    c.push(t),
                    i && (i(), (i = null)),
                    !h &&
                      (c.length >= n || d >= r) &&
                      (await new E((e) => {
                        o = e;
                      }));
                }
                c.push(C);
              } catch (e) {
                let t = M(e);
                A(t, f, p), c.push(t);
              } finally {
                (h = !0), i && (i(), (i = null));
              }
            })();
            try {
              for (;;) {
                for (; c.length > 0; ) {
                  let e = await c[0];
                  if (e === C) return;
                  if (s.aborted) throw new a();
                  e !== P && (yield e), c.shift(), m();
                }
                await new E((e) => {
                  i = e;
                });
              }
            } finally {
              (h = !0), o && (o(), (o = null));
            }
          }.call(this)
        );
      }
      async function L(e, t = void 0) {
        for await (let r of O.call(this, e, t)) return !0;
        return !1;
      }
      function O(e, t) {
        if ("function" != typeof e)
          throw new i("fn", ["Function", "AsyncFunction"], e);
        return I.call(
          this,
          async function (t, r) {
            return (await e(t, r)) ? t : P;
          },
          t
        );
      }
      var N = class extends o {
        constructor() {
          super("reduce"),
            (this.message =
              "Reduce of an empty stream requires an initial value");
        }
      };
      function U(e) {
        if (((e = w(e)), S(e))) return 0;
        if (e < 0) throw new s("number", ">= 0", e);
        return e;
      }
      (t.exports.streamReturningOperators = {
        asIndexedPairs: v(function (e = void 0) {
          return (
            null != e && u(e, "options"),
            null != e?.signal && l(e.signal, "options.signal"),
            async function* () {
              let t = 0;
              for await (let n of this) {
                var r;
                if (
                  null != e &&
                  null !== (r = e.signal) &&
                  void 0 !== r &&
                  r.aborted
                )
                  throw new a({ cause: e.signal.reason });
                yield [t++, n];
              }
            }.call(this)
          );
        }, "readable.asIndexedPairs will be removed in a future version."),
        drop: function (e, t = void 0) {
          return (
            null != t && u(t, "options"),
            null != t?.signal && l(t.signal, "options.signal"),
            (e = U(e)),
            async function* () {
              var r;
              if (
                null != t &&
                null !== (r = t.signal) &&
                void 0 !== r &&
                r.aborted
              )
                throw new a();
              for await (let r of this) {
                var n;
                if (
                  null != t &&
                  null !== (n = t.signal) &&
                  void 0 !== n &&
                  n.aborted
                )
                  throw new a();
                e-- <= 0 && (yield r);
              }
            }.call(this)
          );
        },
        filter: O,
        flatMap: function (e, t) {
          let r = I.call(this, e, t);
          return async function* () {
            for await (let e of r) yield* e;
          }.call(this);
        },
        map: I,
        take: function (e, t = void 0) {
          return (
            null != t && u(t, "options"),
            null != t?.signal && l(t.signal, "options.signal"),
            (e = U(e)),
            async function* () {
              var r;
              if (
                null != t &&
                null !== (r = t.signal) &&
                void 0 !== r &&
                r.aborted
              )
                throw new a();
              for await (let r of this) {
                var n;
                if (
                  null != t &&
                  null !== (n = t.signal) &&
                  void 0 !== n &&
                  n.aborted
                )
                  throw new a();
                if ((e-- > 0 && (yield r), e <= 0)) return;
              }
            }.call(this)
          );
        },
        compose: function (e, t) {
          if (
            (null != t && u(t, "options"),
            null != t?.signal && l(t.signal, "options.signal"),
            _(e) && !g(e))
          )
            throw new n("stream", e, "must be writable");
          let r = f(this, e);
          return null != t && t.signal && m(t.signal, r), r;
        },
      }),
        (t.exports.promiseReturningOperators = {
          every: async function (e, t = void 0) {
            if ("function" != typeof e)
              throw new i("fn", ["Function", "AsyncFunction"], e);
            return !(await L.call(this, async (...t) => !(await e(...t)), t));
          },
          forEach: async function (e, t) {
            if ("function" != typeof e)
              throw new i("fn", ["Function", "AsyncFunction"], e);
            for await (let r of I.call(
              this,
              async function (t, r) {
                return await e(t, r), P;
              },
              t
            ));
          },
          reduce: async function (e, t, n) {
            var o;
            if ("function" != typeof e)
              throw new i("reducer", ["Function", "AsyncFunction"], e);
            null != n && u(n, "options"),
              null != n?.signal && l(n.signal, "options.signal");
            let s = arguments.length > 1;
            if (
              null != n &&
              null !== (o = n.signal) &&
              void 0 !== o &&
              o.aborted
            ) {
              let e = new a(void 0, { cause: n.signal.reason });
              throw (this.once("error", () => {}), await p(this.destroy(e)), e);
            }
            let c = new r(),
              f = c.signal;
            if (null != n && n.signal) {
              let e = { once: !0, [h]: this, [d]: !0 };
              n.signal.addEventListener("abort", () => c.abort(), e);
            }
            let m = !1;
            try {
              for await (let r of this) {
                var g;
                if (
                  ((m = !0),
                  null != n &&
                    null !== (g = n.signal) &&
                    void 0 !== g &&
                    g.aborted)
                )
                  throw new a();
                s ? (t = await e(t, r, { signal: f })) : ((t = r), (s = !0));
              }
              if (!m && !s) throw new N();
            } finally {
              c.abort();
            }
            return t;
          },
          toArray: async function (e) {
            null != e && u(e, "options"),
              null != e?.signal && l(e.signal, "options.signal");
            let t = [];
            for await (let n of this) {
              var r;
              if (
                null != e &&
                null !== (r = e.signal) &&
                void 0 !== r &&
                r.aborted
              )
                throw new a(void 0, { cause: e.signal.reason });
              y(t, n);
            }
            return t;
          },
          some: L,
          find: async function (e, t) {
            for await (let r of O.call(this, e, t)) return r;
          },
        });
    }),
    Kh = dc((e, t) => {
      mc(), lh(), qu();
      var { ArrayPrototypePop: r, Promise: n } = ch(),
        { isIterable: i, isNodeStream: o, isWebStream: s } = Ch(),
        { pipelineImpl: a } = Xh(),
        { finished: l } = Ih();
      $h(),
        (t.exports = {
          finished: l,
          pipeline: function (...e) {
            return new n((t, n) => {
              let l,
                c,
                u = e[e.length - 1];
              if (u && "object" == typeof u && !o(u) && !i(u) && !s(u)) {
                let t = r(e);
                (l = t.signal), (c = t.end);
              }
              a(
                e,
                (e, r) => {
                  e ? n(e) : t(r);
                },
                { signal: l, end: c }
              );
            });
          },
        });
    }),
    $h = dc((e, t) => {
      mc(), lh(), qu();
      var { Buffer: r } = (ah(), fc(rh)),
        { ObjectDefineProperty: n, ObjectKeys: i, ReflectApply: o } = ch(),
        {
          promisify: { custom: s },
        } = Ah(),
        { streamReturningOperators: a, promiseReturningOperators: l } = Yh(),
        {
          codes: { ERR_ILLEGAL_CONSTRUCTOR: c },
        } = hh(),
        u = qh(),
        { setDefaultHighWaterMark: h, getDefaultHighWaterMark: d } = Dh(),
        { pipeline: p } = Xh(),
        { destroyer: f } = Lh(),
        m = Ih(),
        g = Kh(),
        _ = Ch(),
        v = (t.exports = Oh().Stream);
      (v.isDestroyed = _.isDestroyed),
        (v.isDisturbed = _.isDisturbed),
        (v.isErrored = _.isErrored),
        (v.isReadable = _.isReadable),
        (v.isWritable = _.isWritable),
        (v.Readable = Hh());
      for (let e of i(a)) {
        let t = function (...e) {
            if (new.target) throw c();
            return v.Readable.from(o(r, this, e));
          },
          r = a[e];
        n(t, "name", { __proto__: null, value: r.name }),
          n(t, "length", { __proto__: null, value: r.length }),
          n(v.Readable.prototype, e, {
            __proto__: null,
            value: t,
            enumerable: !1,
            configurable: !0,
            writable: !0,
          });
      }
      for (let e of i(l)) {
        let t = function (...e) {
            if (new.target) throw c();
            return o(r, this, e);
          },
          r = l[e];
        n(t, "name", { __proto__: null, value: r.name }),
          n(t, "length", { __proto__: null, value: r.length }),
          n(v.Readable.prototype, e, {
            __proto__: null,
            value: t,
            enumerable: !1,
            configurable: !0,
            writable: !0,
          });
      }
      (v.Writable = zh()),
        (v.Duplex = jh()),
        (v.Transform = Wh()),
        (v.PassThrough = Gh()),
        (v.pipeline = p);
      var { addAbortSignal: y } = Nh();
      (v.addAbortSignal = y),
        (v.finished = m),
        (v.destroy = f),
        (v.compose = u),
        (v.setDefaultHighWaterMark = h),
        (v.getDefaultHighWaterMark = d),
        n(v, "promises", {
          __proto__: null,
          configurable: !0,
          enumerable: !0,
          get: () => g,
        }),
        n(p, s, { __proto__: null, enumerable: !0, get: () => g.pipeline }),
        n(m, s, { __proto__: null, enumerable: !0, get: () => g.finished }),
        (v.Stream = v),
        (v._isUint8Array = function (e) {
          return e instanceof Uint8Array;
        }),
        (v._uint8ArrayToBuffer = function (e) {
          return r.from(e.buffer, e.byteOffset, e.byteLength);
        });
    }),
    Qh = dc((e, t) => {
      mc(), lh(), qu();
      var r = $h(),
        n = Kh(),
        i = r.Readable.destroy;
      (t.exports = r.Readable),
        (t.exports._uint8ArrayToBuffer = r._uint8ArrayToBuffer),
        (t.exports._isUint8Array = r._isUint8Array),
        (t.exports.isDisturbed = r.isDisturbed),
        (t.exports.isErrored = r.isErrored),
        (t.exports.isReadable = r.isReadable),
        (t.exports.Readable = r.Readable),
        (t.exports.Writable = r.Writable),
        (t.exports.Duplex = r.Duplex),
        (t.exports.Transform = r.Transform),
        (t.exports.PassThrough = r.PassThrough),
        (t.exports.addAbortSignal = r.addAbortSignal),
        (t.exports.finished = r.finished),
        (t.exports.destroy = r.destroy),
        (t.exports.destroy = i),
        (t.exports.pipeline = r.pipeline),
        (t.exports.compose = r.compose),
        Object.defineProperty(r, "promises", {
          configurable: !0,
          enumerable: !0,
          get: () => n,
        }),
        (t.exports.Stream = r.Stream),
        (t.exports.default = t.exports);
    }),
    Jh = dc((e, t) => {
      mc(),
        lh(),
        qu(),
        "function" == typeof Object.create
          ? (t.exports = function (e, t) {
              t &&
                ((e.super_ = t),
                (e.prototype = Object.create(t.prototype, {
                  constructor: {
                    value: e,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0,
                  },
                })));
            })
          : (t.exports = function (e, t) {
              if (t) {
                e.super_ = t;
                var r = function () {};
                (r.prototype = t.prototype),
                  (e.prototype = new r()),
                  (e.prototype.constructor = e);
              }
            });
    }),
    Zh = dc((e, t) => {
      mc(), lh(), qu();
      var { Buffer: r } = (ah(), fc(rh)),
        n = Symbol.for("BufferList");
      function i(e) {
        if (!(this instanceof i)) return new i(e);
        i._init.call(this, e);
      }
      (i._init = function (e) {
        Object.defineProperty(this, n, { value: !0 }),
          (this._bufs = []),
          (this.length = 0),
          e && this.append(e);
      }),
        (i.prototype._new = function (e) {
          return new i(e);
        }),
        (i.prototype._offset = function (e) {
          if (0 === e) return [0, 0];
          let t = 0;
          for (let r = 0; r < this._bufs.length; r++) {
            let n = t + this._bufs[r].length;
            if (e < n || r === this._bufs.length - 1) return [r, e - t];
            t = n;
          }
        }),
        (i.prototype._reverseOffset = function (e) {
          let t = e[0],
            r = e[1];
          for (let e = 0; e < t; e++) r += this._bufs[e].length;
          return r;
        }),
        (i.prototype.getBuffers = function () {
          return this._bufs;
        }),
        (i.prototype.get = function (e) {
          if (e > this.length || e < 0) return;
          let t = this._offset(e);
          return this._bufs[t[0]][t[1]];
        }),
        (i.prototype.slice = function (e, t) {
          return (
            "number" == typeof e && e < 0 && (e += this.length),
            "number" == typeof t && t < 0 && (t += this.length),
            this.copy(null, 0, e, t)
          );
        }),
        (i.prototype.copy = function (e, t, n, i) {
          if (
            (("number" != typeof n || n < 0) && (n = 0),
            ("number" != typeof i || i > this.length) && (i = this.length),
            n >= this.length || i <= 0)
          )
            return e || r.alloc(0);
          let o = !!e,
            s = this._offset(n),
            a = i - n,
            l = a,
            c = (o && t) || 0,
            u = s[1];
          if (0 === n && i === this.length) {
            if (!o)
              return 1 === this._bufs.length
                ? this._bufs[0]
                : r.concat(this._bufs, this.length);
            for (let t = 0; t < this._bufs.length; t++)
              this._bufs[t].copy(e, c), (c += this._bufs[t].length);
            return e;
          }
          if (l <= this._bufs[s[0]].length - u)
            return o
              ? this._bufs[s[0]].copy(e, t, u, u + l)
              : this._bufs[s[0]].slice(u, u + l);
          o || (e = r.allocUnsafe(a));
          for (let t = s[0]; t < this._bufs.length; t++) {
            let r = this._bufs[t].length - u;
            if (!(l > r)) {
              this._bufs[t].copy(e, c, u, u + l), (c += r);
              break;
            }
            this._bufs[t].copy(e, c, u), (c += r), (l -= r), u && (u = 0);
          }
          return e.length > c ? e.slice(0, c) : e;
        }),
        (i.prototype.shallowSlice = function (e, t) {
          if (
            ((e = e || 0),
            (t = "number" != typeof t ? this.length : t),
            e < 0 && (e += this.length),
            t < 0 && (t += this.length),
            e === t)
          )
            return this._new();
          let r = this._offset(e),
            n = this._offset(t),
            i = this._bufs.slice(r[0], n[0] + 1);
          return (
            0 === n[1]
              ? i.pop()
              : (i[i.length - 1] = i[i.length - 1].slice(0, n[1])),
            0 !== r[1] && (i[0] = i[0].slice(r[1])),
            this._new(i)
          );
        }),
        (i.prototype.toString = function (e, t, r) {
          return this.slice(t, r).toString(e);
        }),
        (i.prototype.consume = function (e) {
          if (((e = Math.trunc(e)), Number.isNaN(e) || e <= 0)) return this;
          for (; this._bufs.length; ) {
            if (!(e >= this._bufs[0].length)) {
              (this._bufs[0] = this._bufs[0].slice(e)), (this.length -= e);
              break;
            }
            (e -= this._bufs[0].length),
              (this.length -= this._bufs[0].length),
              this._bufs.shift();
          }
          return this;
        }),
        (i.prototype.duplicate = function () {
          let e = this._new();
          for (let t = 0; t < this._bufs.length; t++) e.append(this._bufs[t]);
          return e;
        }),
        (i.prototype.append = function (e) {
          return this._attach(e, i.prototype._appendBuffer);
        }),
        (i.prototype.prepend = function (e) {
          return this._attach(e, i.prototype._prependBuffer, !0);
        }),
        (i.prototype._attach = function (e, t, n) {
          if (null == e) return this;
          if (e.buffer)
            t.call(this, r.from(e.buffer, e.byteOffset, e.byteLength));
          else if (Array.isArray(e)) {
            let [r, i] = n ? [e.length - 1, -1] : [0, 1];
            for (let o = r; o >= 0 && o < e.length; o += i)
              this._attach(e[o], t, n);
          } else if (this._isBufferList(e)) {
            let [r, i] = n ? [e._bufs.length - 1, -1] : [0, 1];
            for (let o = r; o >= 0 && o < e._bufs.length; o += i)
              this._attach(e._bufs[o], t, n);
          } else
            "number" == typeof e && (e = e.toString()), t.call(this, r.from(e));
          return this;
        }),
        (i.prototype._appendBuffer = function (e) {
          this._bufs.push(e), (this.length += e.length);
        }),
        (i.prototype._prependBuffer = function (e) {
          this._bufs.unshift(e), (this.length += e.length);
        }),
        (i.prototype.indexOf = function (e, t, n) {
          if (
            (void 0 === n && "string" == typeof t && ((n = t), (t = void 0)),
            "function" == typeof e || Array.isArray(e))
          )
            throw new TypeError(
              'The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.'
            );
          if (
            ("number" == typeof e
              ? (e = r.from([e]))
              : "string" == typeof e
              ? (e = r.from(e, n))
              : this._isBufferList(e)
              ? (e = e.slice())
              : Array.isArray(e.buffer)
              ? (e = r.from(e.buffer, e.byteOffset, e.byteLength))
              : r.isBuffer(e) || (e = r.from(e)),
            (t = Number(t || 0)),
            isNaN(t) && (t = 0),
            t < 0 && (t = this.length + t),
            t < 0 && (t = 0),
            0 === e.length)
          )
            return t > this.length ? this.length : t;
          let i = this._offset(t),
            o = i[0],
            s = i[1];
          for (; o < this._bufs.length; o++) {
            let t = this._bufs[o];
            for (; s < t.length; )
              if (t.length - s >= e.length) {
                let r = t.indexOf(e, s);
                if (-1 !== r) return this._reverseOffset([o, r]);
                s = t.length - e.length + 1;
              } else {
                let t = this._reverseOffset([o, s]);
                if (this._match(t, e)) return t;
                s++;
              }
            s = 0;
          }
          return -1;
        }),
        (i.prototype._match = function (e, t) {
          if (this.length - e < t.length) return !1;
          for (let r = 0; r < t.length; r++)
            if (this.get(e + r) !== t[r]) return !1;
          return !0;
        }),
        (function () {
          let e = {
            readDoubleBE: 8,
            readDoubleLE: 8,
            readFloatBE: 4,
            readFloatLE: 4,
            readBigInt64BE: 8,
            readBigInt64LE: 8,
            readBigUInt64BE: 8,
            readBigUInt64LE: 8,
            readInt32BE: 4,
            readInt32LE: 4,
            readUInt32BE: 4,
            readUInt32LE: 4,
            readInt16BE: 2,
            readInt16LE: 2,
            readUInt16BE: 2,
            readUInt16LE: 2,
            readInt8: 1,
            readUInt8: 1,
            readIntBE: null,
            readIntLE: null,
            readUIntBE: null,
            readUIntLE: null,
          };
          for (let t in e)
            (function (t) {
              i.prototype[t] =
                null === e[t]
                  ? function (e, r) {
                      return this.slice(e, e + r)[t](0, r);
                    }
                  : function (r = 0) {
                      return this.slice(r, r + e[t])[t](0);
                    };
            })(t);
        })(),
        (i.prototype._isBufferList = function (e) {
          return e instanceof i || i.isBufferList(e);
        }),
        (i.isBufferList = function (e) {
          return null != e && e[n];
        }),
        (t.exports = i);
    }),
    ed = dc((e, t) => {
      mc(), lh(), qu();
      var r = Qh().Duplex,
        n = Jh(),
        i = Zh();
      function o(e) {
        if (!(this instanceof o)) return new o(e);
        if ("function" == typeof e) {
          this._callback = e;
          let t = function (e) {
            this._callback && (this._callback(e), (this._callback = null));
          }.bind(this);
          this.on("pipe", function (e) {
            e.on("error", t);
          }),
            this.on("unpipe", function (e) {
              e.removeListener("error", t);
            }),
            (e = null);
        }
        i._init.call(this, e), r.call(this);
      }
      n(o, r),
        Object.assign(o.prototype, i.prototype),
        (o.prototype._new = function (e) {
          return new o(e);
        }),
        (o.prototype._write = function (e, t, r) {
          this._appendBuffer(e), "function" == typeof r && r();
        }),
        (o.prototype._read = function (e) {
          if (!this.length) return this.push(null);
          (e = Math.min(e, this.length)),
            this.push(this.slice(0, e)),
            this.consume(e);
        }),
        (o.prototype.end = function (e) {
          r.prototype.end.call(this, e),
            this._callback &&
              (this._callback(null, this.slice()), (this._callback = null));
        }),
        (o.prototype._destroy = function (e, t) {
          (this._bufs.length = 0), (this.length = 0), t(e);
        }),
        (o.prototype._isBufferList = function (e) {
          return e instanceof o || e instanceof i || o.isBufferList(e);
        }),
        (o.isBufferList = i.isBufferList),
        (t.exports = o),
        (t.exports.BufferListStream = o),
        (t.exports.BufferList = i);
    }),
    td = dc((e, t) => {
      mc(),
        lh(),
        qu(),
        (t.exports = class {
          constructor() {
            (this.cmd = null),
              (this.retain = !1),
              (this.qos = 0),
              (this.dup = !1),
              (this.length = -1),
              (this.topic = null),
              (this.payload = null);
          }
        });
    }),
    rd = dc((e, t) => {
      mc(), lh(), qu();
      var r = t.exports,
        { Buffer: n } = (ah(), fc(rh));
      (r.types = {
        0: "reserved",
        1: "connect",
        2: "connack",
        3: "publish",
        4: "puback",
        5: "pubrec",
        6: "pubrel",
        7: "pubcomp",
        8: "subscribe",
        9: "suback",
        10: "unsubscribe",
        11: "unsuback",
        12: "pingreq",
        13: "pingresp",
        14: "disconnect",
        15: "auth",
      }),
        (r.requiredHeaderFlags = {
          1: 0,
          2: 0,
          4: 0,
          5: 0,
          6: 2,
          7: 0,
          8: 2,
          9: 0,
          10: 2,
          11: 0,
          12: 0,
          13: 0,
          14: 0,
          15: 0,
        }),
        (r.requiredHeaderFlagsErrors = {});
      for (let e in r.requiredHeaderFlags) {
        let t = r.requiredHeaderFlags[e];
        r.requiredHeaderFlagsErrors[e] =
          "Invalid header flag bits, must be 0x" +
          t.toString(16) +
          " for " +
          r.types[e] +
          " packet";
      }
      r.codes = {};
      for (let e in r.types) {
        let t = r.types[e];
        r.codes[t] = e;
      }
      (r.CMD_SHIFT = 4),
        (r.CMD_MASK = 240),
        (r.DUP_MASK = 8),
        (r.QOS_MASK = 3),
        (r.QOS_SHIFT = 1),
        (r.RETAIN_MASK = 1),
        (r.VARBYTEINT_MASK = 127),
        (r.VARBYTEINT_FIN_MASK = 128),
        (r.VARBYTEINT_MAX = 268435455),
        (r.SESSIONPRESENT_MASK = 1),
        (r.SESSIONPRESENT_HEADER = n.from([r.SESSIONPRESENT_MASK])),
        (r.CONNACK_HEADER = n.from([r.codes.connack << r.CMD_SHIFT])),
        (r.USERNAME_MASK = 128),
        (r.PASSWORD_MASK = 64),
        (r.WILL_RETAIN_MASK = 32),
        (r.WILL_QOS_MASK = 24),
        (r.WILL_QOS_SHIFT = 3),
        (r.WILL_FLAG_MASK = 4),
        (r.CLEAN_SESSION_MASK = 2),
        (r.CONNECT_HEADER = n.from([r.codes.connect << r.CMD_SHIFT])),
        (r.properties = {
          sessionExpiryInterval: 17,
          willDelayInterval: 24,
          receiveMaximum: 33,
          maximumPacketSize: 39,
          topicAliasMaximum: 34,
          requestResponseInformation: 25,
          requestProblemInformation: 23,
          userProperties: 38,
          authenticationMethod: 21,
          authenticationData: 22,
          payloadFormatIndicator: 1,
          messageExpiryInterval: 2,
          contentType: 3,
          responseTopic: 8,
          correlationData: 9,
          maximumQoS: 36,
          retainAvailable: 37,
          assignedClientIdentifier: 18,
          reasonString: 31,
          wildcardSubscriptionAvailable: 40,
          subscriptionIdentifiersAvailable: 41,
          sharedSubscriptionAvailable: 42,
          serverKeepAlive: 19,
          responseInformation: 26,
          serverReference: 28,
          topicAlias: 35,
          subscriptionIdentifier: 11,
        }),
        (r.propertiesCodes = {});
      for (let e in r.properties) {
        let t = r.properties[e];
        r.propertiesCodes[t] = e;
      }
      function i(e) {
        return [0, 1, 2].map((t) =>
          [0, 1].map((i) =>
            [0, 1].map((o) => {
              let s = n.alloc(1);
              return (
                s.writeUInt8(
                  (r.codes[e] << r.CMD_SHIFT) |
                    (i ? r.DUP_MASK : 0) |
                    (t << r.QOS_SHIFT) |
                    o,
                  0,
                  !0
                ),
                s
              );
            })
          )
        );
      }
      (r.propertiesTypes = {
        sessionExpiryInterval: "int32",
        willDelayInterval: "int32",
        receiveMaximum: "int16",
        maximumPacketSize: "int32",
        topicAliasMaximum: "int16",
        requestResponseInformation: "byte",
        requestProblemInformation: "byte",
        userProperties: "pair",
        authenticationMethod: "string",
        authenticationData: "binary",
        payloadFormatIndicator: "byte",
        messageExpiryInterval: "int32",
        contentType: "string",
        responseTopic: "string",
        correlationData: "binary",
        maximumQoS: "int8",
        retainAvailable: "byte",
        assignedClientIdentifier: "string",
        reasonString: "string",
        wildcardSubscriptionAvailable: "byte",
        subscriptionIdentifiersAvailable: "byte",
        sharedSubscriptionAvailable: "byte",
        serverKeepAlive: "int16",
        responseInformation: "string",
        serverReference: "string",
        topicAlias: "int16",
        subscriptionIdentifier: "var",
      }),
        (r.PUBLISH_HEADER = i("publish")),
        (r.SUBSCRIBE_HEADER = i("subscribe")),
        (r.SUBSCRIBE_OPTIONS_QOS_MASK = 3),
        (r.SUBSCRIBE_OPTIONS_NL_MASK = 1),
        (r.SUBSCRIBE_OPTIONS_NL_SHIFT = 2),
        (r.SUBSCRIBE_OPTIONS_RAP_MASK = 1),
        (r.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3),
        (r.SUBSCRIBE_OPTIONS_RH_MASK = 3),
        (r.SUBSCRIBE_OPTIONS_RH_SHIFT = 4),
        (r.SUBSCRIBE_OPTIONS_RH = [0, 16, 32]),
        (r.SUBSCRIBE_OPTIONS_NL = 4),
        (r.SUBSCRIBE_OPTIONS_RAP = 8),
        (r.SUBSCRIBE_OPTIONS_QOS = [0, 1, 2]),
        (r.UNSUBSCRIBE_HEADER = i("unsubscribe")),
        (r.ACKS = {
          unsuback: i("unsuback"),
          puback: i("puback"),
          pubcomp: i("pubcomp"),
          pubrel: i("pubrel"),
          pubrec: i("pubrec"),
        }),
        (r.SUBACK_HEADER = n.from([r.codes.suback << r.CMD_SHIFT])),
        (r.VERSION3 = n.from([3])),
        (r.VERSION4 = n.from([4])),
        (r.VERSION5 = n.from([5])),
        (r.VERSION131 = n.from([131])),
        (r.VERSION132 = n.from([132])),
        (r.QOS = [0, 1, 2].map((e) => n.from([e]))),
        (r.EMPTY = {
          pingreq: n.from([r.codes.pingreq << 4, 0]),
          pingresp: n.from([r.codes.pingresp << 4, 0]),
          disconnect: n.from([r.codes.disconnect << 4, 0]),
        }),
        (r.MQTT5_PUBACK_PUBREC_CODES = {
          0: "Success",
          16: "No matching subscribers",
          128: "Unspecified error",
          131: "Implementation specific error",
          135: "Not authorized",
          144: "Topic Name invalid",
          145: "Packet identifier in use",
          151: "Quota exceeded",
          153: "Payload format invalid",
        }),
        (r.MQTT5_PUBREL_PUBCOMP_CODES = {
          0: "Success",
          146: "Packet Identifier not found",
        }),
        (r.MQTT5_SUBACK_CODES = {
          0: "Granted QoS 0",
          1: "Granted QoS 1",
          2: "Granted QoS 2",
          128: "Unspecified error",
          131: "Implementation specific error",
          135: "Not authorized",
          143: "Topic Filter invalid",
          145: "Packet Identifier in use",
          151: "Quota exceeded",
          158: "Shared Subscriptions not supported",
          161: "Subscription Identifiers not supported",
          162: "Wildcard Subscriptions not supported",
        }),
        (r.MQTT5_UNSUBACK_CODES = {
          0: "Success",
          17: "No subscription existed",
          128: "Unspecified error",
          131: "Implementation specific error",
          135: "Not authorized",
          143: "Topic Filter invalid",
          145: "Packet Identifier in use",
        }),
        (r.MQTT5_DISCONNECT_CODES = {
          0: "Normal disconnection",
          4: "Disconnect with Will Message",
          128: "Unspecified error",
          129: "Malformed Packet",
          130: "Protocol Error",
          131: "Implementation specific error",
          135: "Not authorized",
          137: "Server busy",
          139: "Server shutting down",
          141: "Keep Alive timeout",
          142: "Session taken over",
          143: "Topic Filter invalid",
          144: "Topic Name invalid",
          147: "Receive Maximum exceeded",
          148: "Topic Alias invalid",
          149: "Packet too large",
          150: "Message rate too high",
          151: "Quota exceeded",
          152: "Administrative action",
          153: "Payload format invalid",
          154: "Retain not supported",
          155: "QoS not supported",
          156: "Use another server",
          157: "Server moved",
          158: "Shared Subscriptions not supported",
          159: "Connection rate exceeded",
          160: "Maximum connect time",
          161: "Subscription Identifiers not supported",
          162: "Wildcard Subscriptions not supported",
        }),
        (r.MQTT5_AUTH_CODES = {
          0: "Success",
          24: "Continue authentication",
          25: "Re-authenticate",
        });
    }),
    nd = dc((e, t) => {
      mc(), lh(), qu();
      var r = 1e3,
        n = 6e4,
        i = 60 * n,
        o = 24 * i,
        s = 7 * o;
      function a(e, t, r, n) {
        var i = t >= 1.5 * r;
        return Math.round(e / r) + " " + n + (i ? "s" : "");
      }
      t.exports = function (e, t) {
        t = t || {};
        var l = typeof e;
        if ("string" === l && e.length > 0)
          return (function (e) {
            if (!((e = String(e)).length > 100)) {
              var t =
                /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
                  e
                );
              if (t) {
                var a = parseFloat(t[1]);
                switch ((t[2] || "ms").toLowerCase()) {
                  case "years":
                  case "year":
                  case "yrs":
                  case "yr":
                  case "y":
                    return 315576e5 * a;
                  case "weeks":
                  case "week":
                  case "w":
                    return a * s;
                  case "days":
                  case "day":
                  case "d":
                    return a * o;
                  case "hours":
                  case "hour":
                  case "hrs":
                  case "hr":
                  case "h":
                    return a * i;
                  case "minutes":
                  case "minute":
                  case "mins":
                  case "min":
                  case "m":
                    return a * n;
                  case "seconds":
                  case "second":
                  case "secs":
                  case "sec":
                  case "s":
                    return a * r;
                  case "milliseconds":
                  case "millisecond":
                  case "msecs":
                  case "msec":
                  case "ms":
                    return a;
                  default:
                    return;
                }
              }
            }
          })(e);
        if ("number" === l && isFinite(e))
          return t.long
            ? (function (e) {
                var t = Math.abs(e);
                return t >= o
                  ? a(e, t, o, "day")
                  : t >= i
                  ? a(e, t, i, "hour")
                  : t >= n
                  ? a(e, t, n, "minute")
                  : t >= r
                  ? a(e, t, r, "second")
                  : e + " ms";
              })(e)
            : (function (e) {
                var t = Math.abs(e);
                return t >= o
                  ? Math.round(e / o) + "d"
                  : t >= i
                  ? Math.round(e / i) + "h"
                  : t >= n
                  ? Math.round(e / n) + "m"
                  : t >= r
                  ? Math.round(e / r) + "s"
                  : e + "ms";
              })(e);
        throw new Error(
          "val is not a non-empty string or a valid number. val=" +
            JSON.stringify(e)
        );
      };
    }),
    id = dc((e, t) => {
      mc(),
        lh(),
        qu(),
        (t.exports = function (e) {
          function t(e) {
            let n,
              i,
              o,
              s = null;
            function a(...e) {
              if (!a.enabled) return;
              let r = a,
                i = Number(new Date()),
                o = i - (n || i);
              (r.diff = o),
                (r.prev = n),
                (r.curr = i),
                (n = i),
                (e[0] = t.coerce(e[0])),
                "string" != typeof e[0] && e.unshift("%O");
              let s = 0;
              (e[0] = e[0].replace(/%([a-zA-Z%])/g, (n, i) => {
                if ("%%" === n) return "%";
                s++;
                let o = t.formatters[i];
                if ("function" == typeof o) {
                  let t = e[s];
                  (n = o.call(r, t)), e.splice(s, 1), s--;
                }
                return n;
              })),
                t.formatArgs.call(r, e),
                (r.log || t.log).apply(r, e);
            }
            return (
              (a.namespace = e),
              (a.useColors = t.useColors()),
              (a.color = t.selectColor(e)),
              (a.extend = r),
              (a.destroy = t.destroy),
              Object.defineProperty(a, "enabled", {
                enumerable: !0,
                configurable: !1,
                get: () =>
                  null !== s
                    ? s
                    : (i !== t.namespaces &&
                        ((i = t.namespaces), (o = t.enabled(e))),
                      o),
                set: (e) => {
                  s = e;
                },
              }),
              "function" == typeof t.init && t.init(a),
              a
            );
          }
          function r(e, r) {
            let n = t(this.namespace + (typeof r > "u" ? ":" : r) + e);
            return (n.log = this.log), n;
          }
          function n(e, t) {
            let r = 0,
              n = 0,
              i = -1,
              o = 0;
            for (; r < e.length; )
              if (n < t.length && (t[n] === e[r] || "*" === t[n]))
                "*" === t[n] ? ((i = n), (o = r), n++) : (r++, n++);
              else {
                if (-1 === i) return !1;
                (n = i + 1), o++, (r = o);
              }
            for (; n < t.length && "*" === t[n]; ) n++;
            return n === t.length;
          }
          return (
            (t.debug = t),
            (t.default = t),
            (t.coerce = function (e) {
              return e instanceof Error ? e.stack || e.message : e;
            }),
            (t.disable = function () {
              let e = [...t.names, ...t.skips.map((e) => "-" + e)].join(",");
              return t.enable(""), e;
            }),
            (t.enable = function (e) {
              t.save(e), (t.namespaces = e), (t.names = []), (t.skips = []);
              let r = ("string" == typeof e ? e : "")
                .trim()
                .replace(/\s+/g, ",")
                .split(",")
                .filter(Boolean);
              for (let e of r)
                "-" === e[0] ? t.skips.push(e.slice(1)) : t.names.push(e);
            }),
            (t.enabled = function (e) {
              for (let r of t.skips) if (n(e, r)) return !1;
              for (let r of t.names) if (n(e, r)) return !0;
              return !1;
            }),
            (t.humanize = nd()),
            (t.destroy = function () {
              console.warn(
                "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
              );
            }),
            Object.keys(e).forEach((r) => {
              t[r] = e[r];
            }),
            (t.names = []),
            (t.skips = []),
            (t.formatters = {}),
            (t.selectColor = function (e) {
              let r = 0;
              for (let t = 0; t < e.length; t++)
                (r = (r << 5) - r + e.charCodeAt(t)), (r |= 0);
              return t.colors[Math.abs(r) % t.colors.length];
            }),
            t.enable(t.load()),
            t
          );
        });
    }),
    od = dc((e, t) => {
      mc(),
        lh(),
        qu(),
        (e.formatArgs = function (e) {
          if (
            ((e[0] =
              (this.useColors ? "%c" : "") +
              this.namespace +
              (this.useColors ? " %c" : " ") +
              e[0] +
              (this.useColors ? "%c " : " ") +
              "+" +
              t.exports.humanize(this.diff)),
            !this.useColors)
          )
            return;
          let r = "color: " + this.color;
          e.splice(1, 0, r, "color: inherit");
          let n = 0,
            i = 0;
          e[0].replace(/%[a-zA-Z%]/g, (e) => {
            "%%" !== e && (n++, "%c" === e && (i = n));
          }),
            e.splice(i, 0, r);
        }),
        (e.save = function (t) {
          try {
            t ? e.storage.setItem("debug", t) : e.storage.removeItem("debug");
          } catch {}
        }),
        (e.load = function () {
          let t;
          try {
            t = e.storage.getItem("debug") || e.storage.getItem("DEBUG");
          } catch {}
          return !t && typeof gc < "u" && "env" in gc && (t = gc.env.DEBUG), t;
        }),
        (e.useColors = function () {
          if (
            typeof window < "u" &&
            window.process &&
            ("renderer" === window.process.type || window.process.__nwjs)
          )
            return !0;
          if (
            typeof navigator < "u" &&
            navigator.userAgent &&
            navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
          )
            return !1;
          let e;
          return (
            (typeof document < "u" &&
              document.documentElement &&
              document.documentElement.style &&
              document.documentElement.style.WebkitAppearance) ||
            (typeof window < "u" &&
              window.console &&
              (window.console.firebug ||
                (window.console.exception && window.console.table))) ||
            (typeof navigator < "u" &&
              navigator.userAgent &&
              (e = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) &&
              parseInt(e[1], 10) >= 31) ||
            (typeof navigator < "u" &&
              navigator.userAgent &&
              navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
          );
        }),
        (e.storage = (function () {
          try {
            return localStorage;
          } catch {}
        })()),
        (e.destroy = (() => {
          let e = !1;
          return () => {
            e ||
              ((e = !0),
              console.warn(
                "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
              ));
          };
        })()),
        (e.colors = [
          "#0000CC",
          "#0000FF",
          "#0033CC",
          "#0033FF",
          "#0066CC",
          "#0066FF",
          "#0099CC",
          "#0099FF",
          "#00CC00",
          "#00CC33",
          "#00CC66",
          "#00CC99",
          "#00CCCC",
          "#00CCFF",
          "#3300CC",
          "#3300FF",
          "#3333CC",
          "#3333FF",
          "#3366CC",
          "#3366FF",
          "#3399CC",
          "#3399FF",
          "#33CC00",
          "#33CC33",
          "#33CC66",
          "#33CC99",
          "#33CCCC",
          "#33CCFF",
          "#6600CC",
          "#6600FF",
          "#6633CC",
          "#6633FF",
          "#66CC00",
          "#66CC33",
          "#9900CC",
          "#9900FF",
          "#9933CC",
          "#9933FF",
          "#99CC00",
          "#99CC33",
          "#CC0000",
          "#CC0033",
          "#CC0066",
          "#CC0099",
          "#CC00CC",
          "#CC00FF",
          "#CC3300",
          "#CC3333",
          "#CC3366",
          "#CC3399",
          "#CC33CC",
          "#CC33FF",
          "#CC6600",
          "#CC6633",
          "#CC9900",
          "#CC9933",
          "#CCCC00",
          "#CCCC33",
          "#FF0000",
          "#FF0033",
          "#FF0066",
          "#FF0099",
          "#FF00CC",
          "#FF00FF",
          "#FF3300",
          "#FF3333",
          "#FF3366",
          "#FF3399",
          "#FF33CC",
          "#FF33FF",
          "#FF6600",
          "#FF6633",
          "#FF9900",
          "#FF9933",
          "#FFCC00",
          "#FFCC33",
        ]),
        (e.log = console.debug || console.log || (() => {})),
        (t.exports = id()(e));
      var { formatters: r } = t.exports;
      r.j = function (e) {
        try {
          return JSON.stringify(e);
        } catch (e) {
          return "[UnexpectedJSONParseError]: " + e.message;
        }
      };
    }),
    sd = dc((e, t) => {
      mc(), lh(), qu();
      var r = ed(),
        { EventEmitter: n } = (Th(), fc(ph)),
        i = td(),
        o = rd(),
        s = od()("mqtt-packet:parser");
      t.exports = class e extends n {
        constructor() {
          super(), (this.parser = this.constructor.parser);
        }
        static parser(t) {
          return this instanceof e
            ? ((this.settings = t || {}),
              (this._states = [
                "_parseHeader",
                "_parseLength",
                "_parsePayload",
                "_newPacket",
              ]),
              this._resetState(),
              this)
            : new e().parser(t);
        }
        _resetState() {
          s("_resetState: resetting packet, error, _list, and _stateCounter"),
            (this.packet = new i()),
            (this.error = null),
            (this._list = r()),
            (this._stateCounter = 0);
        }
        parse(e) {
          for (
            this.error && this._resetState(),
              this._list.append(e),
              s("parse: current state: %s", this._states[this._stateCounter]);
            (-1 !== this.packet.length || this._list.length > 0) &&
            this[this._states[this._stateCounter]]() &&
            !this.error;

          )
            this._stateCounter++,
              s(
                "parse: state complete. _stateCounter is now: %d",
                this._stateCounter
              ),
              s(
                "parse: packet.length: %d, buffer list length: %d",
                this.packet.length,
                this._list.length
              ),
              this._stateCounter >= this._states.length &&
                (this._stateCounter = 0);
          return (
            s(
              "parse: exited while loop. packet: %d, buffer list length: %d",
              this.packet.length,
              this._list.length
            ),
            this._list.length
          );
        }
        _parseHeader() {
          let e = this._list.readUInt8(0),
            t = e >> o.CMD_SHIFT;
          this.packet.cmd = o.types[t];
          let r = 15 & e,
            n = o.requiredHeaderFlags[t];
          return null != n && r !== n
            ? this._emitError(new Error(o.requiredHeaderFlagsErrors[t]))
            : ((this.packet.retain = 0 !== (e & o.RETAIN_MASK)),
              (this.packet.qos = (e >> o.QOS_SHIFT) & o.QOS_MASK),
              this.packet.qos > 2
                ? this._emitError(
                    new Error("Packet must not have both QoS bits set to 1")
                  )
                : ((this.packet.dup = 0 !== (e & o.DUP_MASK)),
                  s("_parseHeader: packet: %o", this.packet),
                  this._list.consume(1),
                  !0));
        }
        _parseLength() {
          let e = this._parseVarByteNum(!0);
          return (
            e && ((this.packet.length = e.value), this._list.consume(e.bytes)),
            s("_parseLength %d", e.value),
            !!e
          );
        }
        _parsePayload() {
          s("_parsePayload: payload %O", this._list);
          let e = !1;
          if (
            0 === this.packet.length ||
            this._list.length >= this.packet.length
          ) {
            switch (((this._pos = 0), this.packet.cmd)) {
              case "connect":
                this._parseConnect();
                break;
              case "connack":
                this._parseConnack();
                break;
              case "publish":
                this._parsePublish();
                break;
              case "puback":
              case "pubrec":
              case "pubrel":
              case "pubcomp":
                this._parseConfirmation();
                break;
              case "subscribe":
                this._parseSubscribe();
                break;
              case "suback":
                this._parseSuback();
                break;
              case "unsubscribe":
                this._parseUnsubscribe();
                break;
              case "unsuback":
                this._parseUnsuback();
                break;
              case "pingreq":
              case "pingresp":
                break;
              case "disconnect":
                this._parseDisconnect();
                break;
              case "auth":
                this._parseAuth();
                break;
              default:
                this._emitError(new Error("Not supported"));
            }
            e = !0;
          }
          return s("_parsePayload complete result: %s", e), e;
        }
        _parseConnect() {
          s("_parseConnect");
          let e,
            t,
            r,
            n,
            i = {},
            a = this.packet,
            l = this._parseString();
          if (null === l)
            return this._emitError(new Error("Cannot parse protocolId"));
          if ("MQTT" !== l && "MQIsdp" !== l)
            return this._emitError(new Error("Invalid protocolId"));
          if (((a.protocolId = l), this._pos >= this._list.length))
            return this._emitError(new Error("Packet too short"));
          if (
            ((a.protocolVersion = this._list.readUInt8(this._pos)),
            a.protocolVersion >= 128 &&
              ((a.bridgeMode = !0),
              (a.protocolVersion = a.protocolVersion - 128)),
            3 !== a.protocolVersion &&
              4 !== a.protocolVersion &&
              5 !== a.protocolVersion)
          )
            return this._emitError(new Error("Invalid protocol version"));
          if ((this._pos++, this._pos >= this._list.length))
            return this._emitError(new Error("Packet too short"));
          if (1 & this._list.readUInt8(this._pos))
            return this._emitError(
              new Error("Connect flag bit 0 must be 0, but got 1")
            );
          (i.username = this._list.readUInt8(this._pos) & o.USERNAME_MASK),
            (i.password = this._list.readUInt8(this._pos) & o.PASSWORD_MASK),
            (i.will = this._list.readUInt8(this._pos) & o.WILL_FLAG_MASK);
          let c = !!(this._list.readUInt8(this._pos) & o.WILL_RETAIN_MASK),
            u =
              (this._list.readUInt8(this._pos) & o.WILL_QOS_MASK) >>
              o.WILL_QOS_SHIFT;
          if (i.will) (a.will = {}), (a.will.retain = c), (a.will.qos = u);
          else {
            if (c)
              return this._emitError(
                new Error(
                  "Will Retain Flag must be set to zero when Will Flag is set to 0"
                )
              );
            if (u)
              return this._emitError(
                new Error(
                  "Will QoS must be set to zero when Will Flag is set to 0"
                )
              );
          }
          if (
            ((a.clean =
              0 !== (this._list.readUInt8(this._pos) & o.CLEAN_SESSION_MASK)),
            this._pos++,
            (a.keepalive = this._parseNum()),
            -1 === a.keepalive)
          )
            return this._emitError(new Error("Packet too short"));
          if (5 === a.protocolVersion) {
            let e = this._parseProperties();
            Object.getOwnPropertyNames(e).length && (a.properties = e);
          }
          let h = this._parseString();
          if (null === h) return this._emitError(new Error("Packet too short"));
          if (
            ((a.clientId = h),
            s("_parseConnect: packet.clientId: %s", a.clientId),
            i.will)
          ) {
            if (5 === a.protocolVersion) {
              let e = this._parseProperties();
              Object.getOwnPropertyNames(e).length && (a.will.properties = e);
            }
            if (((e = this._parseString()), null === e))
              return this._emitError(new Error("Cannot parse will topic"));
            if (
              ((a.will.topic = e),
              s("_parseConnect: packet.will.topic: %s", a.will.topic),
              (t = this._parseBuffer()),
              null === t)
            )
              return this._emitError(new Error("Cannot parse will payload"));
            (a.will.payload = t),
              s("_parseConnect: packet.will.paylaod: %s", a.will.payload);
          }
          if (i.username) {
            if (((n = this._parseString()), null === n))
              return this._emitError(new Error("Cannot parse username"));
            (a.username = n),
              s("_parseConnect: packet.username: %s", a.username);
          }
          if (i.password) {
            if (((r = this._parseBuffer()), null === r))
              return this._emitError(new Error("Cannot parse password"));
            a.password = r;
          }
          return (this.settings = a), s("_parseConnect: complete"), a;
        }
        _parseConnack() {
          s("_parseConnack");
          let e = this.packet;
          if (this._list.length < 1) return null;
          let t = this._list.readUInt8(this._pos++);
          if (t > 1)
            return this._emitError(
              new Error("Invalid connack flags, bits 7-1 must be set to 0")
            );
          if (
            ((e.sessionPresent = !!(t & o.SESSIONPRESENT_MASK)),
            5 === this.settings.protocolVersion)
          )
            this._list.length >= 2
              ? (e.reasonCode = this._list.readUInt8(this._pos++))
              : (e.reasonCode = 0);
          else {
            if (this._list.length < 2) return null;
            e.returnCode = this._list.readUInt8(this._pos++);
          }
          if (-1 === e.returnCode || -1 === e.reasonCode)
            return this._emitError(new Error("Cannot parse return code"));
          if (5 === this.settings.protocolVersion) {
            let t = this._parseProperties();
            Object.getOwnPropertyNames(t).length && (e.properties = t);
          }
          s("_parseConnack: complete");
        }
        _parsePublish() {
          s("_parsePublish");
          let e = this.packet;
          if (((e.topic = this._parseString()), null === e.topic))
            return this._emitError(new Error("Cannot parse topic"));
          if (!(e.qos > 0) || this._parseMessageId()) {
            if (5 === this.settings.protocolVersion) {
              let t = this._parseProperties();
              Object.getOwnPropertyNames(t).length && (e.properties = t);
            }
            (e.payload = this._list.slice(this._pos, e.length)),
              s("_parsePublish: payload from buffer list: %o", e.payload);
          }
        }
        _parseSubscribe() {
          s("_parseSubscribe");
          let e,
            t,
            r,
            n,
            i,
            a,
            l,
            c = this.packet;
          if (((c.subscriptions = []), this._parseMessageId())) {
            if (5 === this.settings.protocolVersion) {
              let e = this._parseProperties();
              Object.getOwnPropertyNames(e).length && (c.properties = e);
            }
            if (c.length <= 0)
              return this._emitError(
                new Error("Malformed subscribe, no payload specified")
              );
            for (; this._pos < c.length; ) {
              if (((e = this._parseString()), null === e))
                return this._emitError(new Error("Cannot parse topic"));
              if (this._pos >= c.length)
                return this._emitError(
                  new Error("Malformed Subscribe Payload")
                );
              if (
                ((t = this._parseByte()), 5 === this.settings.protocolVersion)
              ) {
                if (192 & t)
                  return this._emitError(
                    new Error(
                      "Invalid subscribe topic flag bits, bits 7-6 must be 0"
                    )
                  );
              } else if (252 & t)
                return this._emitError(
                  new Error(
                    "Invalid subscribe topic flag bits, bits 7-2 must be 0"
                  )
                );
              if (((r = t & o.SUBSCRIBE_OPTIONS_QOS_MASK), r > 2))
                return this._emitError(
                  new Error("Invalid subscribe QoS, must be <= 2")
                );
              if (
                ((a =
                  0 !==
                  ((t >> o.SUBSCRIBE_OPTIONS_NL_SHIFT) &
                    o.SUBSCRIBE_OPTIONS_NL_MASK)),
                (i =
                  0 !==
                  ((t >> o.SUBSCRIBE_OPTIONS_RAP_SHIFT) &
                    o.SUBSCRIBE_OPTIONS_RAP_MASK)),
                (n =
                  (t >> o.SUBSCRIBE_OPTIONS_RH_SHIFT) &
                  o.SUBSCRIBE_OPTIONS_RH_MASK),
                n > 2)
              )
                return this._emitError(
                  new Error("Invalid retain handling, must be <= 2")
                );
              (l = { topic: e, qos: r }),
                5 === this.settings.protocolVersion
                  ? ((l.nl = a), (l.rap = i), (l.rh = n))
                  : this.settings.bridgeMode &&
                    ((l.rh = 0), (l.rap = !0), (l.nl = !0)),
                s("_parseSubscribe: push subscription `%s` to subscription", l),
                c.subscriptions.push(l);
            }
          }
        }
        _parseSuback() {
          s("_parseSuback");
          let e = this.packet;
          if (((this.packet.granted = []), this._parseMessageId())) {
            if (5 === this.settings.protocolVersion) {
              let t = this._parseProperties();
              Object.getOwnPropertyNames(t).length && (e.properties = t);
            }
            if (e.length <= 0)
              return this._emitError(
                new Error("Malformed suback, no payload specified")
              );
            for (; this._pos < this.packet.length; ) {
              let e = this._list.readUInt8(this._pos++);
              if (5 === this.settings.protocolVersion) {
                if (!o.MQTT5_SUBACK_CODES[e])
                  return this._emitError(new Error("Invalid suback code"));
              } else if (e > 2 && 128 !== e)
                return this._emitError(
                  new Error("Invalid suback QoS, must be 0, 1, 2 or 128")
                );
              this.packet.granted.push(e);
            }
          }
        }
        _parseUnsubscribe() {
          s("_parseUnsubscribe");
          let e = this.packet;
          if (((e.unsubscriptions = []), this._parseMessageId())) {
            if (5 === this.settings.protocolVersion) {
              let t = this._parseProperties();
              Object.getOwnPropertyNames(t).length && (e.properties = t);
            }
            if (e.length <= 0)
              return this._emitError(
                new Error("Malformed unsubscribe, no payload specified")
              );
            for (; this._pos < e.length; ) {
              let t = this._parseString();
              if (null === t)
                return this._emitError(new Error("Cannot parse topic"));
              s("_parseUnsubscribe: push topic `%s` to unsubscriptions", t),
                e.unsubscriptions.push(t);
            }
          }
        }
        _parseUnsuback() {
          s("_parseUnsuback");
          let e = this.packet;
          if (!this._parseMessageId())
            return this._emitError(new Error("Cannot parse messageId"));
          if (
            (3 === this.settings.protocolVersion ||
              4 === this.settings.protocolVersion) &&
            2 !== e.length
          )
            return this._emitError(
              new Error("Malformed unsuback, payload length must be 2")
            );
          if (e.length <= 0)
            return this._emitError(
              new Error("Malformed unsuback, no payload specified")
            );
          if (5 === this.settings.protocolVersion) {
            let t = this._parseProperties();
            for (
              Object.getOwnPropertyNames(t).length && (e.properties = t),
                e.granted = [];
              this._pos < this.packet.length;

            ) {
              let e = this._list.readUInt8(this._pos++);
              if (!o.MQTT5_UNSUBACK_CODES[e])
                return this._emitError(new Error("Invalid unsuback code"));
              this.packet.granted.push(e);
            }
          }
        }
        _parseConfirmation() {
          s("_parseConfirmation: packet.cmd: `%s`", this.packet.cmd);
          let e = this.packet;
          if ((this._parseMessageId(), 5 === this.settings.protocolVersion)) {
            if (e.length > 2) {
              switch (((e.reasonCode = this._parseByte()), this.packet.cmd)) {
                case "puback":
                case "pubrec":
                  if (!o.MQTT5_PUBACK_PUBREC_CODES[e.reasonCode])
                    return this._emitError(
                      new Error("Invalid " + this.packet.cmd + " reason code")
                    );
                  break;
                case "pubrel":
                case "pubcomp":
                  if (!o.MQTT5_PUBREL_PUBCOMP_CODES[e.reasonCode])
                    return this._emitError(
                      new Error("Invalid " + this.packet.cmd + " reason code")
                    );
              }
              s("_parseConfirmation: packet.reasonCode `%d`", e.reasonCode);
            } else e.reasonCode = 0;
            if (e.length > 3) {
              let t = this._parseProperties();
              Object.getOwnPropertyNames(t).length && (e.properties = t);
            }
          }
          return !0;
        }
        _parseDisconnect() {
          let e = this.packet;
          if ((s("_parseDisconnect"), 5 === this.settings.protocolVersion)) {
            this._list.length > 0
              ? ((e.reasonCode = this._parseByte()),
                o.MQTT5_DISCONNECT_CODES[e.reasonCode] ||
                  this._emitError(new Error("Invalid disconnect reason code")))
              : (e.reasonCode = 0);
            let t = this._parseProperties();
            Object.getOwnPropertyNames(t).length && (e.properties = t);
          }
          return s("_parseDisconnect result: true"), !0;
        }
        _parseAuth() {
          s("_parseAuth");
          let e = this.packet;
          if (5 !== this.settings.protocolVersion)
            return this._emitError(
              new Error("Not supported auth packet for this version MQTT")
            );
          if (
            ((e.reasonCode = this._parseByte()),
            !o.MQTT5_AUTH_CODES[e.reasonCode])
          )
            return this._emitError(new Error("Invalid auth reason code"));
          let t = this._parseProperties();
          return (
            Object.getOwnPropertyNames(t).length && (e.properties = t),
            s("_parseAuth: result: true"),
            !0
          );
        }
        _parseMessageId() {
          let e = this.packet;
          return (
            (e.messageId = this._parseNum()),
            null === e.messageId
              ? (this._emitError(new Error("Cannot parse messageId")), !1)
              : (s("_parseMessageId: packet.messageId %d", e.messageId), !0)
          );
        }
        _parseString(e) {
          let t = this._parseNum(),
            r = t + this._pos;
          if (-1 === t || r > this._list.length || r > this.packet.length)
            return null;
          let n = this._list.toString("utf8", this._pos, r);
          return (this._pos += t), s("_parseString: result: %s", n), n;
        }
        _parseStringPair() {
          return (
            s("_parseStringPair"),
            { name: this._parseString(), value: this._parseString() }
          );
        }
        _parseBuffer() {
          let e = this._parseNum(),
            t = e + this._pos;
          if (-1 === e || t > this._list.length || t > this.packet.length)
            return null;
          let r = this._list.slice(this._pos, t);
          return (this._pos += e), s("_parseBuffer: result: %o", r), r;
        }
        _parseNum() {
          if (this._list.length - this._pos < 2) return -1;
          let e = this._list.readUInt16BE(this._pos);
          return (this._pos += 2), s("_parseNum: result: %s", e), e;
        }
        _parse4ByteNum() {
          if (this._list.length - this._pos < 4) return -1;
          let e = this._list.readUInt32BE(this._pos);
          return (this._pos += 4), s("_parse4ByteNum: result: %s", e), e;
        }
        _parseVarByteNum(e) {
          s("_parseVarByteNum");
          let t,
            r = 0,
            n = 1,
            i = 0,
            a = !1,
            l = this._pos ? this._pos : 0;
          for (; r < 4 && l + r < this._list.length; ) {
            if (
              ((t = this._list.readUInt8(l + r++)),
              (i += n * (t & o.VARBYTEINT_MASK)),
              (n *= 128),
              0 === (t & o.VARBYTEINT_FIN_MASK))
            ) {
              a = !0;
              break;
            }
            if (this._list.length <= r) break;
          }
          return (
            !a &&
              4 === r &&
              this._list.length >= r &&
              this._emitError(new Error("Invalid variable byte integer")),
            l && (this._pos += r),
            (a = !!a && (e ? { bytes: r, value: i } : i)),
            s("_parseVarByteNum: result: %o", a),
            a
          );
        }
        _parseByte() {
          let e;
          return (
            this._pos < this._list.length &&
              ((e = this._list.readUInt8(this._pos)), this._pos++),
            s("_parseByte: result: %o", e),
            e
          );
        }
        _parseByType(e) {
          switch ((s("_parseByType: type: %s", e), e)) {
            case "byte":
              return 0 !== this._parseByte();
            case "int8":
              return this._parseByte();
            case "int16":
              return this._parseNum();
            case "int32":
              return this._parse4ByteNum();
            case "var":
              return this._parseVarByteNum();
            case "string":
              return this._parseString();
            case "pair":
              return this._parseStringPair();
            case "binary":
              return this._parseBuffer();
          }
        }
        _parseProperties() {
          s("_parseProperties");
          let e = this._parseVarByteNum(),
            t = this._pos + e,
            r = {};
          for (; this._pos < t; ) {
            let e = this._parseByte();
            if (!e)
              return (
                this._emitError(new Error("Cannot parse property code type")),
                !1
              );
            let t = o.propertiesCodes[e];
            if (!t) return this._emitError(new Error("Unknown property")), !1;
            if ("userProperties" === t) {
              r[t] || (r[t] = Object.create(null));
              let e = this._parseByType(o.propertiesTypes[t]);
              if (r[t][e.name])
                if (Array.isArray(r[t][e.name])) r[t][e.name].push(e.value);
                else {
                  let n = r[t][e.name];
                  (r[t][e.name] = [n]), r[t][e.name].push(e.value);
                }
              else r[t][e.name] = e.value;
              continue;
            }
            r[t]
              ? (Array.isArray(r[t]) || (r[t] = [r[t]]),
                r[t].push(this._parseByType(o.propertiesTypes[t])))
              : (r[t] = this._parseByType(o.propertiesTypes[t]));
          }
          return r;
        }
        _newPacket() {
          return (
            s("_newPacket"),
            this.packet &&
              (this._list.consume(this.packet.length),
              s(
                "_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d",
                this.packet.cmd,
                this.packet.payload,
                this.packet.length
              ),
              this.emit("packet", this.packet)),
            s("_newPacket: new packet"),
            (this.packet = new i()),
            (this._pos = 0),
            !0
          );
        }
        _emitError(e) {
          s("_emitError", e), (this.error = e), this.emit("error", e);
        }
      };
    }),
    ad = dc((e, t) => {
      mc(), lh(), qu();
      var { Buffer: r } = (ah(), fc(rh)),
        n = {},
        i = r.isBuffer(r.from([1, 2]).subarray(0, 1));
      function o(e) {
        let t = r.allocUnsafe(2);
        return t.writeUInt8(e >> 8, 0), t.writeUInt8(255 & e, 1), t;
      }
      t.exports = {
        cache: n,
        generateCache: function () {
          for (let e = 0; e < 65536; e++) n[e] = o(e);
        },
        generateNumber: o,
        genBufVariableByteInt: function (e) {
          let t = 0,
            n = 0,
            o = r.allocUnsafe(4);
          do {
            (t = e % 128 | 0),
              (e = (e / 128) | 0) > 0 && (t |= 128),
              o.writeUInt8(t, n++);
          } while (e > 0 && n < 4);
          return e > 0 && (n = 0), i ? o.subarray(0, n) : o.slice(0, n);
        },
        generate4ByteBuffer: function (e) {
          let t = r.allocUnsafe(4);
          return t.writeUInt32BE(e, 0), t;
        },
      };
    }),
    ld = dc((e, t) => {
      mc(),
        lh(),
        qu(),
        typeof gc > "u" ||
        !gc.version ||
        0 === gc.version.indexOf("v0.") ||
        (0 === gc.version.indexOf("v1.") && 0 !== gc.version.indexOf("v1.8."))
          ? (t.exports = {
              nextTick: function (e, t, r, n) {
                if ("function" != typeof e)
                  throw new TypeError('"callback" argument must be a function');
                var i,
                  o,
                  s = arguments.length;
                switch (s) {
                  case 0:
                  case 1:
                    return gc.nextTick(e);
                  case 2:
                    return gc.nextTick(function () {
                      e.call(null, t);
                    });
                  case 3:
                    return gc.nextTick(function () {
                      e.call(null, t, r);
                    });
                  case 4:
                    return gc.nextTick(function () {
                      e.call(null, t, r, n);
                    });
                  default:
                    for (i = new Array(s - 1), o = 0; o < i.length; )
                      i[o++] = arguments[o];
                    return gc.nextTick(function () {
                      e.apply(null, i);
                    });
                }
              },
            })
          : (t.exports = gc);
    }),
    cd = dc((e, t) => {
      mc(), lh(), qu();
      var r = rd(),
        { Buffer: n } = (ah(), fc(rh)),
        i = n.allocUnsafe(0),
        o = n.from([0]),
        s = ad(),
        a = ld().nextTick,
        l = od()("mqtt-packet:writeToStream"),
        c = s.cache,
        u = s.generateNumber,
        h = s.generateCache,
        d = s.genBufVariableByteInt,
        p = s.generate4ByteBuffer,
        f = w,
        m = !0;
      function g(e, t, s) {
        switch (
          (l("generate called"),
          t.cork && (t.cork(), a(_, t)),
          m && ((m = !1), h()),
          l("generate: packet.cmd: %s", e.cmd),
          e.cmd)
        ) {
          case "connect":
            return (function (e, t) {
              let i = e || {},
                o = i.protocolId || "MQTT",
                s = i.protocolVersion || 4,
                a = i.will,
                l = i.clean,
                c = i.keepalive || 0,
                u = i.clientId || "",
                h = i.username,
                d = i.password,
                p = i.properties;
              void 0 === l && (l = !0);
              let m,
                g,
                _ = 0;
              if (!o || ("string" != typeof o && !n.isBuffer(o)))
                return t.destroy(new Error("Invalid protocolId")), !1;
              if (((_ += o.length + 2), 3 !== s && 4 !== s && 5 !== s))
                return t.destroy(new Error("Invalid protocol version")), !1;
              if (
                ((_ += 1),
                ("string" == typeof u || n.isBuffer(u)) &&
                  (u || s >= 4) &&
                  (u || l))
              )
                _ += n.byteLength(u) + 2;
              else {
                if (s < 4)
                  return (
                    t.destroy(
                      new Error("clientId must be supplied before 3.1.1")
                    ),
                    !1
                  );
                if (1 * l == 0)
                  return (
                    t.destroy(
                      new Error(
                        "clientId must be given if cleanSession set to 0"
                      )
                    ),
                    !1
                  );
              }
              if ("number" != typeof c || c < 0 || c > 65535 || c % 1 != 0)
                return t.destroy(new Error("Invalid keepalive")), !1;
              if (((_ += 2), (_ += 1), 5 === s)) {
                if (((m = M(t, p)), !m)) return !1;
                _ += m.length;
              }
              if (a) {
                if ("object" != typeof a)
                  return t.destroy(new Error("Invalid will")), !1;
                if (!a.topic || "string" != typeof a.topic)
                  return t.destroy(new Error("Invalid will topic")), !1;
                if (((_ += n.byteLength(a.topic) + 2), (_ += 2), a.payload)) {
                  if (!(a.payload.length >= 0))
                    return t.destroy(new Error("Invalid will payload")), !1;
                  "string" == typeof a.payload
                    ? (_ += n.byteLength(a.payload))
                    : (_ += a.payload.length);
                }
                if (((g = {}), 5 === s)) {
                  if (((g = M(t, a.properties)), !g)) return !1;
                  _ += g.length;
                }
              }
              let v = !1;
              if (null != h) {
                if (!C(h)) return t.destroy(new Error("Invalid username")), !1;
                (v = !0), (_ += n.byteLength(h) + 2);
              }
              if (null != d) {
                if (!v)
                  return (
                    t.destroy(
                      new Error("Username is required to use password")
                    ),
                    !1
                  );
                if (!C(d)) return t.destroy(new Error("Invalid password")), !1;
                _ += P(d) + 2;
              }
              t.write(r.CONNECT_HEADER),
                y(t, _),
                E(t, o),
                i.bridgeMode && (s += 128),
                t.write(
                  131 === s
                    ? r.VERSION131
                    : 132 === s
                    ? r.VERSION132
                    : 4 === s
                    ? r.VERSION4
                    : 5 === s
                    ? r.VERSION5
                    : r.VERSION3
                );
              let x = 0;
              return (
                (x |= null != h ? r.USERNAME_MASK : 0),
                (x |= null != d ? r.PASSWORD_MASK : 0),
                (x |= a && a.retain ? r.WILL_RETAIN_MASK : 0),
                (x |= a && a.qos ? a.qos << r.WILL_QOS_SHIFT : 0),
                (x |= a ? r.WILL_FLAG_MASK : 0),
                (x |= l ? r.CLEAN_SESSION_MASK : 0),
                t.write(n.from([x])),
                f(t, c),
                5 === s && m.write(),
                E(t, u),
                a && (5 === s && g.write(), b(t, a.topic), E(t, a.payload)),
                null != h && E(t, h),
                null != d && E(t, d),
                !0
              );
            })(e, t);
          case "connack":
            return (function (e, t, i) {
              let s = i ? i.protocolVersion : 4,
                a = e || {},
                l = 5 === s ? a.reasonCode : a.returnCode,
                c = a.properties,
                u = 2;
              if ("number" != typeof l)
                return t.destroy(new Error("Invalid return code")), !1;
              let h = null;
              if (5 === s) {
                if (((h = M(t, c)), !h)) return !1;
                u += h.length;
              }
              return (
                t.write(r.CONNACK_HEADER),
                y(t, u),
                t.write(a.sessionPresent ? r.SESSIONPRESENT_HEADER : o),
                t.write(n.from([l])),
                h?.write(),
                !0
              );
            })(e, t, s);
          case "publish":
            return (function (e, t, o) {
              l("publish: packet: %o", e);
              let s = o ? o.protocolVersion : 4,
                a = e || {},
                c = a.qos || 0,
                u = a.retain ? r.RETAIN_MASK : 0,
                h = a.topic,
                d = a.payload || i,
                p = a.messageId,
                m = a.properties,
                g = 0;
              if ("string" == typeof h) g += n.byteLength(h) + 2;
              else {
                if (!n.isBuffer(h))
                  return t.destroy(new Error("Invalid topic")), !1;
                g += h.length + 2;
              }
              if (
                (n.isBuffer(d) ? (g += d.length) : (g += n.byteLength(d)),
                c && "number" != typeof p)
              )
                return t.destroy(new Error("Invalid messageId")), !1;
              c && (g += 2);
              let _ = null;
              if (5 === s) {
                if (((_ = M(t, m)), !_)) return !1;
                g += _.length;
              }
              return (
                t.write(r.PUBLISH_HEADER[c][a.dup ? 1 : 0][u ? 1 : 0]),
                y(t, g),
                f(t, P(h)),
                t.write(h),
                c > 0 && f(t, p),
                _?.write(),
                l("publish: payload: %o", d),
                t.write(d)
              );
            })(e, t, s);
          case "puback":
          case "pubrec":
          case "pubrel":
          case "pubcomp":
            return (function (e, t, i) {
              let o = i ? i.protocolVersion : 4,
                s = e || {},
                a = s.cmd || "puback",
                l = s.messageId,
                c = s.dup && "pubrel" === a ? r.DUP_MASK : 0,
                u = 0,
                h = s.reasonCode,
                d = s.properties,
                p = 5 === o ? 3 : 2;
              if (("pubrel" === a && (u = 1), "number" != typeof l))
                return t.destroy(new Error("Invalid messageId")), !1;
              let m = null;
              if (5 === o && "object" == typeof d) {
                if (((m = T(t, d, i, p)), !m)) return !1;
                p += m.length;
              }
              return (
                t.write(r.ACKS[a][u][c][0]),
                3 === p && (p += 0 !== h ? 1 : -1),
                y(t, p),
                f(t, l),
                5 === o && 2 !== p && t.write(n.from([h])),
                null !== m ? m.write() : 4 === p && t.write(n.from([0])),
                !0
              );
            })(e, t, s);
          case "subscribe":
            return (function (e, t, i) {
              l("subscribe: packet: ");
              let o = i ? i.protocolVersion : 4,
                s = e || {},
                a = s.dup ? r.DUP_MASK : 0,
                c = s.messageId,
                u = s.subscriptions,
                h = s.properties,
                d = 0;
              if ("number" != typeof c)
                return t.destroy(new Error("Invalid messageId")), !1;
              d += 2;
              let p = null;
              if (5 === o) {
                if (((p = M(t, h)), !p)) return !1;
                d += p.length;
              }
              if ("object" != typeof u || !u.length)
                return t.destroy(new Error("Invalid subscriptions")), !1;
              for (let e = 0; e < u.length; e += 1) {
                let r = u[e].topic,
                  i = u[e].qos;
                if ("string" != typeof r)
                  return (
                    t.destroy(
                      new Error("Invalid subscriptions - invalid topic")
                    ),
                    !1
                  );
                if ("number" != typeof i)
                  return (
                    t.destroy(new Error("Invalid subscriptions - invalid qos")),
                    !1
                  );
                if (5 === o) {
                  if ("boolean" != typeof (u[e].nl || !1))
                    return (
                      t.destroy(
                        new Error("Invalid subscriptions - invalid No Local")
                      ),
                      !1
                    );
                  if ("boolean" != typeof (u[e].rap || !1))
                    return (
                      t.destroy(
                        new Error(
                          "Invalid subscriptions - invalid Retain as Published"
                        )
                      ),
                      !1
                    );
                  let r = u[e].rh || 0;
                  if ("number" != typeof r || r > 2)
                    return (
                      t.destroy(
                        new Error(
                          "Invalid subscriptions - invalid Retain Handling"
                        )
                      ),
                      !1
                    );
                }
                d += n.byteLength(r) + 2 + 1;
              }
              l("subscribe: writing to stream: %o", r.SUBSCRIBE_HEADER),
                t.write(r.SUBSCRIBE_HEADER[1][a ? 1 : 0][0]),
                y(t, d),
                f(t, c),
                null !== p && p.write();
              let m = !0;
              for (let e of u) {
                let i,
                  s = e.topic,
                  a = e.qos,
                  l = +e.nl,
                  c = +e.rap,
                  u = e.rh;
                b(t, s),
                  (i = r.SUBSCRIBE_OPTIONS_QOS[a]),
                  5 === o &&
                    ((i |= l ? r.SUBSCRIBE_OPTIONS_NL : 0),
                    (i |= c ? r.SUBSCRIBE_OPTIONS_RAP : 0),
                    (i |= u ? r.SUBSCRIBE_OPTIONS_RH[u] : 0)),
                  (m = t.write(n.from([i])));
              }
              return m;
            })(e, t, s);
          case "suback":
            return (function (e, t, i) {
              let o = i ? i.protocolVersion : 4,
                s = e || {},
                a = s.messageId,
                l = s.granted,
                c = s.properties,
                u = 0;
              if ("number" != typeof a)
                return t.destroy(new Error("Invalid messageId")), !1;
              if (((u += 2), "object" != typeof l || !l.length))
                return t.destroy(new Error("Invalid qos vector")), !1;
              for (let e = 0; e < l.length; e += 1) {
                if ("number" != typeof l[e])
                  return t.destroy(new Error("Invalid qos vector")), !1;
                u += 1;
              }
              let h = null;
              if (5 === o) {
                if (((h = T(t, c, i, u)), !h)) return !1;
                u += h.length;
              }
              return (
                t.write(r.SUBACK_HEADER),
                y(t, u),
                f(t, a),
                null !== h && h.write(),
                t.write(n.from(l))
              );
            })(e, t, s);
          case "unsubscribe":
            return (function (e, t, i) {
              let o = i ? i.protocolVersion : 4,
                s = e || {},
                a = s.messageId,
                l = s.dup ? r.DUP_MASK : 0,
                c = s.unsubscriptions,
                u = s.properties,
                h = 0;
              if ("number" != typeof a)
                return t.destroy(new Error("Invalid messageId")), !1;
              if (((h += 2), "object" != typeof c || !c.length))
                return t.destroy(new Error("Invalid unsubscriptions")), !1;
              for (let e = 0; e < c.length; e += 1) {
                if ("string" != typeof c[e])
                  return t.destroy(new Error("Invalid unsubscriptions")), !1;
                h += n.byteLength(c[e]) + 2;
              }
              let d = null;
              if (5 === o) {
                if (((d = M(t, u)), !d)) return !1;
                h += d.length;
              }
              t.write(r.UNSUBSCRIBE_HEADER[1][l ? 1 : 0][0]),
                y(t, h),
                f(t, a),
                null !== d && d.write();
              let p = !0;
              for (let e = 0; e < c.length; e++) p = b(t, c[e]);
              return p;
            })(e, t, s);
          case "unsuback":
            return (function (e, t, i) {
              let o = i ? i.protocolVersion : 4,
                s = e || {},
                a = s.messageId,
                l = s.dup ? r.DUP_MASK : 0,
                c = s.granted,
                u = s.properties,
                h = s.cmd,
                d = 2;
              if ("number" != typeof a)
                return t.destroy(new Error("Invalid messageId")), !1;
              if (5 === o) {
                if ("object" != typeof c || !c.length)
                  return t.destroy(new Error("Invalid qos vector")), !1;
                for (let e = 0; e < c.length; e += 1) {
                  if ("number" != typeof c[e])
                    return t.destroy(new Error("Invalid qos vector")), !1;
                  d += 1;
                }
              }
              let p = null;
              if (5 === o) {
                if (((p = T(t, u, i, d)), !p)) return !1;
                d += p.length;
              }
              return (
                t.write(r.ACKS[h][0][l][0]),
                y(t, d),
                f(t, a),
                null !== p && p.write(),
                5 === o && t.write(n.from(c)),
                !0
              );
            })(e, t, s);
          case "pingreq":
          case "pingresp":
            return (function (e, t) {
              return t.write(r.EMPTY[e.cmd]);
            })(e, t);
          case "disconnect":
            return (function (e, t, i) {
              let o = i ? i.protocolVersion : 4,
                s = e || {},
                a = s.reasonCode,
                l = s.properties,
                c = 5 === o ? 1 : 0,
                u = null;
              if (5 === o) {
                if (((u = T(t, l, i, c)), !u)) return !1;
                c += u.length;
              }
              return (
                t.write(n.from([r.codes.disconnect << 4])),
                y(t, c),
                5 === o && t.write(n.from([a])),
                null !== u && u.write(),
                !0
              );
            })(e, t, s);
          case "auth":
            return (function (e, t, i) {
              let o = i ? i.protocolVersion : 4,
                s = e || {},
                a = s.reasonCode,
                l = s.properties,
                c = 5 === o ? 1 : 0;
              5 !== o &&
                t.destroy(new Error("Invalid mqtt version for auth packet"));
              let u = T(t, l, i, c);
              return (
                !!u &&
                ((c += u.length),
                t.write(n.from([r.codes.auth << 4])),
                y(t, c),
                t.write(n.from([a])),
                null !== u && u.write(),
                !0)
              );
            })(e, t, s);
          default:
            return t.destroy(new Error("Unknown command")), !1;
        }
      }
      function _(e) {
        e.uncork();
      }
      Object.defineProperty(g, "cacheNumbers", {
        get: () => f === w,
        set(e) {
          e
            ? ((!c || 0 === Object.keys(c).length) && (m = !0), (f = w))
            : ((m = !1), (f = S));
        },
      });
      var v = {};
      function y(e, t) {
        if (t > r.VARBYTEINT_MAX)
          return (
            e.destroy(new Error(`Invalid variable byte integer: ${t}`)), !1
          );
        let n = v[t];
        return (
          n || ((n = d(t)), t < 16384 && (v[t] = n)),
          l("writeVarByteInt: writing to stream: %o", n),
          e.write(n)
        );
      }
      function b(e, t) {
        let r = n.byteLength(t);
        return f(e, r), l("writeString: %s", t), e.write(t, "utf8");
      }
      function x(e, t, r) {
        b(e, t), b(e, r);
      }
      function w(e, t) {
        return (
          l("writeNumberCached: number: %d", t),
          l("writeNumberCached: %o", c[t]),
          e.write(c[t])
        );
      }
      function S(e, t) {
        let r = u(t);
        return l("writeNumberGenerated: %o", r), e.write(r);
      }
      function E(e, t) {
        "string" == typeof t
          ? b(e, t)
          : t
          ? (f(e, t.length), e.write(t))
          : f(e, 0);
      }
      function M(e, t) {
        if ("object" != typeof t || null != t.length)
          return {
            length: 1,
            write() {
              R(e, {}, 0);
            },
          };
        let i = 0;
        function o(t, i) {
          let o = 0;
          switch (r.propertiesTypes[t]) {
            case "byte":
              if ("boolean" != typeof i)
                return e.destroy(new Error(`Invalid ${t}: ${i}`)), !1;
              o += 2;
              break;
            case "int8":
              if ("number" != typeof i || i < 0 || i > 255)
                return e.destroy(new Error(`Invalid ${t}: ${i}`)), !1;
              o += 2;
              break;
            case "binary":
              if (i && null === i)
                return e.destroy(new Error(`Invalid ${t}: ${i}`)), !1;
              o += 1 + n.byteLength(i) + 2;
              break;
            case "int16":
              if ("number" != typeof i || i < 0 || i > 65535)
                return e.destroy(new Error(`Invalid ${t}: ${i}`)), !1;
              o += 3;
              break;
            case "int32":
              if ("number" != typeof i || i < 0 || i > 4294967295)
                return e.destroy(new Error(`Invalid ${t}: ${i}`)), !1;
              o += 5;
              break;
            case "var":
              if ("number" != typeof i || i < 0 || i > 268435455)
                return e.destroy(new Error(`Invalid ${t}: ${i}`)), !1;
              o += 1 + n.byteLength(d(i));
              break;
            case "string":
              if ("string" != typeof i)
                return e.destroy(new Error(`Invalid ${t}: ${i}`)), !1;
              o += 3 + n.byteLength(i.toString());
              break;
            case "pair":
              if ("object" != typeof i)
                return e.destroy(new Error(`Invalid ${t}: ${i}`)), !1;
              o += Object.getOwnPropertyNames(i).reduce((e, t) => {
                let r = i[t];
                return (
                  Array.isArray(r)
                    ? (e += r.reduce(
                        (e, r) =>
                          e +
                          (3 +
                            n.byteLength(t.toString()) +
                            2 +
                            n.byteLength(r.toString())),
                        0
                      ))
                    : (e +=
                        3 +
                        n.byteLength(t.toString()) +
                        2 +
                        n.byteLength(i[t].toString())),
                  e
                );
              }, 0);
              break;
            default:
              return e.destroy(new Error(`Invalid property ${t}: ${i}`)), !1;
          }
          return o;
        }
        if (t)
          for (let e in t) {
            let r = 0,
              n = 0,
              s = t[e];
            if (void 0 !== s) {
              if (Array.isArray(s))
                for (let t = 0; t < s.length; t++) {
                  if (((n = o(e, s[t])), !n)) return !1;
                  r += n;
                }
              else {
                if (((n = o(e, s)), !n)) return !1;
                r = n;
              }
              if (!r) return !1;
              i += r;
            }
          }
        return {
          length: n.byteLength(d(i)) + i,
          write() {
            R(e, t, i);
          },
        };
      }
      function T(e, t, r, n) {
        let i = ["reasonString", "userProperties"],
          o =
            r && r.properties && r.properties.maximumPacketSize
              ? r.properties.maximumPacketSize
              : 0,
          s = M(e, t);
        if (o)
          for (; n + s.length > o; ) {
            let r = i.shift();
            if (!r || !t[r]) return !1;
            delete t[r], (s = M(e, t));
          }
        return s;
      }
      function A(e, t, i) {
        switch (r.propertiesTypes[t]) {
          case "byte":
            e.write(n.from([r.properties[t]])), e.write(n.from([+i]));
            break;
          case "int8":
            e.write(n.from([r.properties[t]])), e.write(n.from([i]));
            break;
          case "binary":
            e.write(n.from([r.properties[t]])), E(e, i);
            break;
          case "int16":
            e.write(n.from([r.properties[t]])), f(e, i);
            break;
          case "int32":
            e.write(n.from([r.properties[t]])),
              (function (e, t) {
                let r = p(t);
                l("write4ByteNumber: %o", r), e.write(r);
              })(e, i);
            break;
          case "var":
            e.write(n.from([r.properties[t]])), y(e, i);
            break;
          case "string":
            e.write(n.from([r.properties[t]])), b(e, i);
            break;
          case "pair":
            Object.getOwnPropertyNames(i).forEach((o) => {
              let s = i[o];
              Array.isArray(s)
                ? s.forEach((i) => {
                    e.write(n.from([r.properties[t]])),
                      x(e, o.toString(), i.toString());
                  })
                : (e.write(n.from([r.properties[t]])),
                  x(e, o.toString(), s.toString()));
            });
            break;
          default:
            return (
              e.destroy(new Error(`Invalid property ${t} value: ${i}`)), !1
            );
        }
      }
      function R(e, t, r) {
        y(e, r);
        for (let r in t)
          if (Object.prototype.hasOwnProperty.call(t, r) && null != t[r]) {
            let n = t[r];
            if (Array.isArray(n))
              for (let t = 0; t < n.length; t++) A(e, r, n[t]);
            else A(e, r, n);
          }
      }
      function P(e) {
        return e ? (e instanceof n ? e.length : n.byteLength(e)) : 0;
      }
      function C(e) {
        return "string" == typeof e || e instanceof n;
      }
      t.exports = g;
    }),
    ud = dc((e, t) => {
      mc(), lh(), qu();
      var r = cd(),
        { EventEmitter: n } = (Th(), fc(ph)),
        { Buffer: i } = (ah(), fc(rh)),
        o = class extends n {
          constructor() {
            super(), (this._array = new Array(20)), (this._i = 0);
          }
          write(e) {
            return (this._array[this._i++] = e), !0;
          }
          concat() {
            let e,
              t = 0,
              r = new Array(this._array.length),
              n = this._array,
              o = 0;
            for (e = 0; e < n.length && void 0 !== n[e]; e++)
              "string" != typeof n[e]
                ? (r[e] = n[e].length)
                : (r[e] = i.byteLength(n[e])),
                (t += r[e]);
            let s = i.allocUnsafe(t);
            for (e = 0; e < n.length && void 0 !== n[e]; e++)
              "string" != typeof n[e]
                ? (n[e].copy(s, o), (o += r[e]))
                : (s.write(n[e], o), (o += r[e]));
            return s;
          }
          destroy(e) {
            e && this.emit("error", e);
          }
        };
      t.exports = function (e, t) {
        let n = new o();
        return r(e, n, t), n.concat();
      };
    }),
    hd = dc((e) => {
      mc(),
        lh(),
        qu(),
        (e.parser = sd().parser),
        (e.generate = ud()),
        (e.writeToStream = cd());
    }),
    dd = dc((e, t) => {
      function r(e) {
        return e instanceof ih
          ? ih.from(e)
          : new e.constructor(e.buffer.slice(), e.byteOffset, e.length);
      }
      mc(),
        lh(),
        qu(),
        (t.exports = function (e) {
          if ((e = e || {}).circles)
            return (function (e) {
              let t = [],
                n = [],
                i = new Map();
              if (
                (i.set(Date, (e) => new Date(e)),
                i.set(Map, (e, t) => new Map(s(Array.from(e), t))),
                i.set(Set, (e, t) => new Set(s(Array.from(e), t))),
                e.constructorHandlers)
              )
                for (let t of e.constructorHandlers) i.set(t[0], t[1]);
              let o = null;
              return e.proto
                ? function e(a) {
                    if ("object" != typeof a || null === a) return a;
                    if (Array.isArray(a)) return s(a, e);
                    if (a.constructor !== Object && (o = i.get(a.constructor)))
                      return o(a, e);
                    let l = {};
                    t.push(a), n.push(l);
                    for (let s in a) {
                      let c = a[s];
                      if ("object" != typeof c || null === c) l[s] = c;
                      else if (
                        c.constructor !== Object &&
                        (o = i.get(c.constructor))
                      )
                        l[s] = o(c, e);
                      else if (ArrayBuffer.isView(c)) l[s] = r(c);
                      else {
                        let r = t.indexOf(c);
                        l[s] = -1 !== r ? n[r] : e(c);
                      }
                    }
                    return t.pop(), n.pop(), l;
                  }
                : function e(a) {
                    if ("object" != typeof a || null === a) return a;
                    if (Array.isArray(a)) return s(a, e);
                    if (a.constructor !== Object && (o = i.get(a.constructor)))
                      return o(a, e);
                    let l = {};
                    t.push(a), n.push(l);
                    for (let s in a) {
                      if (!1 === Object.hasOwnProperty.call(a, s)) continue;
                      let c = a[s];
                      if ("object" != typeof c || null === c) l[s] = c;
                      else if (
                        c.constructor !== Object &&
                        (o = i.get(c.constructor))
                      )
                        l[s] = o(c, e);
                      else if (ArrayBuffer.isView(c)) l[s] = r(c);
                      else {
                        let r = t.indexOf(c);
                        l[s] = -1 !== r ? n[r] : e(c);
                      }
                    }
                    return t.pop(), n.pop(), l;
                  };
              function s(e, s) {
                let a = Object.keys(e),
                  l = new Array(a.length);
                for (let c = 0; c < a.length; c++) {
                  let u = a[c],
                    h = e[u];
                  if ("object" != typeof h || null === h) l[u] = h;
                  else if (
                    h.constructor !== Object &&
                    (o = i.get(h.constructor))
                  )
                    l[u] = o(h, s);
                  else if (ArrayBuffer.isView(h)) l[u] = r(h);
                  else {
                    let e = t.indexOf(h);
                    l[u] = -1 !== e ? n[e] : s(h);
                  }
                }
                return l;
              }
            })(e);
          let t = new Map();
          if (
            (t.set(Date, (e) => new Date(e)),
            t.set(Map, (e, t) => new Map(i(Array.from(e), t))),
            t.set(Set, (e, t) => new Set(i(Array.from(e), t))),
            e.constructorHandlers)
          )
            for (let r of e.constructorHandlers) t.set(r[0], r[1]);
          let n = null;
          return e.proto
            ? function e(o) {
                if ("object" != typeof o || null === o) return o;
                if (Array.isArray(o)) return i(o, e);
                if (o.constructor !== Object && (n = t.get(o.constructor)))
                  return n(o, e);
                let s = {};
                for (let i in o) {
                  let a = o[i];
                  "object" != typeof a || null === a
                    ? (s[i] = a)
                    : a.constructor !== Object && (n = t.get(a.constructor))
                    ? (s[i] = n(a, e))
                    : ArrayBuffer.isView(a)
                    ? (s[i] = r(a))
                    : (s[i] = e(a));
                }
                return s;
              }
            : function e(o) {
                if ("object" != typeof o || null === o) return o;
                if (Array.isArray(o)) return i(o, e);
                if (o.constructor !== Object && (n = t.get(o.constructor)))
                  return n(o, e);
                let s = {};
                for (let i in o) {
                  if (!1 === Object.hasOwnProperty.call(o, i)) continue;
                  let a = o[i];
                  "object" != typeof a || null === a
                    ? (s[i] = a)
                    : a.constructor !== Object && (n = t.get(a.constructor))
                    ? (s[i] = n(a, e))
                    : ArrayBuffer.isView(a)
                    ? (s[i] = r(a))
                    : (s[i] = e(a));
                }
                return s;
              };
          function i(e, i) {
            let o = Object.keys(e),
              s = new Array(o.length);
            for (let a = 0; a < o.length; a++) {
              let l = o[a],
                c = e[l];
              "object" != typeof c || null === c
                ? (s[l] = c)
                : c.constructor !== Object && (n = t.get(c.constructor))
                ? (s[l] = n(c, i))
                : ArrayBuffer.isView(c)
                ? (s[l] = r(c))
                : (s[l] = i(c));
            }
            return s;
          }
        });
    }),
    pd = dc((e, t) => {
      mc(), lh(), qu(), (t.exports = dd()());
    }),
    fd = dc((e) => {
      function t(e) {
        let t = e.split("/");
        for (let e = 0; e < t.length; e++)
          if ("+" !== t[e]) {
            if ("#" === t[e]) return e === t.length - 1;
            if (-1 !== t[e].indexOf("+") || -1 !== t[e].indexOf("#")) return !1;
          }
        return !0;
      }
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "__esModule", { value: !0 }),
        (e.validateTopic = t),
        (e.validateTopics = function (e) {
          if (0 === e.length) return "empty_topic_list";
          for (let r = 0; r < e.length; r++) if (!t(e[r])) return e[r];
          return null;
        });
    }),
    md = dc((e) => {
      mc(), lh(), qu(), Object.defineProperty(e, "__esModule", { value: !0 });
      var t = Qh(),
        r = { objectMode: !0 },
        n = { clean: !0 };
      e.default = class {
        options;
        _inflights;
        constructor(e) {
          (this.options = e || {}),
            (this.options = { ...n, ...e }),
            (this._inflights = new Map());
        }
        put(e, t) {
          return this._inflights.set(e.messageId, e), t && t(), this;
        }
        createStream() {
          let e = new t.Readable(r),
            n = [],
            i = !1,
            o = 0;
          return (
            this._inflights.forEach((e, t) => {
              n.push(e);
            }),
            (e._read = () => {
              !i && o < n.length ? e.push(n[o++]) : e.push(null);
            }),
            (e.destroy = (t) => {
              if (!i)
                return (
                  (i = !0),
                  setTimeout(() => {
                    e.emit("close");
                  }, 0),
                  e
                );
            }),
            e
          );
        }
        del(e, t) {
          let r = this._inflights.get(e.messageId);
          return (
            r
              ? (this._inflights.delete(e.messageId), t(null, r))
              : t && t(new Error("missing packet")),
            this
          );
        }
        get(e, t) {
          let r = this._inflights.get(e.messageId);
          return r ? t(null, r) : t && t(new Error("missing packet")), this;
        }
        close(e) {
          this.options.clean && (this._inflights = null), e && e();
        }
      };
    }),
    gd = dc((e) => {
      mc(), lh(), qu(), Object.defineProperty(e, "__esModule", { value: !0 });
      var t = [0, 16, 128, 131, 135, 144, 145, 151, 153];
      e.default = (e, r, n) => {
        e.log("handlePublish: packet %o", r), (n = typeof n < "u" ? n : e.noop);
        let i = r.topic.toString(),
          o = r.payload,
          { qos: s } = r,
          { messageId: a } = r,
          { options: l } = e;
        if (5 === e.options.protocolVersion) {
          let t;
          if ((r.properties && (t = r.properties.topicAlias), typeof t < "u"))
            if (0 === i.length) {
              if (!(t > 0 && t <= 65535))
                return (
                  e.log(
                    "handlePublish :: topic alias out of range. alias: %d",
                    t
                  ),
                  void e.emit(
                    "error",
                    new Error("Received Topic Alias is out of range")
                  )
                );
              {
                let r = e.topicAliasRecv.getTopicByAlias(t);
                if (!r)
                  return (
                    e.log(
                      "handlePublish :: unregistered topic alias. alias: %d",
                      t
                    ),
                    void e.emit(
                      "error",
                      new Error("Received unregistered Topic Alias")
                    )
                  );
                (i = r),
                  e.log(
                    "handlePublish :: topic complemented by alias. topic: %s - alias: %d",
                    i,
                    t
                  );
              }
            } else {
              if (!e.topicAliasRecv.put(i, t))
                return (
                  e.log(
                    "handlePublish :: topic alias out of range. alias: %d",
                    t
                  ),
                  void e.emit(
                    "error",
                    new Error("Received Topic Alias is out of range")
                  )
                );
              e.log("handlePublish :: registered topic: %s - alias: %d", i, t);
            }
        }
        switch ((e.log("handlePublish: qos %d", s), s)) {
          case 2:
            l.customHandleAcks(
              i,
              o,
              r,
              (i, o) => (
                "number" == typeof i && ((o = i), (i = null)),
                i
                  ? e.emit("error", i)
                  : -1 === t.indexOf(o)
                  ? e.emit("error", new Error("Wrong reason code for pubrec"))
                  : void (o
                      ? e._sendPacket(
                          { cmd: "pubrec", messageId: a, reasonCode: o },
                          n
                        )
                      : e.incomingStore.put(r, () => {
                          e._sendPacket({ cmd: "pubrec", messageId: a }, n);
                        }))
              )
            );
            break;
          case 1:
            l.customHandleAcks(
              i,
              o,
              r,
              (s, l) => (
                "number" == typeof s && ((l = s), (s = null)),
                s
                  ? e.emit("error", s)
                  : -1 === t.indexOf(l)
                  ? e.emit("error", new Error("Wrong reason code for puback"))
                  : (l || e.emit("message", i, o, r),
                    void e.handleMessage(r, (t) => {
                      if (t) return n && n(t);
                      e._sendPacket(
                        { cmd: "puback", messageId: a, reasonCode: l },
                        n
                      );
                    }))
              )
            );
            break;
          case 0:
            e.emit("message", i, o, r), e.handleMessage(r, n);
            break;
          default:
            e.log("handlePublish: unknown QoS. Doing nothing.");
        }
      };
    }),
    _d = dc((e, t) => {
      t.exports = { version: "5.14.1" };
    }),
    vd = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "__esModule", { value: !0 }),
        (e.MQTTJS_VERSION =
          e.nextTick =
          e.ErrorWithSubackPacket =
          e.ErrorWithReasonCode =
            void 0),
        (e.applyMixin = function (e, t, r = !1) {
          let n = [t];
          for (;;) {
            let e = n[0],
              t = Object.getPrototypeOf(e);
            if (!t?.prototype) break;
            n.unshift(t);
          }
          for (let t of n)
            for (let n of Object.getOwnPropertyNames(t.prototype))
              (r || "constructor" !== n) &&
                Object.defineProperty(
                  e.prototype,
                  n,
                  Object.getOwnPropertyDescriptor(t.prototype, n) ??
                    Object.create(null)
                );
        });
      var t = class e extends Error {
        code;
        constructor(t, r) {
          super(t),
            (this.code = r),
            Object.setPrototypeOf(this, e.prototype),
            (Object.getPrototypeOf(this).name = "ErrorWithReasonCode");
        }
      };
      e.ErrorWithReasonCode = t;
      var r = class e extends Error {
        packet;
        constructor(t, r) {
          super(t),
            (this.packet = r),
            Object.setPrototypeOf(this, e.prototype),
            (Object.getPrototypeOf(this).name = "ErrorWithSubackPacket");
        }
      };
      (e.ErrorWithSubackPacket = r),
        (e.nextTick =
          "function" == typeof gc?.nextTick
            ? gc.nextTick
            : (e) => {
                setTimeout(e, 0);
              }),
        (e.MQTTJS_VERSION = _d().version);
    }),
    yd = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "__esModule", { value: !0 }),
        (e.ReasonCodes = void 0);
      var t = vd();
      (e.ReasonCodes = {
        0: "",
        1: "Unacceptable protocol version",
        2: "Identifier rejected",
        3: "Server unavailable",
        4: "Bad username or password",
        5: "Not authorized",
        16: "No matching subscribers",
        17: "No subscription existed",
        128: "Unspecified error",
        129: "Malformed Packet",
        130: "Protocol Error",
        131: "Implementation specific error",
        132: "Unsupported Protocol Version",
        133: "Client Identifier not valid",
        134: "Bad User Name or Password",
        135: "Not authorized",
        136: "Server unavailable",
        137: "Server busy",
        138: "Banned",
        139: "Server shutting down",
        140: "Bad authentication method",
        141: "Keep Alive timeout",
        142: "Session taken over",
        143: "Topic Filter invalid",
        144: "Topic Name invalid",
        145: "Packet identifier in use",
        146: "Packet Identifier not found",
        147: "Receive Maximum exceeded",
        148: "Topic Alias invalid",
        149: "Packet too large",
        150: "Message rate too high",
        151: "Quota exceeded",
        152: "Administrative action",
        153: "Payload format invalid",
        154: "Retain not supported",
        155: "QoS not supported",
        156: "Use another server",
        157: "Server moved",
        158: "Shared Subscriptions not supported",
        159: "Connection rate exceeded",
        160: "Maximum connect time",
        161: "Subscription Identifiers not supported",
        162: "Wildcard Subscriptions not supported",
      }),
        (e.default = (r, n) => {
          let { messageId: i } = n,
            o = n.cmd,
            s = null,
            a = r.outgoing[i] ? r.outgoing[i].cb : null,
            l = null;
          if (a) {
            switch ((r.log("_handleAck :: packet type", o), o)) {
              case "pubcomp":
              case "puback": {
                let o = n.reasonCode;
                o && o > 0 && 16 !== o
                  ? ((l = new t.ErrorWithReasonCode(
                      `Publish error: ${e.ReasonCodes[o]}`,
                      o
                    )),
                    r._removeOutgoingAndStoreMessage(i, () => {
                      a(l, n);
                    }))
                  : r._removeOutgoingAndStoreMessage(i, a);
                break;
              }
              case "pubrec": {
                s = { cmd: "pubrel", qos: 2, messageId: i };
                let o = n.reasonCode;
                o && o > 0 && 16 !== o
                  ? ((l = new t.ErrorWithReasonCode(
                      `Publish error: ${e.ReasonCodes[o]}`,
                      o
                    )),
                    r._removeOutgoingAndStoreMessage(i, () => {
                      a(l, n);
                    }))
                  : r._sendPacket(s);
                break;
              }
              case "suback": {
                delete r.outgoing[i], r.messageIdProvider.deallocate(i);
                let t = n.granted;
                for (let n = 0; n < t.length; n++) {
                  let o = t[n];
                  if (128 & o) {
                    (l = new Error(`Subscribe error: ${e.ReasonCodes[o]}`)),
                      (l.code = o);
                    let t = r.messageIdToTopic[i];
                    t &&
                      t.forEach((e) => {
                        delete r._resubscribeTopics[e];
                      });
                  }
                }
                delete r.messageIdToTopic[i],
                  r._invokeStoreProcessingQueue(),
                  a(l, n);
                break;
              }
              case "unsuback":
                delete r.outgoing[i],
                  r.messageIdProvider.deallocate(i),
                  r._invokeStoreProcessingQueue(),
                  a(null, n);
                break;
              default:
                r.emit("error", new Error("unrecognized packet type"));
            }
            r.disconnecting &&
              0 === Object.keys(r.outgoing).length &&
              r.emit("outgoingEmpty");
          } else r.log("_handleAck :: Server sent an ack in error. Ignoring.");
        });
    }),
    bd = dc((e) => {
      mc(), lh(), qu(), Object.defineProperty(e, "__esModule", { value: !0 });
      var t = vd(),
        r = yd();
      e.default = (e, n) => {
        let { options: i } = e,
          o = i.protocolVersion,
          s = 5 === o ? n.reasonCode : n.returnCode;
        if (5 !== o) {
          let r = new t.ErrorWithReasonCode(
            `Protocol error: Auth packets are only supported in MQTT 5. Your version:${o}`,
            s
          );
          return void e.emit("error", r);
        }
        e.handleAuth(n, (n, i) => {
          if (n) e.emit("error", n);
          else if (24 === s) (e.reconnecting = !1), e._sendPacket(i);
          else {
            let n = new t.ErrorWithReasonCode(
              `Connection refused: ${r.ReasonCodes[s]}`,
              s
            );
            e.emit("error", n);
          }
        });
      };
    }),
    xd = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "__esModule", { value: !0 }),
        (e.LRUCache = void 0);
      var t =
          "object" == typeof performance &&
          performance &&
          "function" == typeof performance.now
            ? performance
            : Date,
        r = new Set(),
        n = "object" == typeof gc && gc ? gc : {},
        i = (e, t, r, i) => {
          "function" == typeof n.emitWarning
            ? n.emitWarning(e, t, r, i)
            : console.error(`[${r}] ${t}: ${e}`);
        },
        o = globalThis.AbortController,
        s = globalThis.AbortSignal;
      if (typeof o > "u") {
        (s = class {
          onabort;
          _onabort = [];
          reason;
          aborted = !1;
          addEventListener(e, t) {
            this._onabort.push(t);
          }
        }),
          (o = class {
            constructor() {
              t();
            }
            signal = new s();
            abort(e) {
              if (!this.signal.aborted) {
                (this.signal.reason = e), (this.signal.aborted = !0);
                for (let t of this.signal._onabort) t(e);
                this.signal.onabort?.(e);
              }
            }
          });
        let e = "1" !== n.env?.LRU_CACHE_IGNORE_AC_WARNING,
          t = () => {
            e &&
              ((e = !1),
              i(
                "AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.",
                "NO_ABORT_CONTROLLER",
                "ENOTSUP",
                t
              ));
          };
      }
      Symbol("type");
      var a = (e) => e && e === Math.floor(e) && e > 0 && isFinite(e),
        l = (e) =>
          a(e)
            ? e <= Math.pow(2, 8)
              ? Uint8Array
              : e <= Math.pow(2, 16)
              ? Uint16Array
              : e <= Math.pow(2, 32)
              ? Uint32Array
              : e <= Number.MAX_SAFE_INTEGER
              ? c
              : null
            : null,
        c = class extends Array {
          constructor(e) {
            super(e), this.fill(0);
          }
        },
        u = class e {
          heap;
          length;
          static #e = !1;
          static create(t) {
            let r = l(t);
            if (!r) return [];
            e.#e = !0;
            let n = new e(t, r);
            return (e.#e = !1), n;
          }
          constructor(t, r) {
            if (!e.#e)
              throw new TypeError("instantiate Stack using Stack.create(n)");
            (this.heap = new r(t)), (this.length = 0);
          }
          push(e) {
            this.heap[this.length++] = e;
          }
          pop() {
            return this.heap[--this.length];
          }
        },
        h = class e {
          #e;
          #t;
          #r;
          #n;
          #i;
          #o;
          ttl;
          ttlResolution;
          ttlAutopurge;
          updateAgeOnGet;
          updateAgeOnHas;
          allowStale;
          noDisposeOnSet;
          noUpdateTTL;
          maxEntrySize;
          sizeCalculation;
          noDeleteOnFetchRejection;
          noDeleteOnStaleGet;
          allowStaleOnFetchAbort;
          allowStaleOnFetchRejection;
          ignoreFetchAbort;
          #s;
          #a;
          #l;
          #c;
          #u;
          #h;
          #d;
          #p;
          #f;
          #m;
          #g;
          #_;
          #v;
          #y;
          #b;
          #x;
          #w;
          static unsafeExposeInternals(e) {
            return {
              starts: e.#v,
              ttls: e.#y,
              sizes: e.#_,
              keyMap: e.#l,
              keyList: e.#c,
              valList: e.#u,
              next: e.#h,
              prev: e.#d,
              get head() {
                return e.#p;
              },
              get tail() {
                return e.#f;
              },
              free: e.#m,
              isBackgroundFetch: (t) => e.#S(t),
              backgroundFetch: (t, r, n, i) => e.#E(t, r, n, i),
              moveToTail: (t) => e.#M(t),
              indexes: (t) => e.#T(t),
              rindexes: (t) => e.#A(t),
              isStale: (t) => e.#R(t),
            };
          }
          get max() {
            return this.#e;
          }
          get maxSize() {
            return this.#t;
          }
          get calculatedSize() {
            return this.#a;
          }
          get size() {
            return this.#s;
          }
          get fetchMethod() {
            return this.#i;
          }
          get memoMethod() {
            return this.#o;
          }
          get dispose() {
            return this.#r;
          }
          get disposeAfter() {
            return this.#n;
          }
          constructor(t) {
            let {
              max: n = 0,
              ttl: o,
              ttlResolution: s = 1,
              ttlAutopurge: c,
              updateAgeOnGet: h,
              updateAgeOnHas: d,
              allowStale: p,
              dispose: f,
              disposeAfter: m,
              noDisposeOnSet: g,
              noUpdateTTL: _,
              maxSize: v = 0,
              maxEntrySize: y = 0,
              sizeCalculation: b,
              fetchMethod: x,
              memoMethod: w,
              noDeleteOnFetchRejection: S,
              noDeleteOnStaleGet: E,
              allowStaleOnFetchRejection: M,
              allowStaleOnFetchAbort: T,
              ignoreFetchAbort: A,
            } = t;
            if (0 !== n && !a(n))
              throw new TypeError("max option must be a nonnegative integer");
            let R = n ? l(n) : Array;
            if (!R) throw new Error("invalid max value: " + n);
            if (
              ((this.#e = n),
              (this.#t = v),
              (this.maxEntrySize = y || this.#t),
              (this.sizeCalculation = b),
              this.sizeCalculation)
            ) {
              if (!this.#t && !this.maxEntrySize)
                throw new TypeError(
                  "cannot set sizeCalculation without setting maxSize or maxEntrySize"
                );
              if ("function" != typeof this.sizeCalculation)
                throw new TypeError("sizeCalculation set to non-function");
            }
            if (void 0 !== w && "function" != typeof w)
              throw new TypeError("memoMethod must be a function if defined");
            if (((this.#o = w), void 0 !== x && "function" != typeof x))
              throw new TypeError(
                "fetchMethod must be a function if specified"
              );
            if (
              ((this.#i = x),
              (this.#x = !!x),
              (this.#l = new Map()),
              (this.#c = new Array(n).fill(void 0)),
              (this.#u = new Array(n).fill(void 0)),
              (this.#h = new R(n)),
              (this.#d = new R(n)),
              (this.#p = 0),
              (this.#f = 0),
              (this.#m = u.create(n)),
              (this.#s = 0),
              (this.#a = 0),
              "function" == typeof f && (this.#r = f),
              "function" == typeof m
                ? ((this.#n = m), (this.#g = []))
                : ((this.#n = void 0), (this.#g = void 0)),
              (this.#b = !!this.#r),
              (this.#w = !!this.#n),
              (this.noDisposeOnSet = !!g),
              (this.noUpdateTTL = !!_),
              (this.noDeleteOnFetchRejection = !!S),
              (this.allowStaleOnFetchRejection = !!M),
              (this.allowStaleOnFetchAbort = !!T),
              (this.ignoreFetchAbort = !!A),
              0 !== this.maxEntrySize)
            ) {
              if (0 !== this.#t && !a(this.#t))
                throw new TypeError(
                  "maxSize must be a positive integer if specified"
                );
              if (!a(this.maxEntrySize))
                throw new TypeError(
                  "maxEntrySize must be a positive integer if specified"
                );
              this.#P();
            }
            if (
              ((this.allowStale = !!p),
              (this.noDeleteOnStaleGet = !!E),
              (this.updateAgeOnGet = !!h),
              (this.updateAgeOnHas = !!d),
              (this.ttlResolution = a(s) || 0 === s ? s : 1),
              (this.ttlAutopurge = !!c),
              (this.ttl = o || 0),
              this.ttl)
            ) {
              if (!a(this.ttl))
                throw new TypeError(
                  "ttl must be a positive integer if specified"
                );
              this.#C();
            }
            if (0 === this.#e && 0 === this.ttl && 0 === this.#t)
              throw new TypeError(
                "At least one of max, maxSize, or ttl is required"
              );
            if (!this.ttlAutopurge && !this.#e && !this.#t) {
              let t = "LRU_CACHE_UNBOUNDED";
              ((e) => !r.has(e))(t) &&
                (r.add(t),
                i(
                  "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.",
                  "UnboundedCacheWarning",
                  t,
                  e
                ));
            }
          }
          getRemainingTTL(e) {
            return this.#l.has(e) ? 1 / 0 : 0;
          }
          #C() {
            let e = new c(this.#e),
              r = new c(this.#e);
            (this.#y = e),
              (this.#v = r),
              (this.#I = (n, i, o = t.now()) => {
                if (
                  ((r[n] = 0 !== i ? o : 0),
                  (e[n] = i),
                  0 !== i && this.ttlAutopurge)
                ) {
                  let e = setTimeout(() => {
                    this.#R(n) && this.#L(this.#c[n], "expire");
                  }, i + 1);
                  e.unref && e.unref();
                }
              }),
              (this.#O = (n) => {
                r[n] = 0 !== e[n] ? t.now() : 0;
              }),
              (this.#N = (t, o) => {
                if (e[o]) {
                  let s = e[o],
                    a = r[o];
                  if (!s || !a) return;
                  (t.ttl = s), (t.start = a), (t.now = n || i());
                  let l = t.now - a;
                  t.remainingTTL = s - l;
                }
              });
            let n = 0,
              i = () => {
                let e = t.now();
                if (this.ttlResolution > 0) {
                  n = e;
                  let t = setTimeout(() => (n = 0), this.ttlResolution);
                  t.unref && t.unref();
                }
                return e;
              };
            (this.getRemainingTTL = (t) => {
              let o = this.#l.get(t);
              if (void 0 === o) return 0;
              let s = e[o],
                a = r[o];
              return s && a ? s - ((n || i()) - a) : 1 / 0;
            }),
              (this.#R = (t) => {
                let o = r[t],
                  s = e[t];
                return !!s && !!o && (n || i()) - o > s;
              });
          }
          #O = () => {};
          #N = () => {};
          #I = () => {};
          #R = () => !1;
          #P() {
            let e = new c(this.#e);
            (this.#a = 0),
              (this.#_ = e),
              (this.#U = (t) => {
                (this.#a -= e[t]), (e[t] = 0);
              }),
              (this.#D = (e, t, r, n) => {
                if (this.#S(t)) return 0;
                if (!a(r)) {
                  if (!n)
                    throw new TypeError(
                      "invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set."
                    );
                  if ("function" != typeof n)
                    throw new TypeError("sizeCalculation must be a function");
                  if (((r = n(t, e)), !a(r)))
                    throw new TypeError(
                      "sizeCalculation return invalid (expect positive integer)"
                    );
                }
                return r;
              }),
              (this.#k = (t, r, n) => {
                if (((e[t] = r), this.#t)) {
                  let r = this.#t - e[t];
                  for (; this.#a > r; ) this.#B(!0);
                }
                (this.#a += e[t]),
                  n && ((n.entrySize = r), (n.totalCalculatedSize = this.#a));
              });
          }
          #U = (e) => {};
          #k = (e, t, r) => {};
          #D = (e, t, r, n) => {
            if (r || n)
              throw new TypeError(
                "cannot set size without setting maxSize or maxEntrySize on cache"
              );
            return 0;
          };
          *#T({ allowStale: e = this.allowStale } = {}) {
            if (this.#s)
              for (
                let t = this.#f;
                this.#F(t) && ((e || !this.#R(t)) && (yield t), t !== this.#p);

              )
                t = this.#d[t];
          }
          *#A({ allowStale: e = this.allowStale } = {}) {
            if (this.#s)
              for (
                let t = this.#p;
                this.#F(t) && ((e || !this.#R(t)) && (yield t), t !== this.#f);

              )
                t = this.#h[t];
          }
          #F(e) {
            return void 0 !== e && this.#l.get(this.#c[e]) === e;
          }
          *entries() {
            for (let e of this.#T())
              void 0 !== this.#u[e] &&
                void 0 !== this.#c[e] &&
                !this.#S(this.#u[e]) &&
                (yield [this.#c[e], this.#u[e]]);
          }
          *rentries() {
            for (let e of this.#A())
              void 0 !== this.#u[e] &&
                void 0 !== this.#c[e] &&
                !this.#S(this.#u[e]) &&
                (yield [this.#c[e], this.#u[e]]);
          }
          *keys() {
            for (let e of this.#T()) {
              let t = this.#c[e];
              void 0 !== t && !this.#S(this.#u[e]) && (yield t);
            }
          }
          *rkeys() {
            for (let e of this.#A()) {
              let t = this.#c[e];
              void 0 !== t && !this.#S(this.#u[e]) && (yield t);
            }
          }
          *values() {
            for (let e of this.#T())
              void 0 !== this.#u[e] &&
                !this.#S(this.#u[e]) &&
                (yield this.#u[e]);
          }
          *rvalues() {
            for (let e of this.#A())
              void 0 !== this.#u[e] &&
                !this.#S(this.#u[e]) &&
                (yield this.#u[e]);
          }
          [Symbol.iterator]() {
            return this.entries();
          }
          [Symbol.toStringTag] = "LRUCache";
          find(e, t = {}) {
            for (let r of this.#T()) {
              let n = this.#u[r],
                i = this.#S(n) ? n.__staleWhileFetching : n;
              if (void 0 !== i && e(i, this.#c[r], this))
                return this.get(this.#c[r], t);
            }
          }
          forEach(e, t = this) {
            for (let r of this.#T()) {
              let n = this.#u[r],
                i = this.#S(n) ? n.__staleWhileFetching : n;
              void 0 !== i && e.call(t, i, this.#c[r], this);
            }
          }
          rforEach(e, t = this) {
            for (let r of this.#A()) {
              let n = this.#u[r],
                i = this.#S(n) ? n.__staleWhileFetching : n;
              void 0 !== i && e.call(t, i, this.#c[r], this);
            }
          }
          purgeStale() {
            let e = !1;
            for (let t of this.#A({ allowStale: !0 }))
              this.#R(t) && (this.#L(this.#c[t], "expire"), (e = !0));
            return e;
          }
          info(e) {
            let r = this.#l.get(e);
            if (void 0 === r) return;
            let n = this.#u[r],
              i = this.#S(n) ? n.__staleWhileFetching : n;
            if (void 0 === i) return;
            let o = { value: i };
            if (this.#y && this.#v) {
              let e = this.#y[r],
                n = this.#v[r];
              if (e && n) {
                let r = e - (t.now() - n);
                (o.ttl = r), (o.start = Date.now());
              }
            }
            return this.#_ && (o.size = this.#_[r]), o;
          }
          dump() {
            let e = [];
            for (let r of this.#T({ allowStale: !0 })) {
              let n = this.#c[r],
                i = this.#u[r],
                o = this.#S(i) ? i.__staleWhileFetching : i;
              if (void 0 === o || void 0 === n) continue;
              let s = { value: o };
              if (this.#y && this.#v) {
                s.ttl = this.#y[r];
                let e = t.now() - this.#v[r];
                s.start = Math.floor(Date.now() - e);
              }
              this.#_ && (s.size = this.#_[r]), e.unshift([n, s]);
            }
            return e;
          }
          load(e) {
            this.clear();
            for (let [r, n] of e) {
              if (n.start) {
                let e = Date.now() - n.start;
                n.start = t.now() - e;
              }
              this.set(r, n.value, n);
            }
          }
          set(e, t, r = {}) {
            if (void 0 === t) return this.delete(e), this;
            let {
                ttl: n = this.ttl,
                start: i,
                noDisposeOnSet: o = this.noDisposeOnSet,
                sizeCalculation: s = this.sizeCalculation,
                status: a,
              } = r,
              { noUpdateTTL: l = this.noUpdateTTL } = r,
              c = this.#D(e, t, r.size || 0, s);
            if (this.maxEntrySize && c > this.maxEntrySize)
              return (
                a && ((a.set = "miss"), (a.maxEntrySizeExceeded = !0)),
                this.#L(e, "set"),
                this
              );
            let u = 0 === this.#s ? void 0 : this.#l.get(e);
            if (void 0 === u)
              (u =
                0 === this.#s
                  ? this.#f
                  : 0 !== this.#m.length
                  ? this.#m.pop()
                  : this.#s === this.#e
                  ? this.#B(!1)
                  : this.#s),
                (this.#c[u] = e),
                (this.#u[u] = t),
                this.#l.set(e, u),
                (this.#h[this.#f] = u),
                (this.#d[u] = this.#f),
                (this.#f = u),
                this.#s++,
                this.#k(u, c, a),
                a && (a.set = "add"),
                (l = !1);
            else {
              this.#M(u);
              let r = this.#u[u];
              if (t !== r) {
                if (this.#x && this.#S(r)) {
                  r.__abortController.abort(new Error("replaced"));
                  let { __staleWhileFetching: t } = r;
                  void 0 !== t &&
                    !o &&
                    (this.#b && this.#r?.(t, e, "set"),
                    this.#w && this.#g?.push([t, e, "set"]));
                } else
                  o ||
                    (this.#b && this.#r?.(r, e, "set"),
                    this.#w && this.#g?.push([r, e, "set"]));
                if ((this.#U(u), this.#k(u, c, a), (this.#u[u] = t), a)) {
                  a.set = "replace";
                  let e = r && this.#S(r) ? r.__staleWhileFetching : r;
                  void 0 !== e && (a.oldValue = e);
                }
              } else a && (a.set = "update");
            }
            if (
              (0 !== n && !this.#y && this.#C(),
              this.#y && (l || this.#I(u, n, i), a && this.#N(a, u)),
              !o && this.#w && this.#g)
            ) {
              let e,
                t = this.#g;
              for (; (e = t?.shift()); ) this.#n?.(...e);
            }
            return this;
          }
          pop() {
            try {
              for (; this.#s; ) {
                let e = this.#u[this.#p];
                if ((this.#B(!0), this.#S(e))) {
                  if (e.__staleWhileFetching) return e.__staleWhileFetching;
                } else if (void 0 !== e) return e;
              }
            } finally {
              if (this.#w && this.#g) {
                let e,
                  t = this.#g;
                for (; (e = t?.shift()); ) this.#n?.(...e);
              }
            }
          }
          #B(e) {
            let t = this.#p,
              r = this.#c[t],
              n = this.#u[t];
            return (
              this.#x && this.#S(n)
                ? n.__abortController.abort(new Error("evicted"))
                : (this.#b || this.#w) &&
                  (this.#b && this.#r?.(n, r, "evict"),
                  this.#w && this.#g?.push([n, r, "evict"])),
              this.#U(t),
              e &&
                ((this.#c[t] = void 0), (this.#u[t] = void 0), this.#m.push(t)),
              1 === this.#s
                ? ((this.#p = this.#f = 0), (this.#m.length = 0))
                : (this.#p = this.#h[t]),
              this.#l.delete(r),
              this.#s--,
              t
            );
          }
          has(e, t = {}) {
            let { updateAgeOnHas: r = this.updateAgeOnHas, status: n } = t,
              i = this.#l.get(e);
            if (void 0 !== i) {
              let e = this.#u[i];
              if (this.#S(e) && void 0 === e.__staleWhileFetching) return !1;
              if (!this.#R(i))
                return (
                  r && this.#O(i), n && ((n.has = "hit"), this.#N(n, i)), !0
                );
              n && ((n.has = "stale"), this.#N(n, i));
            } else n && (n.has = "miss");
            return !1;
          }
          peek(e, t = {}) {
            let { allowStale: r = this.allowStale } = t,
              n = this.#l.get(e);
            if (void 0 === n || (!r && this.#R(n))) return;
            let i = this.#u[n];
            return this.#S(i) ? i.__staleWhileFetching : i;
          }
          #E(e, t, r, n) {
            let i = void 0 === t ? void 0 : this.#u[t];
            if (this.#S(i)) return i;
            let s = new o(),
              { signal: a } = r;
            a?.addEventListener("abort", () => s.abort(a.reason), {
              signal: s.signal,
            });
            let l = { signal: s.signal, options: r, context: n },
              c = (n, i = !1) => {
                let { aborted: o } = s.signal,
                  a = r.ignoreFetchAbort && void 0 !== n;
                if (
                  (r.status &&
                    (o && !i
                      ? ((r.status.fetchAborted = !0),
                        (r.status.fetchError = s.signal.reason),
                        a && (r.status.fetchAbortIgnored = !0))
                      : (r.status.fetchResolved = !0)),
                  o && !a && !i)
                )
                  return u(s.signal.reason);
                let c = h;
                return (
                  this.#u[t] === h &&
                    (void 0 === n
                      ? c.__staleWhileFetching
                        ? (this.#u[t] = c.__staleWhileFetching)
                        : this.#L(e, "fetch")
                      : (r.status && (r.status.fetchUpdated = !0),
                        this.set(e, n, l.options))),
                  n
                );
              },
              u = (n) => {
                let { aborted: i } = s.signal,
                  o = i && r.allowStaleOnFetchAbort,
                  a = o || r.allowStaleOnFetchRejection,
                  l = a || r.noDeleteOnFetchRejection,
                  c = h;
                if (
                  (this.#u[t] === h &&
                    (l && void 0 !== c.__staleWhileFetching
                      ? o || (this.#u[t] = c.__staleWhileFetching)
                      : this.#L(e, "fetch")),
                  a)
                )
                  return (
                    r.status &&
                      void 0 !== c.__staleWhileFetching &&
                      (r.status.returnedStale = !0),
                    c.__staleWhileFetching
                  );
                if (c.__returned === c) throw n;
              };
            r.status && (r.status.fetchDispatched = !0);
            let h = new Promise((t, n) => {
                let o = this.#i?.(e, i, l);
                o &&
                  o instanceof Promise &&
                  o.then((e) => t(void 0 === e ? void 0 : e), n),
                  s.signal.addEventListener("abort", () => {
                    (!r.ignoreFetchAbort || r.allowStaleOnFetchAbort) &&
                      (t(void 0),
                      r.allowStaleOnFetchAbort && (t = (e) => c(e, !0)));
                  });
              }).then(
                c,
                (e) => (
                  r.status &&
                    ((r.status.fetchRejected = !0), (r.status.fetchError = e)),
                  u(e)
                )
              ),
              d = Object.assign(h, {
                __abortController: s,
                __staleWhileFetching: i,
                __returned: void 0,
              });
            return (
              void 0 === t
                ? (this.set(e, d, { ...l.options, status: void 0 }),
                  (t = this.#l.get(e)))
                : (this.#u[t] = d),
              d
            );
          }
          #S(e) {
            if (!this.#x) return !1;
            let t = e;
            return (
              !!t &&
              t instanceof Promise &&
              t.hasOwnProperty("__staleWhileFetching") &&
              t.__abortController instanceof o
            );
          }
          async fetch(e, t = {}) {
            let {
              allowStale: r = this.allowStale,
              updateAgeOnGet: n = this.updateAgeOnGet,
              noDeleteOnStaleGet: i = this.noDeleteOnStaleGet,
              ttl: o = this.ttl,
              noDisposeOnSet: s = this.noDisposeOnSet,
              size: a = 0,
              sizeCalculation: l = this.sizeCalculation,
              noUpdateTTL: c = this.noUpdateTTL,
              noDeleteOnFetchRejection: u = this.noDeleteOnFetchRejection,
              allowStaleOnFetchRejection: h = this.allowStaleOnFetchRejection,
              ignoreFetchAbort: d = this.ignoreFetchAbort,
              allowStaleOnFetchAbort: p = this.allowStaleOnFetchAbort,
              context: f,
              forceRefresh: m = !1,
              status: g,
              signal: _,
            } = t;
            if (!this.#x)
              return (
                g && (g.fetch = "get"),
                this.get(e, {
                  allowStale: r,
                  updateAgeOnGet: n,
                  noDeleteOnStaleGet: i,
                  status: g,
                })
              );
            let v = {
                allowStale: r,
                updateAgeOnGet: n,
                noDeleteOnStaleGet: i,
                ttl: o,
                noDisposeOnSet: s,
                size: a,
                sizeCalculation: l,
                noUpdateTTL: c,
                noDeleteOnFetchRejection: u,
                allowStaleOnFetchRejection: h,
                allowStaleOnFetchAbort: p,
                ignoreFetchAbort: d,
                status: g,
                signal: _,
              },
              y = this.#l.get(e);
            if (void 0 === y) {
              g && (g.fetch = "miss");
              let t = this.#E(e, y, v, f);
              return (t.__returned = t);
            }
            {
              let t = this.#u[y];
              if (this.#S(t)) {
                let e = r && void 0 !== t.__staleWhileFetching;
                return (
                  g && ((g.fetch = "inflight"), e && (g.returnedStale = !0)),
                  e ? t.__staleWhileFetching : (t.__returned = t)
                );
              }
              let i = this.#R(y);
              if (!m && !i)
                return (
                  g && (g.fetch = "hit"),
                  this.#M(y),
                  n && this.#O(y),
                  g && this.#N(g, y),
                  t
                );
              let o = this.#E(e, y, v, f),
                s = void 0 !== o.__staleWhileFetching && r;
              return (
                g &&
                  ((g.fetch = i ? "stale" : "refresh"),
                  s && i && (g.returnedStale = !0)),
                s ? o.__staleWhileFetching : (o.__returned = o)
              );
            }
          }
          async forceFetch(e, t = {}) {
            let r = await this.fetch(e, t);
            if (void 0 === r) throw new Error("fetch() returned undefined");
            return r;
          }
          memo(e, t = {}) {
            let r = this.#o;
            if (!r) throw new Error("no memoMethod provided to constructor");
            let { context: n, forceRefresh: i, ...o } = t,
              s = this.get(e, o);
            if (!i && void 0 !== s) return s;
            let a = r(e, s, { options: o, context: n });
            return this.set(e, a, o), a;
          }
          get(e, t = {}) {
            let {
                allowStale: r = this.allowStale,
                updateAgeOnGet: n = this.updateAgeOnGet,
                noDeleteOnStaleGet: i = this.noDeleteOnStaleGet,
                status: o,
              } = t,
              s = this.#l.get(e);
            if (void 0 !== s) {
              let t = this.#u[s],
                a = this.#S(t);
              return (
                o && this.#N(o, s),
                this.#R(s)
                  ? (o && (o.get = "stale"),
                    a
                      ? (o &&
                          r &&
                          void 0 !== t.__staleWhileFetching &&
                          (o.returnedStale = !0),
                        r ? t.__staleWhileFetching : void 0)
                      : (i || this.#L(e, "expire"),
                        o && r && (o.returnedStale = !0),
                        r ? t : void 0))
                  : (o && (o.get = "hit"),
                    a
                      ? t.__staleWhileFetching
                      : (this.#M(s), n && this.#O(s), t))
              );
            }
            o && (o.get = "miss");
          }
          #H(e, t) {
            (this.#d[t] = e), (this.#h[e] = t);
          }
          #M(e) {
            e !== this.#f &&
              (e === this.#p
                ? (this.#p = this.#h[e])
                : this.#H(this.#d[e], this.#h[e]),
              this.#H(this.#f, e),
              (this.#f = e));
          }
          delete(e) {
            return this.#L(e, "delete");
          }
          #L(e, t) {
            let r = !1;
            if (0 !== this.#s) {
              let n = this.#l.get(e);
              if (void 0 !== n)
                if (((r = !0), 1 === this.#s)) this.#z(t);
                else {
                  this.#U(n);
                  let r = this.#u[n];
                  if (
                    (this.#S(r)
                      ? r.__abortController.abort(new Error("deleted"))
                      : (this.#b || this.#w) &&
                        (this.#b && this.#r?.(r, e, t),
                        this.#w && this.#g?.push([r, e, t])),
                    this.#l.delete(e),
                    (this.#c[n] = void 0),
                    (this.#u[n] = void 0),
                    n === this.#f)
                  )
                    this.#f = this.#d[n];
                  else if (n === this.#p) this.#p = this.#h[n];
                  else {
                    let e = this.#d[n];
                    this.#h[e] = this.#h[n];
                    let t = this.#h[n];
                    this.#d[t] = this.#d[n];
                  }
                  this.#s--, this.#m.push(n);
                }
            }
            if (this.#w && this.#g?.length) {
              let e,
                t = this.#g;
              for (; (e = t?.shift()); ) this.#n?.(...e);
            }
            return r;
          }
          clear() {
            return this.#z("delete");
          }
          #z(e) {
            for (let t of this.#A({ allowStale: !0 })) {
              let r = this.#u[t];
              if (this.#S(r)) r.__abortController.abort(new Error("deleted"));
              else {
                let n = this.#c[t];
                this.#b && this.#r?.(r, n, e),
                  this.#w && this.#g?.push([r, n, e]);
              }
            }
            if (
              (this.#l.clear(),
              this.#u.fill(void 0),
              this.#c.fill(void 0),
              this.#y && this.#v && (this.#y.fill(0), this.#v.fill(0)),
              this.#_ && this.#_.fill(0),
              (this.#p = 0),
              (this.#f = 0),
              (this.#m.length = 0),
              (this.#a = 0),
              (this.#s = 0),
              this.#w && this.#g)
            ) {
              let e,
                t = this.#g;
              for (; (e = t?.shift()); ) this.#n?.(...e);
            }
          }
        };
      e.LRUCache = h;
    }),
    wd = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "t", { value: !0 }),
        (e.ContainerIterator = e.Container = e.Base = void 0),
        (e.ContainerIterator = class {
          constructor(e = 0) {
            this.iteratorType = e;
          }
          equals(e) {
            return this.o === e.o;
          }
        });
      var t = class {
        constructor() {
          this.i = 0;
        }
        get length() {
          return this.i;
        }
        size() {
          return this.i;
        }
        empty() {
          return 0 === this.i;
        }
      };
      (e.Base = t), (e.Container = class extends t {});
    }),
    Sd = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "t", { value: !0 }),
        (e.default = void 0);
      var t = wd(),
        r = class extends t.Base {
          constructor(e = []) {
            super(), (this.S = []);
            let t = this;
            e.forEach(function (e) {
              t.push(e);
            });
          }
          clear() {
            (this.i = 0), (this.S = []);
          }
          push(e) {
            return this.S.push(e), (this.i += 1), this.i;
          }
          pop() {
            if (0 !== this.i) return (this.i -= 1), this.S.pop();
          }
          top() {
            return this.S[this.i - 1];
          }
        };
      e.default = r;
    }),
    Ed = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "t", { value: !0 }),
        (e.default = void 0);
      var t = wd(),
        r = class extends t.Base {
          constructor(e = []) {
            super(), (this.j = 0), (this.q = []);
            let t = this;
            e.forEach(function (e) {
              t.push(e);
            });
          }
          clear() {
            (this.q = []), (this.i = this.j = 0);
          }
          push(e) {
            let t = this.q.length;
            if (this.j / t > 0.5 && this.j + this.i >= t && t > 4096) {
              let t = this.i;
              for (let e = 0; e < t; ++e) this.q[e] = this.q[this.j + e];
              (this.j = 0), (this.q[this.i] = e);
            } else this.q[this.j + this.i] = e;
            return ++this.i;
          }
          pop() {
            if (0 === this.i) return;
            let e = this.q[this.j++];
            return (this.i -= 1), e;
          }
          front() {
            if (0 !== this.i) return this.q[this.j];
          }
        };
      e.default = r;
    }),
    Md = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "t", { value: !0 }),
        (e.default = void 0);
      var t = wd(),
        r = class extends t.Base {
          constructor(
            e = [],
            t = function (e, t) {
              return e > t ? -1 : e < t ? 1 : 0;
            },
            r = !0
          ) {
            if ((super(), (this.v = t), Array.isArray(e)))
              this.C = r ? [...e] : e;
            else {
              this.C = [];
              let t = this;
              e.forEach(function (e) {
                t.C.push(e);
              });
            }
            this.i = this.C.length;
            let n = this.i >> 1;
            for (let e = (this.i - 1) >> 1; e >= 0; --e) this.k(e, n);
          }
          m(e) {
            let t = this.C[e];
            for (; e > 0; ) {
              let r = (e - 1) >> 1,
                n = this.C[r];
              if (this.v(n, t) <= 0) break;
              (this.C[e] = n), (e = r);
            }
            this.C[e] = t;
          }
          k(e, t) {
            let r = this.C[e];
            for (; e < t; ) {
              let t = (e << 1) | 1,
                n = t + 1,
                i = this.C[t];
              if (
                (n < this.i &&
                  this.v(i, this.C[n]) > 0 &&
                  ((t = n), (i = this.C[n])),
                this.v(i, r) >= 0)
              )
                break;
              (this.C[e] = i), (e = t);
            }
            this.C[e] = r;
          }
          clear() {
            (this.i = 0), (this.C.length = 0);
          }
          push(e) {
            this.C.push(e), this.m(this.i), (this.i += 1);
          }
          pop() {
            if (0 === this.i) return;
            let e = this.C[0],
              t = this.C.pop();
            return (
              (this.i -= 1),
              this.i && ((this.C[0] = t), this.k(0, this.i >> 1)),
              e
            );
          }
          top() {
            return this.C[0];
          }
          find(e) {
            return this.C.indexOf(e) >= 0;
          }
          remove(e) {
            let t = this.C.indexOf(e);
            return !(
              t < 0 ||
              (0 === t
                ? this.pop()
                : t === this.i - 1
                ? (this.C.pop(), (this.i -= 1))
                : (this.C.splice(t, 1, this.C.pop()),
                  (this.i -= 1),
                  this.m(t),
                  this.k(t, this.i >> 1)),
              0)
            );
          }
          updateItem(e) {
            let t = this.C.indexOf(e);
            return !(t < 0 || (this.m(t), this.k(t, this.i >> 1), 0));
          }
          toArray() {
            return [...this.C];
          }
        };
      e.default = r;
    }),
    Td = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "t", { value: !0 }),
        (e.default = void 0);
      var t = wd(),
        r = class extends t.Container {};
      e.default = r;
    }),
    Ad = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "t", { value: !0 }),
        (e.throwIteratorAccessError = function () {
          throw new RangeError("Iterator access denied!");
        });
    }),
    Rd = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "t", { value: !0 }),
        (e.RandomIterator = void 0);
      var t = wd(),
        r = Ad(),
        n = class extends t.ContainerIterator {
          constructor(e, t) {
            super(t),
              (this.o = e),
              0 === this.iteratorType
                ? ((this.pre = function () {
                    return (
                      0 === this.o && (0, r.throwIteratorAccessError)(),
                      (this.o -= 1),
                      this
                    );
                  }),
                  (this.next = function () {
                    return (
                      this.o === this.container.size() &&
                        (0, r.throwIteratorAccessError)(),
                      (this.o += 1),
                      this
                    );
                  }))
                : ((this.pre = function () {
                    return (
                      this.o === this.container.size() - 1 &&
                        (0, r.throwIteratorAccessError)(),
                      (this.o += 1),
                      this
                    );
                  }),
                  (this.next = function () {
                    return (
                      -1 === this.o && (0, r.throwIteratorAccessError)(),
                      (this.o -= 1),
                      this
                    );
                  }));
          }
          get pointer() {
            return this.container.getElementByPos(this.o);
          }
          set pointer(e) {
            this.container.setElementByPos(this.o, e);
          }
        };
      e.RandomIterator = n;
    }),
    Pd = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "t", { value: !0 }),
        (e.default = void 0);
      var t,
        r = (t = Td()) && t.t ? t : { default: t },
        n = Rd(),
        i = class e extends n.RandomIterator {
          constructor(e, t, r) {
            super(e, r), (this.container = t);
          }
          copy() {
            return new e(this.o, this.container, this.iteratorType);
          }
        },
        o = class extends r.default {
          constructor(e = [], t = !0) {
            if ((super(), Array.isArray(e)))
              (this.J = t ? [...e] : e), (this.i = e.length);
            else {
              this.J = [];
              let t = this;
              e.forEach(function (e) {
                t.pushBack(e);
              });
            }
          }
          clear() {
            (this.i = 0), (this.J.length = 0);
          }
          begin() {
            return new i(0, this);
          }
          end() {
            return new i(this.i, this);
          }
          rBegin() {
            return new i(this.i - 1, this, 1);
          }
          rEnd() {
            return new i(-1, this, 1);
          }
          front() {
            return this.J[0];
          }
          back() {
            return this.J[this.i - 1];
          }
          getElementByPos(e) {
            if (e < 0 || e > this.i - 1) throw new RangeError();
            return this.J[e];
          }
          eraseElementByPos(e) {
            if (e < 0 || e > this.i - 1) throw new RangeError();
            return this.J.splice(e, 1), (this.i -= 1), this.i;
          }
          eraseElementByValue(e) {
            let t = 0;
            for (let r = 0; r < this.i; ++r)
              this.J[r] !== e && (this.J[t++] = this.J[r]);
            return (this.i = this.J.length = t), this.i;
          }
          eraseElementByIterator(e) {
            let t = e.o;
            return (e = e.next()), this.eraseElementByPos(t), e;
          }
          pushBack(e) {
            return this.J.push(e), (this.i += 1), this.i;
          }
          popBack() {
            if (0 !== this.i) return (this.i -= 1), this.J.pop();
          }
          setElementByPos(e, t) {
            if (e < 0 || e > this.i - 1) throw new RangeError();
            this.J[e] = t;
          }
          insert(e, t, r = 1) {
            if (e < 0 || e > this.i) throw new RangeError();
            return (
              this.J.splice(e, 0, ...new Array(r).fill(t)),
              (this.i += r),
              this.i
            );
          }
          find(e) {
            for (let t = 0; t < this.i; ++t)
              if (this.J[t] === e) return new i(t, this);
            return this.end();
          }
          reverse() {
            this.J.reverse();
          }
          unique() {
            let e = 1;
            for (let t = 1; t < this.i; ++t)
              this.J[t] !== this.J[t - 1] && (this.J[e++] = this.J[t]);
            return (this.i = this.J.length = e), this.i;
          }
          sort(e) {
            this.J.sort(e);
          }
          forEach(e) {
            for (let t = 0; t < this.i; ++t) e(this.J[t], t, this);
          }
          [Symbol.iterator]() {
            return function* () {
              yield* this.J;
            }.bind(this)();
          }
        };
      e.default = o;
    }),
    Cd = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "t", { value: !0 }),
        (e.default = void 0);
      var t,
        r = (t = Td()) && t.t ? t : { default: t },
        n = wd(),
        i = Ad(),
        o = class e extends n.ContainerIterator {
          constructor(e, t, r, n) {
            super(n),
              (this.o = e),
              (this.h = t),
              (this.container = r),
              0 === this.iteratorType
                ? ((this.pre = function () {
                    return (
                      this.o.L === this.h && (0, i.throwIteratorAccessError)(),
                      (this.o = this.o.L),
                      this
                    );
                  }),
                  (this.next = function () {
                    return (
                      this.o === this.h && (0, i.throwIteratorAccessError)(),
                      (this.o = this.o.B),
                      this
                    );
                  }))
                : ((this.pre = function () {
                    return (
                      this.o.B === this.h && (0, i.throwIteratorAccessError)(),
                      (this.o = this.o.B),
                      this
                    );
                  }),
                  (this.next = function () {
                    return (
                      this.o === this.h && (0, i.throwIteratorAccessError)(),
                      (this.o = this.o.L),
                      this
                    );
                  }));
          }
          get pointer() {
            return (
              this.o === this.h && (0, i.throwIteratorAccessError)(), this.o.l
            );
          }
          set pointer(e) {
            this.o === this.h && (0, i.throwIteratorAccessError)(),
              (this.o.l = e);
          }
          copy() {
            return new e(this.o, this.h, this.container, this.iteratorType);
          }
        },
        s = class extends r.default {
          constructor(e = []) {
            super(),
              (this.h = {}),
              (this.p = this._ = this.h.L = this.h.B = this.h);
            let t = this;
            e.forEach(function (e) {
              t.pushBack(e);
            });
          }
          V(e) {
            let { L: t, B: r } = e;
            (t.B = r),
              (r.L = t),
              e === this.p && (this.p = r),
              e === this._ && (this._ = t),
              (this.i -= 1);
          }
          G(e, t) {
            let r = t.B,
              n = { l: e, L: t, B: r };
            (t.B = n),
              (r.L = n),
              t === this.h && (this.p = n),
              r === this.h && (this._ = n),
              (this.i += 1);
          }
          clear() {
            (this.i = 0), (this.p = this._ = this.h.L = this.h.B = this.h);
          }
          begin() {
            return new o(this.p, this.h, this);
          }
          end() {
            return new o(this.h, this.h, this);
          }
          rBegin() {
            return new o(this._, this.h, this, 1);
          }
          rEnd() {
            return new o(this.h, this.h, this, 1);
          }
          front() {
            return this.p.l;
          }
          back() {
            return this._.l;
          }
          getElementByPos(e) {
            if (e < 0 || e > this.i - 1) throw new RangeError();
            let t = this.p;
            for (; e--; ) t = t.B;
            return t.l;
          }
          eraseElementByPos(e) {
            if (e < 0 || e > this.i - 1) throw new RangeError();
            let t = this.p;
            for (; e--; ) t = t.B;
            return this.V(t), this.i;
          }
          eraseElementByValue(e) {
            let t = this.p;
            for (; t !== this.h; ) t.l === e && this.V(t), (t = t.B);
            return this.i;
          }
          eraseElementByIterator(e) {
            let t = e.o;
            return (
              t === this.h && (0, i.throwIteratorAccessError)(),
              (e = e.next()),
              this.V(t),
              e
            );
          }
          pushBack(e) {
            return this.G(e, this._), this.i;
          }
          popBack() {
            if (0 === this.i) return;
            let e = this._.l;
            return this.V(this._), e;
          }
          pushFront(e) {
            return this.G(e, this.h), this.i;
          }
          popFront() {
            if (0 === this.i) return;
            let e = this.p.l;
            return this.V(this.p), e;
          }
          setElementByPos(e, t) {
            if (e < 0 || e > this.i - 1) throw new RangeError();
            let r = this.p;
            for (; e--; ) r = r.B;
            r.l = t;
          }
          insert(e, t, r = 1) {
            if (e < 0 || e > this.i) throw new RangeError();
            if (r <= 0) return this.i;
            if (0 === e) for (; r--; ) this.pushFront(t);
            else if (e === this.i) for (; r--; ) this.pushBack(t);
            else {
              let n = this.p;
              for (let t = 1; t < e; ++t) n = n.B;
              let i = n.B;
              for (this.i += r; r--; )
                (n.B = { l: t, L: n }), (n.B.L = n), (n = n.B);
              (n.B = i), (i.L = n);
            }
            return this.i;
          }
          find(e) {
            let t = this.p;
            for (; t !== this.h; ) {
              if (t.l === e) return new o(t, this.h, this);
              t = t.B;
            }
            return this.end();
          }
          reverse() {
            if (this.i <= 1) return;
            let e = this.p,
              t = this._,
              r = 0;
            for (; r << 1 < this.i; ) {
              let n = e.l;
              (e.l = t.l), (t.l = n), (e = e.B), (t = t.L), (r += 1);
            }
          }
          unique() {
            if (this.i <= 1) return this.i;
            let e = this.p;
            for (; e !== this.h; ) {
              let t = e;
              for (; t.B !== this.h && t.l === t.B.l; )
                (t = t.B), (this.i -= 1);
              (e.B = t.B), (e.B.L = e), (e = e.B);
            }
            return this.i;
          }
          sort(e) {
            if (this.i <= 1) return;
            let t = [];
            this.forEach(function (e) {
              t.push(e);
            }),
              t.sort(e);
            let r = this.p;
            t.forEach(function (e) {
              (r.l = e), (r = r.B);
            });
          }
          merge(e) {
            let t = this;
            if (0 === this.i)
              e.forEach(function (e) {
                t.pushBack(e);
              });
            else {
              let r = this.p;
              e.forEach(function (e) {
                for (; r !== t.h && r.l <= e; ) r = r.B;
                t.G(e, r.L);
              });
            }
            return this.i;
          }
          forEach(e) {
            let t = this.p,
              r = 0;
            for (; t !== this.h; ) e(t.l, r++, this), (t = t.B);
          }
          [Symbol.iterator]() {
            return function* () {
              if (0 === this.i) return;
              let e = this.p;
              for (; e !== this.h; ) yield e.l, (e = e.B);
            }.bind(this)();
          }
        };
      e.default = s;
    }),
    Id = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "t", { value: !0 }),
        (e.default = void 0);
      var t,
        r = (t = Td()) && t.t ? t : { default: t },
        n = Rd(),
        i = class e extends n.RandomIterator {
          constructor(e, t, r) {
            super(e, r), (this.container = t);
          }
          copy() {
            return new e(this.o, this.container, this.iteratorType);
          }
        },
        o = class extends r.default {
          constructor(e = [], t = 4096) {
            super(),
              (this.j = 0),
              (this.D = 0),
              (this.R = 0),
              (this.N = 0),
              (this.P = 0),
              (this.A = []);
            let r = (() => {
              if ("number" == typeof e.length) return e.length;
              if ("number" == typeof e.size) return e.size;
              if ("function" == typeof e.size) return e.size();
              throw new TypeError(
                "Cannot get the length or size of the container"
              );
            })();
            (this.F = t), (this.P = Math.max(Math.ceil(r / this.F), 1));
            for (let e = 0; e < this.P; ++e) this.A.push(new Array(this.F));
            let n = Math.ceil(r / this.F);
            (this.j = this.R = (this.P >> 1) - (n >> 1)),
              (this.D = this.N = (this.F - (r % this.F)) >> 1);
            let i = this;
            e.forEach(function (e) {
              i.pushBack(e);
            });
          }
          T() {
            let e = [],
              t = Math.max(this.P >> 1, 1);
            for (let r = 0; r < t; ++r) e[r] = new Array(this.F);
            for (let t = this.j; t < this.P; ++t) e[e.length] = this.A[t];
            for (let t = 0; t < this.R; ++t) e[e.length] = this.A[t];
            (e[e.length] = [...this.A[this.R]]),
              (this.j = t),
              (this.R = e.length - 1);
            for (let r = 0; r < t; ++r) e[e.length] = new Array(this.F);
            (this.A = e), (this.P = e.length);
          }
          O(e) {
            let t = this.D + e + 1,
              r = t % this.F,
              n = r - 1,
              i = this.j + (t - r) / this.F;
            return (
              0 === r && (i -= 1),
              (i %= this.P),
              n < 0 && (n += this.F),
              { curNodeBucketIndex: i, curNodePointerIndex: n }
            );
          }
          clear() {
            (this.A = [new Array(this.F)]),
              (this.P = 1),
              (this.j = this.R = this.i = 0),
              (this.D = this.N = this.F >> 1);
          }
          begin() {
            return new i(0, this);
          }
          end() {
            return new i(this.i, this);
          }
          rBegin() {
            return new i(this.i - 1, this, 1);
          }
          rEnd() {
            return new i(-1, this, 1);
          }
          front() {
            if (0 !== this.i) return this.A[this.j][this.D];
          }
          back() {
            if (0 !== this.i) return this.A[this.R][this.N];
          }
          pushBack(e) {
            return (
              this.i &&
                (this.N < this.F - 1
                  ? (this.N += 1)
                  : this.R < this.P - 1
                  ? ((this.R += 1), (this.N = 0))
                  : ((this.R = 0), (this.N = 0)),
                this.R === this.j && this.N === this.D && this.T()),
              (this.i += 1),
              (this.A[this.R][this.N] = e),
              this.i
            );
          }
          popBack() {
            if (0 === this.i) return;
            let e = this.A[this.R][this.N];
            return (
              1 !== this.i &&
                (this.N > 0
                  ? (this.N -= 1)
                  : this.R > 0
                  ? ((this.R -= 1), (this.N = this.F - 1))
                  : ((this.R = this.P - 1), (this.N = this.F - 1))),
              (this.i -= 1),
              e
            );
          }
          pushFront(e) {
            return (
              this.i &&
                (this.D > 0
                  ? (this.D -= 1)
                  : this.j > 0
                  ? ((this.j -= 1), (this.D = this.F - 1))
                  : ((this.j = this.P - 1), (this.D = this.F - 1)),
                this.j === this.R && this.D === this.N && this.T()),
              (this.i += 1),
              (this.A[this.j][this.D] = e),
              this.i
            );
          }
          popFront() {
            if (0 === this.i) return;
            let e = this.A[this.j][this.D];
            return (
              1 !== this.i &&
                (this.D < this.F - 1
                  ? (this.D += 1)
                  : this.j < this.P - 1
                  ? ((this.j += 1), (this.D = 0))
                  : ((this.j = 0), (this.D = 0))),
              (this.i -= 1),
              e
            );
          }
          getElementByPos(e) {
            if (e < 0 || e > this.i - 1) throw new RangeError();
            let { curNodeBucketIndex: t, curNodePointerIndex: r } = this.O(e);
            return this.A[t][r];
          }
          setElementByPos(e, t) {
            if (e < 0 || e > this.i - 1) throw new RangeError();
            let { curNodeBucketIndex: r, curNodePointerIndex: n } = this.O(e);
            this.A[r][n] = t;
          }
          insert(e, t, r = 1) {
            if (e < 0 || e > this.i) throw new RangeError();
            if (0 === e) for (; r--; ) this.pushFront(t);
            else if (e === this.i) for (; r--; ) this.pushBack(t);
            else {
              let n = [];
              for (let t = e; t < this.i; ++t) n.push(this.getElementByPos(t));
              this.cut(e - 1);
              for (let e = 0; e < r; ++e) this.pushBack(t);
              for (let e = 0; e < n.length; ++e) this.pushBack(n[e]);
            }
            return this.i;
          }
          cut(e) {
            if (e < 0) return this.clear(), 0;
            let { curNodeBucketIndex: t, curNodePointerIndex: r } = this.O(e);
            return (this.R = t), (this.N = r), (this.i = e + 1), this.i;
          }
          eraseElementByPos(e) {
            if (e < 0 || e > this.i - 1) throw new RangeError();
            if (0 === e) this.popFront();
            else if (e === this.i - 1) this.popBack();
            else {
              let t = [];
              for (let r = e + 1; r < this.i; ++r)
                t.push(this.getElementByPos(r));
              this.cut(e), this.popBack();
              let r = this;
              t.forEach(function (e) {
                r.pushBack(e);
              });
            }
            return this.i;
          }
          eraseElementByValue(e) {
            if (0 === this.i) return 0;
            let t = [];
            for (let r = 0; r < this.i; ++r) {
              let n = this.getElementByPos(r);
              n !== e && t.push(n);
            }
            let r = t.length;
            for (let e = 0; e < r; ++e) this.setElementByPos(e, t[e]);
            return this.cut(r - 1);
          }
          eraseElementByIterator(e) {
            let t = e.o;
            return this.eraseElementByPos(t), e.next();
          }
          find(e) {
            for (let t = 0; t < this.i; ++t)
              if (this.getElementByPos(t) === e) return new i(t, this);
            return this.end();
          }
          reverse() {
            let e = 0,
              t = this.i - 1;
            for (; e < t; ) {
              let r = this.getElementByPos(e);
              this.setElementByPos(e, this.getElementByPos(t)),
                this.setElementByPos(t, r),
                (e += 1),
                (t -= 1);
            }
          }
          unique() {
            if (this.i <= 1) return this.i;
            let e = 1,
              t = this.getElementByPos(0);
            for (let r = 1; r < this.i; ++r) {
              let n = this.getElementByPos(r);
              n !== t && ((t = n), this.setElementByPos(e++, n));
            }
            for (; this.i > e; ) this.popBack();
            return this.i;
          }
          sort(e) {
            let t = [];
            for (let e = 0; e < this.i; ++e) t.push(this.getElementByPos(e));
            t.sort(e);
            for (let e = 0; e < this.i; ++e) this.setElementByPos(e, t[e]);
          }
          shrinkToFit() {
            if (0 === this.i) return;
            let e = [];
            this.forEach(function (t) {
              e.push(t);
            }),
              (this.P = Math.max(Math.ceil(this.i / this.F), 1)),
              (this.i = this.j = this.R = this.D = this.N = 0),
              (this.A = []);
            for (let e = 0; e < this.P; ++e) this.A.push(new Array(this.F));
            for (let t = 0; t < e.length; ++t) this.pushBack(e[t]);
          }
          forEach(e) {
            for (let t = 0; t < this.i; ++t)
              e(this.getElementByPos(t), t, this);
          }
          [Symbol.iterator]() {
            return function* () {
              for (let e = 0; e < this.i; ++e) yield this.getElementByPos(e);
            }.bind(this)();
          }
        };
      e.default = o;
    }),
    Ld = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "t", { value: !0 }),
        (e.TreeNodeEnableIndex = e.TreeNode = void 0);
      var t = class {
        constructor(e, t) {
          (this.ee = 1),
            (this.u = void 0),
            (this.l = void 0),
            (this.U = void 0),
            (this.W = void 0),
            (this.tt = void 0),
            (this.u = e),
            (this.l = t);
        }
        L() {
          let e = this;
          if (1 === e.ee && e.tt.tt === e) e = e.W;
          else if (e.U) for (e = e.U; e.W; ) e = e.W;
          else {
            let t = e.tt;
            for (; t.U === e; ) (e = t), (t = e.tt);
            e = t;
          }
          return e;
        }
        B() {
          let e = this;
          if (e.W) {
            for (e = e.W; e.U; ) e = e.U;
            return e;
          }
          {
            let t = e.tt;
            for (; t.W === e; ) (e = t), (t = e.tt);
            return e.W !== t ? t : e;
          }
        }
        te() {
          let e = this.tt,
            t = this.W,
            r = t.U;
          return (
            e.tt === this ? (e.tt = t) : e.U === this ? (e.U = t) : (e.W = t),
            (t.tt = e),
            (t.U = this),
            (this.tt = t),
            (this.W = r),
            r && (r.tt = this),
            t
          );
        }
        se() {
          let e = this.tt,
            t = this.U,
            r = t.W;
          return (
            e.tt === this ? (e.tt = t) : e.U === this ? (e.U = t) : (e.W = t),
            (t.tt = e),
            (t.W = this),
            (this.tt = t),
            (this.U = r),
            r && (r.tt = this),
            t
          );
        }
      };
      (e.TreeNode = t),
        (e.TreeNodeEnableIndex = class extends t {
          constructor() {
            super(...arguments), (this.rt = 1);
          }
          te() {
            let e = super.te();
            return this.ie(), e.ie(), e;
          }
          se() {
            let e = super.se();
            return this.ie(), e.ie(), e;
          }
          ie() {
            (this.rt = 1),
              this.U && (this.rt += this.U.rt),
              this.W && (this.rt += this.W.rt);
          }
        });
    }),
    Od = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "t", { value: !0 }),
        (e.default = void 0);
      var t = Ld(),
        r = wd(),
        n = Ad(),
        i = class extends r.Container {
          constructor(
            e = function (e, t) {
              return e < t ? -1 : e > t ? 1 : 0;
            },
            r = !1
          ) {
            super(),
              (this.Y = void 0),
              (this.v = e),
              r
                ? ((this.re = t.TreeNodeEnableIndex),
                  (this.M = function (e, t, r) {
                    let n = this.ne(e, t, r);
                    if (n) {
                      let e = n.tt;
                      for (; e !== this.h; ) (e.rt += 1), (e = e.tt);
                      let t = this.he(n);
                      if (t) {
                        let { parentNode: e, grandParent: r, curNode: n } = t;
                        e.ie(), r.ie(), n.ie();
                      }
                    }
                    return this.i;
                  }),
                  (this.V = function (e) {
                    let t = this.fe(e);
                    for (; t !== this.h; ) (t.rt -= 1), (t = t.tt);
                  }))
                : ((this.re = t.TreeNode),
                  (this.M = function (e, t, r) {
                    let n = this.ne(e, t, r);
                    return n && this.he(n), this.i;
                  }),
                  (this.V = this.fe)),
              (this.h = new this.re());
          }
          X(e, t) {
            let r = this.h;
            for (; e; ) {
              let n = this.v(e.u, t);
              if (n < 0) e = e.W;
              else {
                if (!(n > 0)) return e;
                (r = e), (e = e.U);
              }
            }
            return r;
          }
          Z(e, t) {
            let r = this.h;
            for (; e; ) this.v(e.u, t) <= 0 ? (e = e.W) : ((r = e), (e = e.U));
            return r;
          }
          $(e, t) {
            let r = this.h;
            for (; e; ) {
              let n = this.v(e.u, t);
              if (n < 0) (r = e), (e = e.W);
              else {
                if (!(n > 0)) return e;
                e = e.U;
              }
            }
            return r;
          }
          rr(e, t) {
            let r = this.h;
            for (; e; ) this.v(e.u, t) < 0 ? ((r = e), (e = e.W)) : (e = e.U);
            return r;
          }
          ue(e) {
            for (;;) {
              let t = e.tt;
              if (t === this.h) return;
              if (1 === e.ee) return void (e.ee = 0);
              if (e === t.U) {
                let r = t.W;
                if (1 === r.ee)
                  (r.ee = 0),
                    (t.ee = 1),
                    t === this.Y ? (this.Y = t.te()) : t.te();
                else {
                  if (r.W && 1 === r.W.ee)
                    return (
                      (r.ee = t.ee),
                      (t.ee = 0),
                      (r.W.ee = 0),
                      void (t === this.Y ? (this.Y = t.te()) : t.te())
                    );
                  r.U && 1 === r.U.ee
                    ? ((r.ee = 1), (r.U.ee = 0), r.se())
                    : ((r.ee = 1), (e = t));
                }
              } else {
                let r = t.U;
                if (1 === r.ee)
                  (r.ee = 0),
                    (t.ee = 1),
                    t === this.Y ? (this.Y = t.se()) : t.se();
                else {
                  if (r.U && 1 === r.U.ee)
                    return (
                      (r.ee = t.ee),
                      (t.ee = 0),
                      (r.U.ee = 0),
                      void (t === this.Y ? (this.Y = t.se()) : t.se())
                    );
                  r.W && 1 === r.W.ee
                    ? ((r.ee = 1), (r.W.ee = 0), r.te())
                    : ((r.ee = 1), (e = t));
                }
              }
            }
          }
          fe(e) {
            if (1 === this.i) return this.clear(), this.h;
            let t = e;
            for (; t.U || t.W; ) {
              if (t.W) for (t = t.W; t.U; ) t = t.U;
              else t = t.U;
              ([e.u, t.u] = [t.u, e.u]), ([e.l, t.l] = [t.l, e.l]), (e = t);
            }
            this.h.U === t
              ? (this.h.U = t.tt)
              : this.h.W === t && (this.h.W = t.tt),
              this.ue(t);
            let r = t.tt;
            return (
              t === r.U ? (r.U = void 0) : (r.W = void 0),
              (this.i -= 1),
              (this.Y.ee = 0),
              r
            );
          }
          oe(e, t) {
            return (
              void 0 !== e && (!(!this.oe(e.U, t) && !t(e)) || this.oe(e.W, t))
            );
          }
          he(e) {
            for (;;) {
              let t = e.tt;
              if (0 === t.ee) return;
              let r = t.tt;
              if (t === r.U) {
                let n = r.W;
                if (n && 1 === n.ee) {
                  if (((n.ee = t.ee = 0), r === this.Y)) return;
                  (r.ee = 1), (e = r);
                  continue;
                }
                if (e === t.W) {
                  if (
                    ((e.ee = 0),
                    e.U && (e.U.tt = t),
                    e.W && (e.W.tt = r),
                    (t.W = e.U),
                    (r.U = e.W),
                    (e.U = t),
                    (e.W = r),
                    r === this.Y)
                  )
                    (this.Y = e), (this.h.tt = e);
                  else {
                    let t = r.tt;
                    t.U === r ? (t.U = e) : (t.W = e);
                  }
                  return (
                    (e.tt = r.tt),
                    (t.tt = e),
                    (r.tt = e),
                    (r.ee = 1),
                    { parentNode: t, grandParent: r, curNode: e }
                  );
                }
                (t.ee = 0),
                  r === this.Y ? (this.Y = r.se()) : r.se(),
                  (r.ee = 1);
              } else {
                let n = r.U;
                if (n && 1 === n.ee) {
                  if (((n.ee = t.ee = 0), r === this.Y)) return;
                  (r.ee = 1), (e = r);
                  continue;
                }
                if (e === t.U) {
                  if (
                    ((e.ee = 0),
                    e.U && (e.U.tt = r),
                    e.W && (e.W.tt = t),
                    (r.W = e.U),
                    (t.U = e.W),
                    (e.U = r),
                    (e.W = t),
                    r === this.Y)
                  )
                    (this.Y = e), (this.h.tt = e);
                  else {
                    let t = r.tt;
                    t.U === r ? (t.U = e) : (t.W = e);
                  }
                  return (
                    (e.tt = r.tt),
                    (t.tt = e),
                    (r.tt = e),
                    (r.ee = 1),
                    { parentNode: t, grandParent: r, curNode: e }
                  );
                }
                (t.ee = 0),
                  r === this.Y ? (this.Y = r.te()) : r.te(),
                  (r.ee = 1);
              }
              return;
            }
          }
          ne(e, t, r) {
            if (void 0 === this.Y)
              return (
                (this.i += 1),
                (this.Y = new this.re(e, t)),
                (this.Y.ee = 0),
                (this.Y.tt = this.h),
                (this.h.tt = this.Y),
                (this.h.U = this.Y),
                void (this.h.W = this.Y)
              );
            let n,
              i = this.h.U,
              o = this.v(i.u, e);
            if (0 !== o) {
              if (o > 0)
                (i.U = new this.re(e, t)),
                  (i.U.tt = i),
                  (n = i.U),
                  (this.h.U = n);
              else {
                let i = this.h.W,
                  o = this.v(i.u, e);
                if (0 === o) return void (i.l = t);
                if (o < 0)
                  (i.W = new this.re(e, t)),
                    (i.W.tt = i),
                    (n = i.W),
                    (this.h.W = n);
                else {
                  if (void 0 !== r) {
                    let i = r.o;
                    if (i !== this.h) {
                      let r = this.v(i.u, e);
                      if (0 === r) return void (i.l = t);
                      if (r > 0) {
                        let r = i.L(),
                          o = this.v(r.u, e);
                        if (0 === o) return void (r.l = t);
                        o < 0 &&
                          ((n = new this.re(e, t)),
                          void 0 === r.W
                            ? ((r.W = n), (n.tt = r))
                            : ((i.U = n), (n.tt = i)));
                      }
                    }
                  }
                  if (void 0 === n)
                    for (n = this.Y; ; ) {
                      let r = this.v(n.u, e);
                      if (r > 0) {
                        if (void 0 === n.U) {
                          (n.U = new this.re(e, t)), (n.U.tt = n), (n = n.U);
                          break;
                        }
                        n = n.U;
                      } else {
                        if (!(r < 0)) return void (n.l = t);
                        if (void 0 === n.W) {
                          (n.W = new this.re(e, t)), (n.W.tt = n), (n = n.W);
                          break;
                        }
                        n = n.W;
                      }
                    }
                }
              }
              return (this.i += 1), n;
            }
            i.l = t;
          }
          I(e, t) {
            for (; e; ) {
              let r = this.v(e.u, t);
              if (r < 0) e = e.W;
              else {
                if (!(r > 0)) return e;
                e = e.U;
              }
            }
            return e || this.h;
          }
          clear() {
            (this.i = 0),
              (this.Y = void 0),
              (this.h.tt = void 0),
              (this.h.U = this.h.W = void 0);
          }
          updateKeyByIterator(e, t) {
            let r = e.o;
            if (
              (r === this.h && (0, n.throwIteratorAccessError)(), 1 === this.i)
            )
              return (r.u = t), !0;
            if (r === this.h.U)
              return this.v(r.B().u, t) > 0 && ((r.u = t), !0);
            if (r === this.h.W)
              return this.v(r.L().u, t) < 0 && ((r.u = t), !0);
            let i = r.L().u;
            if (this.v(i, t) >= 0) return !1;
            let o = r.B().u;
            return !(this.v(o, t) <= 0 || ((r.u = t), 0));
          }
          eraseElementByPos(e) {
            if (e < 0 || e > this.i - 1) throw new RangeError();
            let t = 0,
              r = this;
            return (
              this.oe(this.Y, function (n) {
                return e === t ? (r.V(n), !0) : ((t += 1), !1);
              }),
              this.i
            );
          }
          eraseElementByKey(e) {
            if (0 === this.i) return !1;
            let t = this.I(this.Y, e);
            return t !== this.h && (this.V(t), !0);
          }
          eraseElementByIterator(e) {
            let t = e.o;
            t === this.h && (0, n.throwIteratorAccessError)();
            let r = void 0 === t.W;
            return (
              0 === e.iteratorType
                ? r && e.next()
                : (!r || void 0 === t.U) && e.next(),
              this.V(t),
              e
            );
          }
          forEach(e) {
            let t = 0;
            for (let r of this) e(r, t++, this);
          }
          getElementByPos(e) {
            if (e < 0 || e > this.i - 1) throw new RangeError();
            let t,
              r = 0;
            for (let n of this) {
              if (r === e) {
                t = n;
                break;
              }
              r += 1;
            }
            return t;
          }
          getHeight() {
            if (0 === this.i) return 0;
            let e = function (t) {
              return t ? Math.max(e(t.U), e(t.W)) + 1 : 0;
            };
            return e(this.Y);
          }
        };
      e.default = i;
    }),
    Nd = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "t", { value: !0 }),
        (e.default = void 0);
      var t = wd(),
        r = Ad(),
        n = class extends t.ContainerIterator {
          constructor(e, t, n) {
            super(n),
              (this.o = e),
              (this.h = t),
              0 === this.iteratorType
                ? ((this.pre = function () {
                    return (
                      this.o === this.h.U && (0, r.throwIteratorAccessError)(),
                      (this.o = this.o.L()),
                      this
                    );
                  }),
                  (this.next = function () {
                    return (
                      this.o === this.h && (0, r.throwIteratorAccessError)(),
                      (this.o = this.o.B()),
                      this
                    );
                  }))
                : ((this.pre = function () {
                    return (
                      this.o === this.h.W && (0, r.throwIteratorAccessError)(),
                      (this.o = this.o.B()),
                      this
                    );
                  }),
                  (this.next = function () {
                    return (
                      this.o === this.h && (0, r.throwIteratorAccessError)(),
                      (this.o = this.o.L()),
                      this
                    );
                  }));
          }
          get index() {
            let e = this.o,
              t = this.h.tt;
            if (e === this.h) return t ? t.rt - 1 : 0;
            let r = 0;
            for (e.U && (r += e.U.rt); e !== t; ) {
              let t = e.tt;
              e === t.W && ((r += 1), t.U && (r += t.U.rt)), (e = t);
            }
            return r;
          }
        };
      e.default = n;
    }),
    Ud = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "t", { value: !0 }),
        (e.default = void 0);
      var t = i(Od()),
        r = i(Nd()),
        n = Ad();
      function i(e) {
        return e && e.t ? e : { default: e };
      }
      var o = class e extends r.default {
          constructor(e, t, r, n) {
            super(e, t, n), (this.container = r);
          }
          get pointer() {
            return (
              this.o === this.h && (0, n.throwIteratorAccessError)(), this.o.u
            );
          }
          copy() {
            return new e(this.o, this.h, this.container, this.iteratorType);
          }
        },
        s = class extends t.default {
          constructor(e = [], t, r) {
            super(t, r);
            let n = this;
            e.forEach(function (e) {
              n.insert(e);
            });
          }
          *K(e) {
            void 0 !== e && (yield* this.K(e.U), yield e.u, yield* this.K(e.W));
          }
          begin() {
            return new o(this.h.U || this.h, this.h, this);
          }
          end() {
            return new o(this.h, this.h, this);
          }
          rBegin() {
            return new o(this.h.W || this.h, this.h, this, 1);
          }
          rEnd() {
            return new o(this.h, this.h, this, 1);
          }
          front() {
            return this.h.U ? this.h.U.u : void 0;
          }
          back() {
            return this.h.W ? this.h.W.u : void 0;
          }
          insert(e, t) {
            return this.M(e, void 0, t);
          }
          find(e) {
            let t = this.I(this.Y, e);
            return new o(t, this.h, this);
          }
          lowerBound(e) {
            let t = this.X(this.Y, e);
            return new o(t, this.h, this);
          }
          upperBound(e) {
            let t = this.Z(this.Y, e);
            return new o(t, this.h, this);
          }
          reverseLowerBound(e) {
            let t = this.$(this.Y, e);
            return new o(t, this.h, this);
          }
          reverseUpperBound(e) {
            let t = this.rr(this.Y, e);
            return new o(t, this.h, this);
          }
          union(e) {
            let t = this;
            return (
              e.forEach(function (e) {
                t.insert(e);
              }),
              this.i
            );
          }
          [Symbol.iterator]() {
            return this.K(this.Y);
          }
        };
      e.default = s;
    }),
    Dd = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "t", { value: !0 }),
        (e.default = void 0);
      var t = i(Od()),
        r = i(Nd()),
        n = Ad();
      function i(e) {
        return e && e.t ? e : { default: e };
      }
      var o = class e extends r.default {
          constructor(e, t, r, n) {
            super(e, t, n), (this.container = r);
          }
          get pointer() {
            this.o === this.h && (0, n.throwIteratorAccessError)();
            let e = this;
            return new Proxy([], {
              get: (t, r) => ("0" === r ? e.o.u : "1" === r ? e.o.l : void 0),
              set(t, r, n) {
                if ("1" !== r) throw new TypeError("props must be 1");
                return (e.o.l = n), !0;
              },
            });
          }
          copy() {
            return new e(this.o, this.h, this.container, this.iteratorType);
          }
        },
        s = class extends t.default {
          constructor(e = [], t, r) {
            super(t, r);
            let n = this;
            e.forEach(function (e) {
              n.setElement(e[0], e[1]);
            });
          }
          *K(e) {
            void 0 !== e &&
              (yield* this.K(e.U), yield [e.u, e.l], yield* this.K(e.W));
          }
          begin() {
            return new o(this.h.U || this.h, this.h, this);
          }
          end() {
            return new o(this.h, this.h, this);
          }
          rBegin() {
            return new o(this.h.W || this.h, this.h, this, 1);
          }
          rEnd() {
            return new o(this.h, this.h, this, 1);
          }
          front() {
            if (0 === this.i) return;
            let e = this.h.U;
            return [e.u, e.l];
          }
          back() {
            if (0 === this.i) return;
            let e = this.h.W;
            return [e.u, e.l];
          }
          lowerBound(e) {
            let t = this.X(this.Y, e);
            return new o(t, this.h, this);
          }
          upperBound(e) {
            let t = this.Z(this.Y, e);
            return new o(t, this.h, this);
          }
          reverseLowerBound(e) {
            let t = this.$(this.Y, e);
            return new o(t, this.h, this);
          }
          reverseUpperBound(e) {
            let t = this.rr(this.Y, e);
            return new o(t, this.h, this);
          }
          setElement(e, t, r) {
            return this.M(e, t, r);
          }
          find(e) {
            let t = this.I(this.Y, e);
            return new o(t, this.h, this);
          }
          getElementByKey(e) {
            return this.I(this.Y, e).l;
          }
          union(e) {
            let t = this;
            return (
              e.forEach(function (e) {
                t.setElement(e[0], e[1]);
              }),
              this.i
            );
          }
          [Symbol.iterator]() {
            return this.K(this.Y);
          }
        };
      e.default = s;
    }),
    kd = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "t", { value: !0 }),
        (e.default = function (e) {
          let t = typeof e;
          return ("object" === t && null !== e) || "function" === t;
        });
    }),
    Bd = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "t", { value: !0 }),
        (e.HashContainerIterator = e.HashContainer = void 0);
      var t,
        r = wd(),
        n = (t = kd()) && t.t ? t : { default: t },
        i = Ad(),
        o = class extends r.ContainerIterator {
          constructor(e, t, r) {
            super(r),
              (this.o = e),
              (this.h = t),
              0 === this.iteratorType
                ? ((this.pre = function () {
                    return (
                      this.o.L === this.h && (0, i.throwIteratorAccessError)(),
                      (this.o = this.o.L),
                      this
                    );
                  }),
                  (this.next = function () {
                    return (
                      this.o === this.h && (0, i.throwIteratorAccessError)(),
                      (this.o = this.o.B),
                      this
                    );
                  }))
                : ((this.pre = function () {
                    return (
                      this.o.B === this.h && (0, i.throwIteratorAccessError)(),
                      (this.o = this.o.B),
                      this
                    );
                  }),
                  (this.next = function () {
                    return (
                      this.o === this.h && (0, i.throwIteratorAccessError)(),
                      (this.o = this.o.L),
                      this
                    );
                  }));
          }
        };
      e.HashContainerIterator = o;
      var s = class extends r.Container {
        constructor() {
          super(),
            (this.H = []),
            (this.g = {}),
            (this.HASH_TAG = Symbol("@@HASH_TAG")),
            Object.setPrototypeOf(this.g, null),
            (this.h = {}),
            (this.h.L = this.h.B = this.p = this._ = this.h);
        }
        V(e) {
          let { L: t, B: r } = e;
          (t.B = r),
            (r.L = t),
            e === this.p && (this.p = r),
            e === this._ && (this._ = t),
            (this.i -= 1);
        }
        M(e, t, r) {
          let i;
          if ((void 0 === r && (r = (0, n.default)(e)), r)) {
            let r = e[this.HASH_TAG];
            if (void 0 !== r) return (this.H[r].l = t), this.i;
            Object.defineProperty(e, this.HASH_TAG, {
              value: this.H.length,
              configurable: !0,
            }),
              (i = { u: e, l: t, L: this._, B: this.h }),
              this.H.push(i);
          } else {
            let r = this.g[e];
            if (r) return (r.l = t), this.i;
            (i = { u: e, l: t, L: this._, B: this.h }), (this.g[e] = i);
          }
          return (
            0 === this.i ? ((this.p = i), (this.h.B = i)) : (this._.B = i),
            (this._ = i),
            (this.h.L = i),
            ++this.i
          );
        }
        I(e, t) {
          if ((void 0 === t && (t = (0, n.default)(e)), t)) {
            let t = e[this.HASH_TAG];
            return void 0 === t ? this.h : this.H[t];
          }
          return this.g[e] || this.h;
        }
        clear() {
          let e = this.HASH_TAG;
          this.H.forEach(function (t) {
            delete t.u[e];
          }),
            (this.H = []),
            (this.g = {}),
            Object.setPrototypeOf(this.g, null),
            (this.i = 0),
            (this.p = this._ = this.h.L = this.h.B = this.h);
        }
        eraseElementByKey(e, t) {
          let r;
          if ((void 0 === t && (t = (0, n.default)(e)), t)) {
            let t = e[this.HASH_TAG];
            if (void 0 === t) return !1;
            delete e[this.HASH_TAG], (r = this.H[t]), delete this.H[t];
          } else {
            if (((r = this.g[e]), void 0 === r)) return !1;
            delete this.g[e];
          }
          return this.V(r), !0;
        }
        eraseElementByIterator(e) {
          let t = e.o;
          return (
            t === this.h && (0, i.throwIteratorAccessError)(),
            this.V(t),
            e.next()
          );
        }
        eraseElementByPos(e) {
          if (e < 0 || e > this.i - 1) throw new RangeError();
          let t = this.p;
          for (; e--; ) t = t.B;
          return this.V(t), this.i;
        }
      };
      e.HashContainer = s;
    }),
    Fd = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "t", { value: !0 }),
        (e.default = void 0);
      var t = Bd(),
        r = Ad(),
        n = class e extends t.HashContainerIterator {
          constructor(e, t, r, n) {
            super(e, t, n), (this.container = r);
          }
          get pointer() {
            return (
              this.o === this.h && (0, r.throwIteratorAccessError)(), this.o.u
            );
          }
          copy() {
            return new e(this.o, this.h, this.container, this.iteratorType);
          }
        },
        i = class extends t.HashContainer {
          constructor(e = []) {
            super();
            let t = this;
            e.forEach(function (e) {
              t.insert(e);
            });
          }
          begin() {
            return new n(this.p, this.h, this);
          }
          end() {
            return new n(this.h, this.h, this);
          }
          rBegin() {
            return new n(this._, this.h, this, 1);
          }
          rEnd() {
            return new n(this.h, this.h, this, 1);
          }
          front() {
            return this.p.u;
          }
          back() {
            return this._.u;
          }
          insert(e, t) {
            return this.M(e, void 0, t);
          }
          getElementByPos(e) {
            if (e < 0 || e > this.i - 1) throw new RangeError();
            let t = this.p;
            for (; e--; ) t = t.B;
            return t.u;
          }
          find(e, t) {
            let r = this.I(e, t);
            return new n(r, this.h, this);
          }
          forEach(e) {
            let t = 0,
              r = this.p;
            for (; r !== this.h; ) e(r.u, t++, this), (r = r.B);
          }
          [Symbol.iterator]() {
            return function* () {
              let e = this.p;
              for (; e !== this.h; ) yield e.u, (e = e.B);
            }.bind(this)();
          }
        };
      e.default = i;
    }),
    Hd = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "t", { value: !0 }),
        (e.default = void 0);
      var t,
        r = Bd(),
        n = (t = kd()) && t.t ? t : { default: t },
        i = Ad(),
        o = class e extends r.HashContainerIterator {
          constructor(e, t, r, n) {
            super(e, t, n), (this.container = r);
          }
          get pointer() {
            this.o === this.h && (0, i.throwIteratorAccessError)();
            let e = this;
            return new Proxy([], {
              get: (t, r) => ("0" === r ? e.o.u : "1" === r ? e.o.l : void 0),
              set(t, r, n) {
                if ("1" !== r) throw new TypeError("props must be 1");
                return (e.o.l = n), !0;
              },
            });
          }
          copy() {
            return new e(this.o, this.h, this.container, this.iteratorType);
          }
        },
        s = class extends r.HashContainer {
          constructor(e = []) {
            super();
            let t = this;
            e.forEach(function (e) {
              t.setElement(e[0], e[1]);
            });
          }
          begin() {
            return new o(this.p, this.h, this);
          }
          end() {
            return new o(this.h, this.h, this);
          }
          rBegin() {
            return new o(this._, this.h, this, 1);
          }
          rEnd() {
            return new o(this.h, this.h, this, 1);
          }
          front() {
            if (0 !== this.i) return [this.p.u, this.p.l];
          }
          back() {
            if (0 !== this.i) return [this._.u, this._.l];
          }
          setElement(e, t, r) {
            return this.M(e, t, r);
          }
          getElementByKey(e, t) {
            if ((void 0 === t && (t = (0, n.default)(e)), t)) {
              let t = e[this.HASH_TAG];
              return void 0 !== t ? this.H[t].l : void 0;
            }
            let r = this.g[e];
            return r ? r.l : void 0;
          }
          getElementByPos(e) {
            if (e < 0 || e > this.i - 1) throw new RangeError();
            let t = this.p;
            for (; e--; ) t = t.B;
            return [t.u, t.l];
          }
          find(e, t) {
            let r = this.I(e, t);
            return new o(r, this.h, this);
          }
          forEach(e) {
            let t = 0,
              r = this.p;
            for (; r !== this.h; ) e([r.u, r.l], t++, this), (r = r.B);
          }
          [Symbol.iterator]() {
            return function* () {
              let e = this.p;
              for (; e !== this.h; ) yield [e.u, e.l], (e = e.B);
            }.bind(this)();
          }
        };
      e.default = s;
    }),
    zd = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "t", { value: !0 }),
        Object.defineProperty(e, "Deque", {
          enumerable: !0,
          get: function () {
            return s.default;
          },
        }),
        Object.defineProperty(e, "HashMap", {
          enumerable: !0,
          get: function () {
            return u.default;
          },
        }),
        Object.defineProperty(e, "HashSet", {
          enumerable: !0,
          get: function () {
            return c.default;
          },
        }),
        Object.defineProperty(e, "LinkList", {
          enumerable: !0,
          get: function () {
            return o.default;
          },
        }),
        Object.defineProperty(e, "OrderedMap", {
          enumerable: !0,
          get: function () {
            return l.default;
          },
        }),
        Object.defineProperty(e, "OrderedSet", {
          enumerable: !0,
          get: function () {
            return a.default;
          },
        }),
        Object.defineProperty(e, "PriorityQueue", {
          enumerable: !0,
          get: function () {
            return n.default;
          },
        }),
        Object.defineProperty(e, "Queue", {
          enumerable: !0,
          get: function () {
            return r.default;
          },
        }),
        Object.defineProperty(e, "Stack", {
          enumerable: !0,
          get: function () {
            return t.default;
          },
        }),
        Object.defineProperty(e, "Vector", {
          enumerable: !0,
          get: function () {
            return i.default;
          },
        });
      var t = h(Sd()),
        r = h(Ed()),
        n = h(Md()),
        i = h(Pd()),
        o = h(Cd()),
        s = h(Id()),
        a = h(Ud()),
        l = h(Dd()),
        c = h(Fd()),
        u = h(Hd());
      function h(e) {
        return e && e.t ? e : { default: e };
      }
    }),
    Vd = dc((e, t) => {
      mc(), lh(), qu();
      var r = zd().OrderedSet,
        n = od()("number-allocator:trace"),
        i = od()("number-allocator:error");
      function o(e, t) {
        (this.low = e), (this.high = t);
      }
      function s(e, t) {
        if (!(this instanceof s)) return new s(e, t);
        (this.min = e),
          (this.max = t),
          (this.ss = new r([], (e, t) => e.compare(t))),
          n("Create"),
          this.clear();
      }
      (o.prototype.equals = function (e) {
        return this.low === e.low && this.high === e.high;
      }),
        (o.prototype.compare = function (e) {
          return this.low < e.low && this.high < e.low
            ? -1
            : e.low < this.low && e.high < this.low
            ? 1
            : 0;
        }),
        (s.prototype.firstVacant = function () {
          return 0 === this.ss.size() ? null : this.ss.front().low;
        }),
        (s.prototype.alloc = function () {
          if (0 === this.ss.size()) return n("alloc():empty"), null;
          let e = this.ss.begin(),
            t = e.pointer.low,
            r = e.pointer.high,
            i = t;
          return (
            i + 1 <= r
              ? this.ss.updateKeyByIterator(e, new o(t + 1, r))
              : this.ss.eraseElementByPos(0),
            n("alloc():" + i),
            i
          );
        }),
        (s.prototype.use = function (e) {
          let t = new o(e, e),
            r = this.ss.lowerBound(t);
          if (!r.equals(this.ss.end())) {
            let i = r.pointer.low,
              s = r.pointer.high;
            return r.pointer.equals(t)
              ? (this.ss.eraseElementByIterator(r), n("use():" + e), !0)
              : !(
                  i > e ||
                  (i === e
                    ? (this.ss.updateKeyByIterator(r, new o(i + 1, s)),
                      n("use():" + e),
                      0)
                    : s === e
                    ? (this.ss.updateKeyByIterator(r, new o(i, s - 1)),
                      n("use():" + e),
                      0)
                    : (this.ss.updateKeyByIterator(r, new o(e + 1, s)),
                      this.ss.insert(new o(i, e - 1)),
                      n("use():" + e),
                      0))
                );
          }
          return n("use():failed"), !1;
        }),
        (s.prototype.free = function (e) {
          if (e < this.min || e > this.max)
            return void i("free():" + e + " is out of range");
          let t = new o(e, e),
            r = this.ss.upperBound(t);
          if (r.equals(this.ss.end())) {
            if (r.equals(this.ss.begin())) return void this.ss.insert(t);
            r.pre();
            let n = r.pointer.high;
            r.pointer.high + 1 === e
              ? this.ss.updateKeyByIterator(r, new o(n, e))
              : this.ss.insert(t);
          } else if (r.equals(this.ss.begin()))
            if (e + 1 === r.pointer.low) {
              let t = r.pointer.high;
              this.ss.updateKeyByIterator(r, new o(e, t));
            } else this.ss.insert(t);
          else {
            let n = r.pointer.low,
              i = r.pointer.high;
            r.pre();
            let s = r.pointer.low;
            r.pointer.high + 1 === e
              ? e + 1 === n
                ? (this.ss.eraseElementByIterator(r),
                  this.ss.updateKeyByIterator(r, new o(s, i)))
                : this.ss.updateKeyByIterator(r, new o(s, e))
              : e + 1 === n
              ? (this.ss.eraseElementByIterator(r.next()),
                this.ss.insert(new o(e, i)))
              : this.ss.insert(t);
          }
          n("free():" + e);
        }),
        (s.prototype.clear = function () {
          n("clear()"),
            this.ss.clear(),
            this.ss.insert(new o(this.min, this.max));
        }),
        (s.prototype.intervalCount = function () {
          return this.ss.size();
        }),
        (s.prototype.dump = function () {
          console.log("length:" + this.ss.size());
          for (let e of this.ss) console.log(e);
        }),
        (t.exports = s);
    }),
    jd = dc((e, t) => {
      mc(), lh(), qu();
      var r = Vd();
      t.exports.NumberAllocator = r;
    }),
    Wd = dc((e) => {
      mc(), lh(), qu(), Object.defineProperty(e, "__esModule", { value: !0 });
      var t = xd(),
        r = jd();
      e.default = class {
        aliasToTopic;
        topicToAlias;
        max;
        numberAllocator;
        length;
        constructor(e) {
          e > 0 &&
            ((this.aliasToTopic = new t.LRUCache({ max: e })),
            (this.topicToAlias = {}),
            (this.numberAllocator = new r.NumberAllocator(1, e)),
            (this.max = e),
            (this.length = 0));
        }
        put(e, t) {
          if (0 === t || t > this.max) return !1;
          let r = this.aliasToTopic.get(t);
          return (
            r && delete this.topicToAlias[r],
            this.aliasToTopic.set(t, e),
            (this.topicToAlias[e] = t),
            this.numberAllocator.use(t),
            (this.length = this.aliasToTopic.size),
            !0
          );
        }
        getTopicByAlias(e) {
          return this.aliasToTopic.get(e);
        }
        getAliasByTopic(e) {
          let t = this.topicToAlias[e];
          return typeof t < "u" && this.aliasToTopic.get(t), t;
        }
        clear() {
          this.aliasToTopic.clear(),
            (this.topicToAlias = {}),
            this.numberAllocator.clear(),
            (this.length = 0);
        }
        getLruAlias() {
          return (
            this.numberAllocator.firstVacant() ||
            [...this.aliasToTopic.keys()][this.aliasToTopic.size - 1]
          );
        }
      };
    }),
    Gd = dc((e) => {
      mc(), lh(), qu();
      var t =
        (e && e.__importDefault) ||
        function (e) {
          return e && e.__esModule ? e : { default: e };
        };
      Object.defineProperty(e, "__esModule", { value: !0 });
      var r = yd(),
        n = t(Wd()),
        i = vd();
      e.default = (e, t) => {
        e.log("_handleConnack");
        let { options: o } = e,
          s = 5 === o.protocolVersion ? t.reasonCode : t.returnCode;
        if (
          (clearTimeout(e.connackTimer), delete e.topicAliasSend, t.properties)
        ) {
          if (t.properties.topicAliasMaximum) {
            if (t.properties.topicAliasMaximum > 65535)
              return void e.emit(
                "error",
                new Error("topicAliasMaximum from broker is out of range")
              );
            t.properties.topicAliasMaximum > 0 &&
              (e.topicAliasSend = new n.default(
                t.properties.topicAliasMaximum
              ));
          }
          t.properties.serverKeepAlive &&
            o.keepalive &&
            (o.keepalive = t.properties.serverKeepAlive),
            t.properties.maximumPacketSize &&
              (o.properties || (o.properties = {}),
              (o.properties.maximumPacketSize =
                t.properties.maximumPacketSize));
        }
        if (0 === s) (e.reconnecting = !1), e._onConnect(t);
        else if (s > 0) {
          let t = new i.ErrorWithReasonCode(
            `Connection refused: ${r.ReasonCodes[s]}`,
            s
          );
          e.emit("error", t),
            e.options.reconnectOnConnackError && e._cleanUp(!0);
        }
      };
    }),
    Xd = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "__esModule", { value: !0 }),
        (e.default = (e, t, r) => {
          e.log("handling pubrel packet");
          let n = typeof r < "u" ? r : e.noop,
            { messageId: i } = t,
            o = { cmd: "pubcomp", messageId: i };
          e.incomingStore.get(t, (t, r) => {
            t
              ? e._sendPacket(o, n)
              : (e.emit("message", r.topic, r.payload, r),
                e.handleMessage(r, (t) => {
                  if (t) return n(t);
                  e.incomingStore.del(r, e.noop), e._sendPacket(o, n);
                }));
          });
        });
    }),
    qd = dc((e) => {
      mc(), lh(), qu();
      var t =
        (e && e.__importDefault) ||
        function (e) {
          return e && e.__esModule ? e : { default: e };
        };
      Object.defineProperty(e, "__esModule", { value: !0 });
      var r = t(gd()),
        n = t(bd()),
        i = t(Gd()),
        o = t(yd()),
        s = t(Xd());
      e.default = (e, t, a) => {
        let { options: l } = e;
        if (
          5 === l.protocolVersion &&
          l.properties &&
          l.properties.maximumPacketSize &&
          l.properties.maximumPacketSize < t.length
        )
          return (
            e.emit("error", new Error(`exceeding packets size ${t.cmd}`)),
            e.end({
              reasonCode: 149,
              properties: { reasonString: "Maximum packet size was exceeded" },
            }),
            e
          );
        switch (
          (e.log("_handlePacket :: emitting packetreceive"),
          e.emit("packetreceive", t),
          t.cmd)
        ) {
          case "publish":
            (0, r.default)(e, t, a);
            break;
          case "puback":
          case "pubrec":
          case "pubcomp":
          case "suback":
          case "unsuback":
            e.reschedulePing(), (0, o.default)(e, t), a();
            break;
          case "pubrel":
            e.reschedulePing(), (0, s.default)(e, t, a);
            break;
          case "connack":
            (0, i.default)(e, t), a();
            break;
          case "auth":
            e.reschedulePing(), (0, n.default)(e, t), a();
            break;
          case "pingresp":
            e.log("_handlePacket :: received pingresp"),
              e.reschedulePing(!0),
              a();
            break;
          case "disconnect":
            e.emit("disconnect", t), a();
            break;
          default:
            e.log("_handlePacket :: unknown command"), a();
        }
      };
    }),
    Yd = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "__esModule", { value: !0 }),
        (e.default = class {
          nextId;
          constructor() {
            this.nextId = Math.max(1, Math.floor(65535 * Math.random()));
          }
          allocate() {
            let e = this.nextId++;
            return 65536 === this.nextId && (this.nextId = 1), e;
          }
          getLastAllocated() {
            return 1 === this.nextId ? 65535 : this.nextId - 1;
          }
          register(e) {
            return !0;
          }
          deallocate(e) {}
          clear() {}
        });
    }),
    Kd = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "__esModule", { value: !0 }),
        (e.default = class {
          aliasToTopic;
          max;
          length;
          constructor(e) {
            (this.aliasToTopic = {}), (this.max = e);
          }
          put(e, t) {
            return !(
              0 === t ||
              t > this.max ||
              ((this.aliasToTopic[t] = e),
              (this.length = Object.keys(this.aliasToTopic).length),
              0)
            );
          }
          getTopicByAlias(e) {
            return this.aliasToTopic[e];
          }
          clear() {
            this.aliasToTopic = {};
          }
        });
    }),
    $d = dc((e) => {
      mc(), lh(), qu();
      var t =
        (e && e.__importDefault) ||
        function (e) {
          return e && e.__esModule ? e : { default: e };
        };
      Object.defineProperty(e, "__esModule", { value: !0 }),
        (e.TypedEventEmitter = void 0);
      var r = t((Th(), fc(ph))),
        n = vd(),
        i = class {};
      (e.TypedEventEmitter = i), (0, n.applyMixin)(i, r.default);
    }),
    Qd = dc((e, t) => {
      function r(e) {
        return (
          (t.exports = r =
            "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
              ? function (e) {
                  return typeof e;
                }
              : function (e) {
                  return e &&
                    "function" == typeof Symbol &&
                    e.constructor === Symbol &&
                    e !== Symbol.prototype
                    ? "symbol"
                    : typeof e;
                }),
          (t.exports.__esModule = !0),
          (t.exports.default = t.exports),
          r(e)
        );
      }
      mc(),
        lh(),
        qu(),
        (t.exports = r),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports);
    }),
    Jd = dc((e, t) => {
      mc(), lh(), qu();
      var r = Qd().default;
      (t.exports = function (e, t) {
        if ("object" != r(e) || !e) return e;
        var n = e[Symbol.toPrimitive];
        if (void 0 !== n) {
          var i = n.call(e, t || "default");
          if ("object" != r(i)) return i;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === t ? String : Number)(e);
      }),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports);
    }),
    Zd = dc((e, t) => {
      mc(), lh(), qu();
      var r = Qd().default,
        n = Jd();
      (t.exports = function (e) {
        var t = n(e, "string");
        return "symbol" == r(t) ? t : t + "";
      }),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports);
    }),
    ep = dc((e, t) => {
      mc(), lh(), qu();
      var r = Zd();
      (t.exports = function (e, t, n) {
        return (
          (t = r(t)) in e
            ? Object.defineProperty(e, t, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0,
              })
            : (e[t] = n),
          e
        );
      }),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports);
    }),
    tp = dc((e, t) => {
      mc(),
        lh(),
        qu(),
        (t.exports = function (e) {
          if (Array.isArray(e)) return e;
        }),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports);
    }),
    rp = dc((e, t) => {
      mc(),
        lh(),
        qu(),
        (t.exports = function (e, t) {
          var r =
            null == e
              ? null
              : (typeof Symbol < "u" && e[Symbol.iterator]) || e["@@iterator"];
          if (null != r) {
            var n,
              i,
              o,
              s,
              a = [],
              l = !0,
              c = !1;
            try {
              if (((o = (r = r.call(e)).next), 0 === t)) {
                if (Object(r) !== r) return;
                l = !1;
              } else
                for (
                  ;
                  !(l = (n = o.call(r)).done) &&
                  (a.push(n.value), a.length !== t);
                  l = !0
                );
            } catch (e) {
              (c = !0), (i = e);
            } finally {
              try {
                if (
                  !l &&
                  null != r.return &&
                  ((s = r.return()), Object(s) !== s)
                )
                  return;
              } finally {
                if (c) throw i;
              }
            }
            return a;
          }
        }),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports);
    }),
    np = dc((e, t) => {
      mc(),
        lh(),
        qu(),
        (t.exports = function (e, t) {
          (null == t || t > e.length) && (t = e.length);
          for (var r = 0, n = Array(t); r < t; r++) n[r] = e[r];
          return n;
        }),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports);
    }),
    ip = dc((e, t) => {
      mc(), lh(), qu();
      var r = np();
      (t.exports = function (e, t) {
        if (e) {
          if ("string" == typeof e) return r(e, t);
          var n = {}.toString.call(e).slice(8, -1);
          return (
            "Object" === n && e.constructor && (n = e.constructor.name),
            "Map" === n || "Set" === n
              ? Array.from(e)
              : "Arguments" === n ||
                /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
              ? r(e, t)
              : void 0
          );
        }
      }),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports);
    }),
    op = dc((e, t) => {
      mc(),
        lh(),
        qu(),
        (t.exports = function () {
          throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
          );
        }),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports);
    }),
    sp = dc((e, t) => {
      mc(), lh(), qu();
      var r = tp(),
        n = rp(),
        i = ip(),
        o = op();
      (t.exports = function (e, t) {
        return r(e) || n(e, t) || i(e, t) || o();
      }),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports);
    }),
    ap = dc((t, r) => {
      var n, i;
      mc(),
        lh(),
        qu(),
        (n = t),
        (i = function (e) {
          var t,
            r =
              void 0 === Number.MAX_SAFE_INTEGER
                ? 9007199254740991
                : Number.MAX_SAFE_INTEGER,
            n = 536870912,
            i = 2 * n,
            o = new WeakMap(),
            s = (function (e, t) {
              return function (o) {
                var s = t.get(o),
                  a = void 0 === s ? o.size : s < i ? s + 1 : 0;
                if (!o.has(a)) return e(o, a);
                if (o.size < n) {
                  for (; o.has(a); ) a = Math.floor(Math.random() * i);
                  return e(o, a);
                }
                if (o.size > r)
                  throw new Error(
                    "Congratulations, you created a collection of unique numbers which uses all available integers!"
                  );
                for (; o.has(a); ) a = Math.floor(Math.random() * r);
                return e(o, a);
              };
            })(
              ((t = o),
              function (e, r) {
                return t.set(e, r), r;
              }),
              o
            ),
            a = (function (e) {
              return function (t) {
                var r = e(t);
                return t.add(r), r;
              };
            })(s);
          (e.addUniqueNumber = a), (e.generateUniqueNumber = s);
        }),
        "object" == typeof t && typeof r < "u"
          ? i(t)
          : "function" == typeof define && e.amdO
          ? define(["exports"], i)
          : i(
              ((n =
                typeof globalThis < "u"
                  ? globalThis
                  : n || self).fastUniqueNumbers = {})
            );
    }),
    lp = dc((e, t) => {
      function r(e, t, r, n, i, o, s) {
        try {
          var a = e[o](s),
            l = a.value;
        } catch (e) {
          return void r(e);
        }
        a.done ? t(l) : Promise.resolve(l).then(n, i);
      }
      mc(),
        lh(),
        qu(),
        (t.exports = function (e) {
          return function () {
            var t = this,
              n = arguments;
            return new Promise(function (i, o) {
              var s = e.apply(t, n);
              function a(e) {
                r(s, i, o, a, l, "next", e);
              }
              function l(e) {
                r(s, i, o, a, l, "throw", e);
              }
              a(void 0);
            });
          };
        }),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports);
    }),
    cp = dc((e, t) => {
      mc(),
        lh(),
        qu(),
        (t.exports = function (e, t) {
          (this.v = e), (this.k = t);
        }),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports);
    }),
    up = dc((e, t) => {
      function r(e, n, i, o) {
        var s = Object.defineProperty;
        try {
          s({}, "", {});
        } catch {
          s = 0;
        }
        (t.exports = r =
          function (e, t, n, i) {
            function o(t, n) {
              r(e, t, function (e) {
                return this._invoke(t, n, e);
              });
            }
            t
              ? s
                ? s(e, t, {
                    value: n,
                    enumerable: !i,
                    configurable: !i,
                    writable: !i,
                  })
                : (e[t] = n)
              : (o("next", 0), o("throw", 1), o("return", 2));
          }),
          (t.exports.__esModule = !0),
          (t.exports.default = t.exports),
          r(e, n, i, o);
      }
      mc(),
        lh(),
        qu(),
        (t.exports = r),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports);
    }),
    hp = dc((e, t) => {
      mc(), lh(), qu();
      var r = up();
      function n() {
        var e,
          i,
          o = "function" == typeof Symbol ? Symbol : {},
          s = o.iterator || "@@iterator",
          a = o.toStringTag || "@@toStringTag";
        function l(t, n, o, s) {
          var a = n && n.prototype instanceof u ? n : u,
            l = Object.create(a.prototype);
          return (
            r(
              l,
              "_invoke",
              (function (t, r, n) {
                var o,
                  s,
                  a,
                  l = 0,
                  u = n || [],
                  h = !1,
                  d = {
                    p: 0,
                    n: 0,
                    v: e,
                    a: p,
                    f: p.bind(e, 4),
                    d: function (t, r) {
                      return (o = t), (s = 0), (a = e), (d.n = r), c;
                    },
                  };
                function p(t, r) {
                  for (
                    s = t, a = r, i = 0;
                    !h && l && !n && i < u.length;
                    i++
                  ) {
                    var n,
                      o = u[i],
                      p = d.p,
                      f = o[2];
                    t > 3
                      ? (n = f === r) &&
                        ((a = o[(s = o[4]) ? 5 : ((s = 3), 3)]),
                        (o[4] = o[5] = e))
                      : o[0] <= p &&
                        ((n = t < 2 && p < o[1])
                          ? ((s = 0), (d.v = r), (d.n = o[1]))
                          : p < f &&
                            (n = t < 3 || o[0] > r || r > f) &&
                            ((o[4] = t), (o[5] = r), (d.n = f), (s = 0)));
                  }
                  if (n || t > 1) return c;
                  throw ((h = !0), r);
                }
                return function (n, u, f) {
                  if (l > 1) throw TypeError("Generator is already running");
                  for (
                    h && 1 === u && p(u, f), s = u, a = f;
                    (i = s < 2 ? e : a) || !h;

                  ) {
                    o ||
                      (s
                        ? s < 3
                          ? (s > 1 && (d.n = -1), p(s, a))
                          : (d.n = a)
                        : (d.v = a));
                    try {
                      if (((l = 2), o)) {
                        if ((s || (n = "next"), (i = o[n]))) {
                          if (!(i = i.call(o, a)))
                            throw TypeError("iterator result is not an object");
                          if (!i.done) return i;
                          (a = i.value), s < 2 && (s = 0);
                        } else
                          1 === s && (i = o.return) && i.call(o),
                            s < 2 &&
                              ((a = TypeError(
                                "The iterator does not provide a '" +
                                  n +
                                  "' method"
                              )),
                              (s = 1));
                        o = e;
                      } else if ((i = (h = d.n < 0) ? a : t.call(r, d)) !== c)
                        break;
                    } catch (t) {
                      (o = e), (s = 1), (a = t);
                    } finally {
                      l = 1;
                    }
                  }
                  return { value: i, done: h };
                };
              })(t, o, s),
              !0
            ),
            l
          );
        }
        var c = {};
        function u() {}
        function h() {}
        function d() {}
        i = Object.getPrototypeOf;
        var p = [][s]
            ? i(i([][s]()))
            : (r((i = {}), s, function () {
                return this;
              }),
              i),
          f = (d.prototype = u.prototype = Object.create(p));
        function m(e) {
          return (
            Object.setPrototypeOf
              ? Object.setPrototypeOf(e, d)
              : ((e.__proto__ = d), r(e, a, "GeneratorFunction")),
            (e.prototype = Object.create(f)),
            e
          );
        }
        return (
          (h.prototype = d),
          r(f, "constructor", d),
          r(d, "constructor", h),
          (h.displayName = "GeneratorFunction"),
          r(d, a, "GeneratorFunction"),
          r(f),
          r(f, a, "Generator"),
          r(f, s, function () {
            return this;
          }),
          r(f, "toString", function () {
            return "[object Generator]";
          }),
          ((t.exports = n =
            function () {
              return { w: l, m };
            }),
          (t.exports.__esModule = !0),
          (t.exports.default = t.exports))()
        );
      }
      (t.exports = n),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports);
    }),
    dp = dc((e, t) => {
      mc(), lh(), qu();
      var r = cp(),
        n = up();
      (t.exports = function e(t, i) {
        function o(e, n, s, a) {
          try {
            var l = t[e](n),
              c = l.value;
            return c instanceof r
              ? i.resolve(c.v).then(
                  function (e) {
                    o("next", e, s, a);
                  },
                  function (e) {
                    o("throw", e, s, a);
                  }
                )
              : i.resolve(c).then(
                  function (e) {
                    (l.value = e), s(l);
                  },
                  function (e) {
                    return o("throw", e, s, a);
                  }
                );
          } catch (e) {
            a(e);
          }
        }
        var s;
        this.next ||
          (n(e.prototype),
          n(
            e.prototype,
            ("function" == typeof Symbol && Symbol.asyncIterator) ||
              "@asyncIterator",
            function () {
              return this;
            }
          )),
          n(
            this,
            "_invoke",
            function (e, t, r) {
              function n() {
                return new i(function (t, n) {
                  o(e, r, t, n);
                });
              }
              return (s = s ? s.then(n, n) : n());
            },
            !0
          );
      }),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports);
    }),
    pp = dc((e, t) => {
      mc(), lh(), qu();
      var r = hp(),
        n = dp();
      (t.exports = function (e, t, i, o, s) {
        return new n(r().w(e, t, i, o), s || Promise);
      }),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports);
    }),
    fp = dc((e, t) => {
      mc(), lh(), qu();
      var r = pp();
      (t.exports = function (e, t, n, i, o) {
        var s = r(e, t, n, i, o);
        return s.next().then(function (e) {
          return e.done ? e.value : s.next();
        });
      }),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports);
    }),
    mp = dc((e, t) => {
      mc(),
        lh(),
        qu(),
        (t.exports = function (e) {
          var t = Object(e),
            r = [];
          for (var n in t) r.unshift(n);
          return function e() {
            for (; r.length; )
              if ((n = r.pop()) in t) return (e.value = n), (e.done = !1), e;
            return (e.done = !0), e;
          };
        }),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports);
    }),
    gp = dc((e, t) => {
      mc(), lh(), qu();
      var r = Qd().default;
      (t.exports = function (e) {
        if (null != e) {
          var t =
              e[
                ("function" == typeof Symbol && Symbol.iterator) || "@@iterator"
              ],
            n = 0;
          if (t) return t.call(e);
          if ("function" == typeof e.next) return e;
          if (!isNaN(e.length))
            return {
              next: function () {
                return (
                  e && n >= e.length && (e = void 0),
                  { value: e && e[n++], done: !e }
                );
              },
            };
        }
        throw new TypeError(r(e) + " is not iterable");
      }),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports);
    }),
    _p = dc((e, t) => {
      mc(), lh(), qu();
      var r = cp(),
        n = hp(),
        i = fp(),
        o = pp(),
        s = dp(),
        a = mp(),
        l = gp();
      function c() {
        var e = n(),
          u = e.m(c),
          h = (Object.getPrototypeOf ? Object.getPrototypeOf(u) : u.__proto__)
            .constructor;
        function d(e) {
          var t = "function" == typeof e && e.constructor;
          return (
            !!t &&
            (t === h || "GeneratorFunction" === (t.displayName || t.name))
          );
        }
        var p = { throw: 1, return: 2, break: 3, continue: 3 };
        function f(e) {
          var t, r;
          return function (n) {
            t ||
              ((t = {
                stop: function () {
                  return r(n.a, 2);
                },
                catch: function () {
                  return n.v;
                },
                abrupt: function (e, t) {
                  return r(n.a, p[e], t);
                },
                delegateYield: function (e, i, o) {
                  return (t.resultName = i), r(n.d, l(e), o);
                },
                finish: function (e) {
                  return r(n.f, e);
                },
              }),
              (r = function (e, r, i) {
                (n.p = t.prev), (n.n = t.next);
                try {
                  return e(r, i);
                } finally {
                  t.next = n.n;
                }
              })),
              t.resultName &&
                ((t[t.resultName] = n.v), (t.resultName = void 0)),
              (t.sent = n.v),
              (t.next = n.n);
            try {
              return e.call(this, t);
            } finally {
              (n.p = t.prev), (n.n = t.next);
            }
          };
        }
        return ((t.exports = c =
          function () {
            return {
              wrap: function (t, r, n, i) {
                return e.w(f(t), r, n, i && i.reverse());
              },
              isGeneratorFunction: d,
              mark: e.m,
              awrap: function (e, t) {
                return new r(e, t);
              },
              AsyncIterator: s,
              async: function (e, t, r, n, s) {
                return (d(t) ? o : i)(f(e), t, r, n, s);
              },
              keys: a,
              values: l,
            };
          }),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports))();
      }
      (t.exports = c),
        (t.exports.__esModule = !0),
        (t.exports.default = t.exports);
    }),
    vp = dc((e, t) => {
      mc(), lh(), qu();
      var r = _p()();
      t.exports = r;
      try {
        regeneratorRuntime = r;
      } catch {
        "object" == typeof globalThis
          ? (globalThis.regeneratorRuntime = r)
          : Function("r", "regeneratorRuntime = r")(r);
      }
    }),
    yp = dc((t, r) => {
      var n, i;
      mc(),
        lh(),
        qu(),
        (n = t),
        (i = function (e, t, r, n, i, o) {
          var s = new WeakMap();
          function a(e, t) {
            var r = Object.keys(e);
            if (Object.getOwnPropertySymbols) {
              var n = Object.getOwnPropertySymbols(e);
              t &&
                (n = n.filter(function (t) {
                  return Object.getOwnPropertyDescriptor(e, t).enumerable;
                })),
                r.push.apply(r, n);
            }
            return r;
          }
          function l(e) {
            for (var r = 1; r < arguments.length; r++) {
              var n = null != arguments[r] ? arguments[r] : {};
              r % 2
                ? a(Object(n), !0).forEach(function (r) {
                    t(e, r, n[r]);
                  })
                : Object.getOwnPropertyDescriptors
                ? Object.defineProperties(
                    e,
                    Object.getOwnPropertyDescriptors(n)
                  )
                : a(Object(n)).forEach(function (t) {
                    Object.defineProperty(
                      e,
                      t,
                      Object.getOwnPropertyDescriptor(n, t)
                    );
                  });
            }
            return e;
          }
          function c(e, t) {
            var r = Object.keys(e);
            if (Object.getOwnPropertySymbols) {
              var n = Object.getOwnPropertySymbols(e);
              t &&
                (n = n.filter(function (t) {
                  return Object.getOwnPropertyDescriptor(e, t).enumerable;
                })),
                r.push.apply(r, n);
            }
            return r;
          }
          function u(e) {
            for (var r = 1; r < arguments.length; r++) {
              var n = null != arguments[r] ? arguments[r] : {};
              r % 2
                ? c(Object(n), !0).forEach(function (r) {
                    t(e, r, n[r]);
                  })
                : Object.getOwnPropertyDescriptors
                ? Object.defineProperties(
                    e,
                    Object.getOwnPropertyDescriptors(n)
                  )
                : c(Object(n)).forEach(function (t) {
                    Object.defineProperty(
                      e,
                      t,
                      Object.getOwnPropertyDescriptor(n, t)
                    );
                  });
            }
            return e;
          }
          var h = new WeakMap();
          e.createBroker = function (e) {
            var a = (function (e) {
              return l(
                l({}, e),
                {},
                {
                  connect: function (e) {
                    var t = e.call;
                    return i(
                      o.mark(function e() {
                        var r, n, i, a;
                        return o.wrap(function (e) {
                          for (;;)
                            switch ((e.prev = e.next)) {
                              case 0:
                                return (
                                  (r = new MessageChannel()),
                                  (n = r.port1),
                                  (i = r.port2),
                                  (e.next = 1),
                                  t("connect", { port: n }, [n])
                                );
                              case 1:
                                return (
                                  (a = e.sent),
                                  s.set(i, a),
                                  e.abrupt("return", i)
                                );
                              case 2:
                              case "end":
                                return e.stop();
                            }
                        }, e);
                      })
                    );
                  },
                  disconnect: function (e) {
                    var t,
                      r = e.call;
                    return (
                      (t = i(
                        o.mark(function e(t) {
                          var n;
                          return o.wrap(function (e) {
                            for (;;)
                              switch ((e.prev = e.next)) {
                                case 0:
                                  if (void 0 !== (n = s.get(t))) {
                                    e.next = 1;
                                    break;
                                  }
                                  throw new Error(
                                    "The given port is not connected."
                                  );
                                case 1:
                                  return (
                                    (e.next = 2), r("disconnect", { portId: n })
                                  );
                                case 2:
                                case "end":
                                  return e.stop();
                              }
                          }, e);
                        })
                      )),
                      function (e) {
                        return t.apply(this, arguments);
                      }
                    );
                  },
                  isSupported: function (e) {
                    var t = e.call;
                    return function () {
                      return t("isSupported");
                    };
                  },
                }
              );
            })(e);
            return function (e) {
              var i = (function (e) {
                if (h.has(e)) return h.get(e);
                var t = new Map();
                return h.set(e, t), t;
              })(e);
              e.addEventListener("message", function (e) {
                var t = e.data,
                  r = t.id;
                if (null !== r && i.has(r)) {
                  var n = i.get(r),
                    o = n.reject,
                    s = n.resolve;
                  i.delete(r),
                    void 0 === t.error
                      ? s(t.result)
                      : o(new Error(t.error.message));
                }
              }),
                (function (e) {
                  return "function" == typeof e.start;
                })(e) && e.start();
              for (
                var o = function (t) {
                    var r =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : null,
                      o =
                        arguments.length > 2 && void 0 !== arguments[2]
                          ? arguments[2]
                          : [];
                    return new Promise(function (s, a) {
                      var l = n.generateUniqueNumber(i);
                      i.set(l, { reject: a, resolve: s }),
                        null === r
                          ? e.postMessage({ id: l, method: t }, o)
                          : e.postMessage({ id: l, method: t, params: r }, o);
                    });
                  },
                  s = function (t, r) {
                    var n =
                      arguments.length > 2 && void 0 !== arguments[2]
                        ? arguments[2]
                        : [];
                    e.postMessage({ id: null, method: t, params: r }, n);
                  },
                  l = {},
                  c = 0,
                  d = Object.entries(a);
                c < d.length;
                c++
              ) {
                var p = r(d[c], 2),
                  f = p[0],
                  m = p[1];
                l = u(u({}, l), {}, t({}, f, m({ call: o, notify: s })));
              }
              return u({}, l);
            };
          };
        }),
        "object" == typeof t && typeof r < "u"
          ? i(t, ep(), sp(), ap(), lp(), vp())
          : "function" == typeof define && e.amdO
          ? define(
              [
                "exports",
                "@babel/runtime/helpers/defineProperty",
                "@babel/runtime/helpers/slicedToArray",
                "fast-unique-numbers",
                "@babel/runtime/helpers/asyncToGenerator",
                "@babel/runtime/regenerator",
              ],
              i
            )
          : i(
              ((n =
                typeof globalThis < "u"
                  ? globalThis
                  : n || self).brokerFactory = {}),
              n._defineProperty,
              n._slicedToArray,
              n.fastUniqueNumbers,
              n._asyncToGenerator,
              n._regeneratorRuntime
            );
    }),
    bp = dc((t, r) => {
      var n, i;
      mc(),
        lh(),
        qu(),
        (n = t),
        (i = function (e, t, r, n) {
          var i = new Map([[0, null]]),
            o = new Map([[0, null]]),
            s = r.createBroker({
              clearInterval: function (e) {
                var r = e.call;
                return function (e) {
                  "symbol" === t(i.get(e)) &&
                    (i.set(e, null),
                    r("clear", { timerId: e, timerType: "interval" }).then(
                      function () {
                        i.delete(e);
                      }
                    ));
                };
              },
              clearTimeout: function (e) {
                var r = e.call;
                return function (e) {
                  "symbol" === t(o.get(e)) &&
                    (o.set(e, null),
                    r("clear", { timerId: e, timerType: "timeout" }).then(
                      function () {
                        o.delete(e);
                      }
                    ));
                };
              },
              setInterval: function (e) {
                var t = e.call;
                return function (e) {
                  for (
                    var r =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : 0,
                      o = arguments.length,
                      s = new Array(o > 2 ? o - 2 : 0),
                      a = 2;
                    a < o;
                    a++
                  )
                    s[a - 2] = arguments[a];
                  var l = Symbol(),
                    c = n.generateUniqueNumber(i);
                  i.set(c, l);
                  var u = function () {
                    return t("set", {
                      delay: r,
                      now: performance.timeOrigin + performance.now(),
                      timerId: c,
                      timerType: "interval",
                    }).then(function () {
                      var t = i.get(c);
                      if (void 0 === t)
                        throw new Error("The timer is in an undefined state.");
                      t === l && (e.apply(void 0, s), i.get(c) === l && u());
                    });
                  };
                  return u(), c;
                };
              },
              setTimeout: function (e) {
                var t = e.call;
                return function (e) {
                  for (
                    var r =
                        arguments.length > 1 && void 0 !== arguments[1]
                          ? arguments[1]
                          : 0,
                      i = arguments.length,
                      s = new Array(i > 2 ? i - 2 : 0),
                      a = 2;
                    a < i;
                    a++
                  )
                    s[a - 2] = arguments[a];
                  var l = Symbol(),
                    c = n.generateUniqueNumber(o);
                  return (
                    o.set(c, l),
                    t("set", {
                      delay: r,
                      now: performance.timeOrigin + performance.now(),
                      timerId: c,
                      timerType: "timeout",
                    }).then(function () {
                      var t = o.get(c);
                      if (void 0 === t)
                        throw new Error("The timer is in an undefined state.");
                      t === l && (o.delete(c), e.apply(void 0, s));
                    }),
                    c
                  );
                };
              },
            });
          (e.load = function (e) {
            var t = new Worker(e);
            return s(t);
          }),
            (e.wrap = s);
        }),
        "object" == typeof t && typeof r < "u"
          ? i(t, Qd(), yp(), ap())
          : "function" == typeof define && e.amdO
          ? define(
              [
                "exports",
                "@babel/runtime/helpers/typeof",
                "broker-factory",
                "fast-unique-numbers",
              ],
              i
            )
          : i(
              ((n =
                typeof globalThis < "u"
                  ? globalThis
                  : n || self).workerTimersBroker = {}),
              n._typeof,
              n.brokerFactory,
              n.fastUniqueNumbers
            );
    }),
    xp = dc((t, r) => {
      var n, i;
      mc(),
        lh(),
        qu(),
        (n = t),
        (i = function (e, t) {
          var r,
            n,
            i =
              ((r = t.load),
              (n = null),
              function () {
                if (null !== n) return n;
                var e = new Blob(
                    [
                      '(()=>{var e={45:(e,t,r)=>{var n=r(738).default;e.exports=function(e,t){if("object"!=n(e)||!e)return e;var r=e[Symbol.toPrimitive];if(void 0!==r){var o=r.call(e,t||"default");if("object"!=n(o))return o;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)},e.exports.__esModule=!0,e.exports.default=e.exports},79:e=>{e.exports=function(e,t){(null==t||t>e.length)&&(t=e.length);for(var r=0,n=Array(t);r<t;r++)n[r]=e[r];return n},e.exports.__esModule=!0,e.exports.default=e.exports},122:(e,t,r)=>{var n=r(79);e.exports=function(e,t){if(e){if("string"==typeof e)return n(e,t);var r={}.toString.call(e).slice(8,-1);return"Object"===r&&e.constructor&&(r=e.constructor.name),"Map"===r||"Set"===r?Array.from(e):"Arguments"===r||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)?n(e,t):void 0}},e.exports.__esModule=!0,e.exports.default=e.exports},156:e=>{e.exports=function(e,t){var r=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null!=r){var n,o,u,a,i=[],s=!0,c=!1;try{if(u=(r=r.call(e)).next,0===t){if(Object(r)!==r)return;s=!1}else for(;!(s=(n=u.call(r)).done)&&(i.push(n.value),i.length!==t);s=!0);}catch(e){c=!0,o=e}finally{try{if(!s&&null!=r.return&&(a=r.return(),Object(a)!==a))return}finally{if(c)throw o}}return i}},e.exports.__esModule=!0,e.exports.default=e.exports},172:e=>{e.exports=function(e,t){this.v=e,this.k=t},e.exports.__esModule=!0,e.exports.default=e.exports},293:e=>{function t(e,t,r,n,o,u,a){try{var i=e[u](a),s=i.value}catch(e){return void r(e)}i.done?t(s):Promise.resolve(s).then(n,o)}e.exports=function(e){return function(){var r=this,n=arguments;return new Promise((function(o,u){var a=e.apply(r,n);function i(e){t(a,o,u,i,s,"next",e)}function s(e){t(a,o,u,i,s,"throw",e)}i(void 0)}))}},e.exports.__esModule=!0,e.exports.default=e.exports},373:e=>{e.exports=function(e){var t=Object(e),r=[];for(var n in t)r.unshift(n);return function e(){for(;r.length;)if((n=r.pop())in t)return e.value=n,e.done=!1,e;return e.done=!0,e}},e.exports.__esModule=!0,e.exports.default=e.exports},389:function(e,t){!function(e){"use strict";var t=function(e){return function(t){var r=e(t);return t.add(r),r}},r=function(e){return function(t,r){return e.set(t,r),r}},n=void 0===Number.MAX_SAFE_INTEGER?9007199254740991:Number.MAX_SAFE_INTEGER,o=536870912,u=2*o,a=function(e,t){return function(r){var a=t.get(r),i=void 0===a?r.size:a<u?a+1:0;if(!r.has(i))return e(r,i);if(r.size<o){for(;r.has(i);)i=Math.floor(Math.random()*u);return e(r,i)}if(r.size>n)throw new Error("Congratulations, you created a collection of unique numbers which uses all available integers!");for(;r.has(i);)i=Math.floor(Math.random()*n);return e(r,i)}},i=new WeakMap,s=r(i),c=a(s,i),f=t(c);e.addUniqueNumber=f,e.generateUniqueNumber=c}(t)},472:function(e,t,r){!function(e,t,r,n){"use strict";var o=function(e,t){return function(r){var o=t.get(r);if(void 0===o)return Promise.resolve(!1);var u=n(o,2),a=u[0],i=u[1];return e(a),t.delete(r),i(!1),Promise.resolve(!0)}},u=function(e,t){var r=function(n,o,u,a){var i=n-e.now();i>0?o.set(a,[t(r,i,n,o,u,a),u]):(o.delete(a),u(!0))};return r},a=function(e,t,r,n){return function(o,u,a){var i=o+u-t.timeOrigin,s=i-t.now();return new Promise((function(t){e.set(a,[r(n,s,i,e,t,a),t])}))}},i=new Map,s=o(globalThis.clearTimeout,i),c=new Map,f=o(globalThis.clearTimeout,c),l=u(performance,globalThis.setTimeout),p=a(i,performance,globalThis.setTimeout,l),d=a(c,performance,globalThis.setTimeout,l);r.createWorker(self,{clear:function(){var r=e(t.mark((function e(r){var n,o,u;return t.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return n=r.timerId,o=r.timerType,e.next=1,"interval"===o?s(n):f(n);case 1:return u=e.sent,e.abrupt("return",{result:u});case 2:case"end":return e.stop()}}),e)})));function n(e){return r.apply(this,arguments)}return n}(),set:function(){var r=e(t.mark((function e(r){var n,o,u,a,i;return t.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return n=r.delay,o=r.now,u=r.timerId,a=r.timerType,e.next=1,("interval"===a?p:d)(n,o,u);case 1:return i=e.sent,e.abrupt("return",{result:i});case 2:case"end":return e.stop()}}),e)})));function n(e){return r.apply(this,arguments)}return n}()})}(r(293),r(756),r(623),r(715))},546:e=>{function t(r,n,o,u){var a=Object.defineProperty;try{a({},"",{})}catch(r){a=0}e.exports=t=function(e,r,n,o){if(r)a?a(e,r,{value:n,enumerable:!o,configurable:!o,writable:!o}):e[r]=n;else{var u=function(r,n){t(e,r,(function(e){return this._invoke(r,n,e)}))};u("next",0),u("throw",1),u("return",2)}},e.exports.__esModule=!0,e.exports.default=e.exports,t(r,n,o,u)}e.exports=t,e.exports.__esModule=!0,e.exports.default=e.exports},579:(e,t,r)=>{var n=r(738).default;e.exports=function(e){if(null!=e){var t=e["function"==typeof Symbol&&Symbol.iterator||"@@iterator"],r=0;if(t)return t.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length))return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}}}throw new TypeError(n(e)+" is not iterable")},e.exports.__esModule=!0,e.exports.default=e.exports},623:function(e,t,r){!function(e,t,r,n,o){"use strict";var u={INTERNAL_ERROR:-32603,INVALID_PARAMS:-32602,METHOD_NOT_FOUND:-32601},a=function(e,t){return Object.assign(new Error(e),{status:t})},i=function(e){return a(\'The requested method called "\'.concat(e,\'" is not supported.\'),u.METHOD_NOT_FOUND)},s=function(e){return a(\'The handler of the method called "\'.concat(e,\'" returned no required result.\'),u.INTERNAL_ERROR)},c=function(e){return a(\'The handler of the method called "\'.concat(e,\'" returned an unexpected result.\'),u.INTERNAL_ERROR)},f=function(e){return a(\'The specified parameter called "portId" with the given value "\'.concat(e,\'" does not identify a port connected to this worker.\'),u.INVALID_PARAMS)},l=function(e,n){return function(){var o=t(r.mark((function t(o){var u,a,f,l,p,d,v,x,y,b,h,m,_,g,w;return r.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(u=o.data,a=u.id,f=u.method,l=u.params,p=n[f],t.prev=1,void 0!==p){t.next=2;break}throw i(f);case 2:if(void 0!==(d=void 0===l?p():p(l))){t.next=3;break}throw s(f);case 3:if(!(d instanceof Promise)){t.next=5;break}return t.next=4,d;case 4:g=t.sent,t.next=6;break;case 5:g=d;case 6:if(v=g,null!==a){t.next=8;break}if(void 0===v.result){t.next=7;break}throw c(f);case 7:t.next=10;break;case 8:if(void 0!==v.result){t.next=9;break}throw c(f);case 9:x=v.result,y=v.transferables,b=void 0===y?[]:y,e.postMessage({id:a,result:x},b);case 10:t.next=12;break;case 11:t.prev=11,w=t.catch(1),h=w.message,m=w.status,_=void 0===m?-32603:m,e.postMessage({error:{code:_,message:h},id:a});case 12:case"end":return t.stop()}}),t,null,[[1,11]])})));return function(e){return o.apply(this,arguments)}}()},p=function(){return new Promise((function(e){var t=new ArrayBuffer(0),r=new MessageChannel,n=r.port1,o=r.port2;n.onmessage=function(t){var r=t.data;return e(null!==r)},o.postMessage(t,[t])}))};function d(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function v(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?d(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):d(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}var x=new Map,y=function(e,n,u){return v(v({},n),{},{connect:function(t){var r=t.port;r.start();var u=e(r,n),a=o.generateUniqueNumber(x);return x.set(a,(function(){u(),r.close(),x.delete(a)})),{result:a}},disconnect:function(e){var t=e.portId,r=x.get(t);if(void 0===r)throw f(t);return r(),{result:null}},isSupported:function(){var e=t(r.mark((function e(){var t,n,o;return r.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=1,p();case 1:if(!e.sent){e.next=5;break}if(!((t=u())instanceof Promise)){e.next=3;break}return e.next=2,t;case 2:o=e.sent,e.next=4;break;case 3:o=t;case 4:return n=o,e.abrupt("return",{result:n});case 5:return e.abrupt("return",{result:!1});case 6:case"end":return e.stop()}}),e)})));function n(){return e.apply(this,arguments)}return n}()})},b=function(e,t){var r=y(b,t,arguments.length>2&&void 0!==arguments[2]?arguments[2]:function(){return!0}),n=l(e,r);return e.addEventListener("message",n),function(){return e.removeEventListener("message",n)}};e.createWorker=b,e.isSupported=p}(t,r(293),r(756),r(693),r(389))},633:(e,t,r)=>{var n=r(172),o=r(993),u=r(869),a=r(887),i=r(791),s=r(373),c=r(579);function f(){"use strict";var t=o(),r=t.m(f),l=(Object.getPrototypeOf?Object.getPrototypeOf(r):r.__proto__).constructor;function p(e){var t="function"==typeof e&&e.constructor;return!!t&&(t===l||"GeneratorFunction"===(t.displayName||t.name))}var d={throw:1,return:2,break:3,continue:3};function v(e){var t,r;return function(n){t||(t={stop:function(){return r(n.a,2)},catch:function(){return n.v},abrupt:function(e,t){return r(n.a,d[e],t)},delegateYield:function(e,o,u){return t.resultName=o,r(n.d,c(e),u)},finish:function(e){return r(n.f,e)}},r=function(e,r,o){n.p=t.prev,n.n=t.next;try{return e(r,o)}finally{t.next=n.n}}),t.resultName&&(t[t.resultName]=n.v,t.resultName=void 0),t.sent=n.v,t.next=n.n;try{return e.call(this,t)}finally{n.p=t.prev,n.n=t.next}}}return(e.exports=f=function(){return{wrap:function(e,r,n,o){return t.w(v(e),r,n,o&&o.reverse())},isGeneratorFunction:p,mark:t.m,awrap:function(e,t){return new n(e,t)},AsyncIterator:i,async:function(e,t,r,n,o){return(p(t)?a:u)(v(e),t,r,n,o)},keys:s,values:c}},e.exports.__esModule=!0,e.exports.default=e.exports)()}e.exports=f,e.exports.__esModule=!0,e.exports.default=e.exports},693:(e,t,r)=>{var n=r(736);e.exports=function(e,t,r){return(t=n(t))in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e},e.exports.__esModule=!0,e.exports.default=e.exports},715:(e,t,r)=>{var n=r(987),o=r(156),u=r(122),a=r(752);e.exports=function(e,t){return n(e)||o(e,t)||u(e,t)||a()},e.exports.__esModule=!0,e.exports.default=e.exports},736:(e,t,r)=>{var n=r(738).default,o=r(45);e.exports=function(e){var t=o(e,"string");return"symbol"==n(t)?t:t+""},e.exports.__esModule=!0,e.exports.default=e.exports},738:e=>{function t(r){return e.exports=t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},e.exports.__esModule=!0,e.exports.default=e.exports,t(r)}e.exports=t,e.exports.__esModule=!0,e.exports.default=e.exports},752:e=>{e.exports=function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")},e.exports.__esModule=!0,e.exports.default=e.exports},756:(e,t,r)=>{var n=r(633)();e.exports=n;try{regeneratorRuntime=n}catch(e){"object"==typeof globalThis?globalThis.regeneratorRuntime=n:Function("r","regeneratorRuntime = r")(n)}},791:(e,t,r)=>{var n=r(172),o=r(546);e.exports=function e(t,r){function u(e,o,a,i){try{var s=t[e](o),c=s.value;return c instanceof n?r.resolve(c.v).then((function(e){u("next",e,a,i)}),(function(e){u("throw",e,a,i)})):r.resolve(c).then((function(e){s.value=e,a(s)}),(function(e){return u("throw",e,a,i)}))}catch(e){i(e)}}var a;this.next||(o(e.prototype),o(e.prototype,"function"==typeof Symbol&&Symbol.asyncIterator||"@asyncIterator",(function(){return this}))),o(this,"_invoke",(function(e,t,n){function o(){return new r((function(t,r){u(e,n,t,r)}))}return a=a?a.then(o,o):o()}),!0)},e.exports.__esModule=!0,e.exports.default=e.exports},869:(e,t,r)=>{var n=r(887);e.exports=function(e,t,r,o,u){var a=n(e,t,r,o,u);return a.next().then((function(e){return e.done?e.value:a.next()}))},e.exports.__esModule=!0,e.exports.default=e.exports},887:(e,t,r)=>{var n=r(993),o=r(791);e.exports=function(e,t,r,u,a){return new o(n().w(e,t,r,u),a||Promise)},e.exports.__esModule=!0,e.exports.default=e.exports},987:e=>{e.exports=function(e){if(Array.isArray(e))return e},e.exports.__esModule=!0,e.exports.default=e.exports},993:(e,t,r)=>{var n=r(546);function o(){var t,r,u="function"==typeof Symbol?Symbol:{},a=u.iterator||"@@iterator",i=u.toStringTag||"@@toStringTag";function s(e,o,u,a){var i=o&&o.prototype instanceof f?o:f,s=Object.create(i.prototype);return n(s,"_invoke",function(e,n,o){var u,a,i,s=0,f=o||[],l=!1,p={p:0,n:0,v:t,a:d,f:d.bind(t,4),d:function(e,r){return u=e,a=0,i=t,p.n=r,c}};function d(e,n){for(a=e,i=n,r=0;!l&&s&&!o&&r<f.length;r++){var o,u=f[r],d=p.p,v=u[2];e>3?(o=v===n)&&(i=u[(a=u[4])?5:(a=3,3)],u[4]=u[5]=t):u[0]<=d&&((o=e<2&&d<u[1])?(a=0,p.v=n,p.n=u[1]):d<v&&(o=e<3||u[0]>n||n>v)&&(u[4]=e,u[5]=n,p.n=v,a=0))}if(o||e>1)return c;throw l=!0,n}return function(o,f,v){if(s>1)throw TypeError("Generator is already running");for(l&&1===f&&d(f,v),a=f,i=v;(r=a<2?t:i)||!l;){u||(a?a<3?(a>1&&(p.n=-1),d(a,i)):p.n=i:p.v=i);try{if(s=2,u){if(a||(o="next"),r=u[o]){if(!(r=r.call(u,i)))throw TypeError("iterator result is not an object");if(!r.done)return r;i=r.value,a<2&&(a=0)}else 1===a&&(r=u.return)&&r.call(u),a<2&&(i=TypeError("The iterator does not provide a \'"+o+"\' method"),a=1);u=t}else if((r=(l=p.n<0)?i:e.call(n,p))!==c)break}catch(e){u=t,a=1,i=e}finally{s=1}}return{value:r,done:l}}}(e,u,a),!0),s}var c={};function f(){}function l(){}function p(){}r=Object.getPrototypeOf;var d=[][a]?r(r([][a]())):(n(r={},a,(function(){return this})),r),v=p.prototype=f.prototype=Object.create(d);function x(e){return Object.setPrototypeOf?Object.setPrototypeOf(e,p):(e.__proto__=p,n(e,i,"GeneratorFunction")),e.prototype=Object.create(v),e}return l.prototype=p,n(v,"constructor",p),n(p,"constructor",l),l.displayName="GeneratorFunction",n(p,i,"GeneratorFunction"),n(v),n(v,i,"Generator"),n(v,a,(function(){return this})),n(v,"toString",(function(){return"[object Generator]"})),(e.exports=o=function(){return{w:s,m:x}},e.exports.__esModule=!0,e.exports.default=e.exports)()}e.exports=o,e.exports.__esModule=!0,e.exports.default=e.exports}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var u=t[n]={exports:{}};return e[n].call(u.exports,u,u.exports,r),u.exports}r.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return r.d(t,{a:t}),t},r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{"use strict";r(472)})()})();',
                    ],
                    { type: "application/javascript; charset=utf-8" }
                  ),
                  t = URL.createObjectURL(e);
                return (
                  (n = r(t)),
                  setTimeout(function () {
                    return URL.revokeObjectURL(t);
                  }),
                  n
                );
              });
          (e.clearInterval = function (e) {
            return i().clearInterval(e);
          }),
            (e.clearTimeout = function (e) {
              return i().clearTimeout(e);
            }),
            (e.setInterval = function () {
              var e;
              return (e = i()).setInterval.apply(e, arguments);
            }),
            (e.setTimeout = function () {
              var e;
              return (e = i()).setTimeout.apply(e, arguments);
            });
        }),
        "object" == typeof t && typeof r < "u"
          ? i(t, bp())
          : "function" == typeof define && e.amdO
          ? define(["exports", "worker-timers-broker"], i)
          : i(
              ((n =
                typeof globalThis < "u" ? globalThis : n || self).workerTimers =
                {}),
              n.workerTimersBroker
            );
    }),
    wp = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "__esModule", { value: !0 }),
        (e.isReactNativeBrowser = e.isWebWorker = void 0);
      var t = () =>
          !!(
            "object" == typeof self &&
            self?.constructor?.name?.includes("WorkerGlobalScope") &&
            typeof Deno > "u"
          ),
        r = () => typeof navigator < "u" && "ReactNative" === navigator.product,
        n =
          (typeof window < "u" &&
            (typeof navigator < "u" &&
            navigator.userAgent?.toLowerCase().indexOf(" electron/") > -1 &&
            gc?.versions
              ? !Object.prototype.hasOwnProperty.call(gc.versions, "electron")
              : typeof window.document < "u")) ||
          t() ||
          r();
      (e.isWebWorker = t()), (e.isReactNativeBrowser = r()), (e.default = n);
    }),
    Sp = dc((e) => {
      mc(), lh(), qu();
      var t,
        r =
          (e && e.__createBinding) ||
          (Object.create
            ? function (e, t, r, n) {
                void 0 === n && (n = r);
                var i = Object.getOwnPropertyDescriptor(t, r);
                (!i ||
                  ("get" in i
                    ? !t.__esModule
                    : i.writable || i.configurable)) &&
                  (i = {
                    enumerable: !0,
                    get: function () {
                      return t[r];
                    },
                  }),
                  Object.defineProperty(e, n, i);
              }
            : function (e, t, r, n) {
                void 0 === n && (n = r), (e[n] = t[r]);
              }),
        n =
          (e && e.__setModuleDefault) ||
          (Object.create
            ? function (e, t) {
                Object.defineProperty(e, "default", {
                  enumerable: !0,
                  value: t,
                });
              }
            : function (e, t) {
                e.default = t;
              }),
        i =
          (e && e.__importStar) ||
          ((t = function (e) {
            return (t =
              Object.getOwnPropertyNames ||
              function (e) {
                var t = [];
                for (var r in e)
                  Object.prototype.hasOwnProperty.call(e, r) &&
                    (t[t.length] = r);
                return t;
              })(e);
          }),
          function (e) {
            if (e && e.__esModule) return e;
            var i = {};
            if (null != e)
              for (var o = t(e), s = 0; s < o.length; s++)
                "default" !== o[s] && r(i, e, o[s]);
            return n(i, e), i;
          });
      Object.defineProperty(e, "__esModule", { value: !0 });
      var o = xp(),
        s = i(wp()),
        a = { set: o.setInterval, clear: o.clearInterval },
        l = {
          set: (e, t) => setInterval(e, t),
          clear: (e) => clearInterval(e),
        };
      e.default = (e) => {
        switch (e) {
          case "native":
            return l;
          case "worker":
            return a;
          default:
            return !s.default || s.isWebWorker || s.isReactNativeBrowser
              ? l
              : a;
        }
      };
    }),
    Ep = dc((e) => {
      mc(), lh(), qu();
      var t =
        (e && e.__importDefault) ||
        function (e) {
          return e && e.__esModule ? e : { default: e };
        };
      Object.defineProperty(e, "__esModule", { value: !0 });
      var r = t(Sp());
      e.default = class {
        _keepalive;
        timerId;
        timer;
        destroyed = !1;
        counter;
        client;
        _keepaliveTimeoutTimestamp;
        _intervalEvery;
        get keepaliveTimeoutTimestamp() {
          return this._keepaliveTimeoutTimestamp;
        }
        get intervalEvery() {
          return this._intervalEvery;
        }
        get keepalive() {
          return this._keepalive;
        }
        constructor(e, t) {
          (this.client = e),
            (this.timer =
              "object" == typeof t && "set" in t && "clear" in t
                ? t
                : (0, r.default)(t)),
            this.setKeepalive(e.options.keepalive);
        }
        clear() {
          this.timerId &&
            (this.timer.clear(this.timerId), (this.timerId = null));
        }
        setKeepalive(e) {
          if (((e *= 1e3), isNaN(e) || e <= 0 || e > 2147483647))
            throw new Error(
              `Keepalive value must be an integer between 0 and 2147483647. Provided value is ${e}`
            );
          (this._keepalive = e),
            this.reschedule(),
            this.client.log(`KeepaliveManager: set keepalive to ${e}ms`);
        }
        destroy() {
          this.clear(), (this.destroyed = !0);
        }
        reschedule() {
          if (this.destroyed) return;
          this.clear(), (this.counter = 0);
          let e = Math.ceil(1.5 * this._keepalive);
          (this._keepaliveTimeoutTimestamp = Date.now() + e),
            (this._intervalEvery = Math.ceil(this._keepalive / 2)),
            (this.timerId = this.timer.set(() => {
              this.destroyed ||
                ((this.counter += 1),
                2 === this.counter
                  ? this.client.sendPing()
                  : this.counter > 2 && this.client.onKeepaliveTimeout());
            }, this._intervalEvery));
        }
      };
    }),
    Mp = dc((e) => {
      mc(), lh(), qu();
      var t,
        r =
          (e && e.__createBinding) ||
          (Object.create
            ? function (e, t, r, n) {
                void 0 === n && (n = r);
                var i = Object.getOwnPropertyDescriptor(t, r);
                (!i ||
                  ("get" in i
                    ? !t.__esModule
                    : i.writable || i.configurable)) &&
                  (i = {
                    enumerable: !0,
                    get: function () {
                      return t[r];
                    },
                  }),
                  Object.defineProperty(e, n, i);
              }
            : function (e, t, r, n) {
                void 0 === n && (n = r), (e[n] = t[r]);
              }),
        n =
          (e && e.__setModuleDefault) ||
          (Object.create
            ? function (e, t) {
                Object.defineProperty(e, "default", {
                  enumerable: !0,
                  value: t,
                });
              }
            : function (e, t) {
                e.default = t;
              }),
        i =
          (e && e.__importStar) ||
          ((t = function (e) {
            return (t =
              Object.getOwnPropertyNames ||
              function (e) {
                var t = [];
                for (var r in e)
                  Object.prototype.hasOwnProperty.call(e, r) &&
                    (t[t.length] = r);
                return t;
              })(e);
          }),
          function (e) {
            if (e && e.__esModule) return e;
            var i = {};
            if (null != e)
              for (var o = t(e), s = 0; s < o.length; s++)
                "default" !== o[s] && r(i, e, o[s]);
            return n(i, e), i;
          }),
        o =
          (e && e.__importDefault) ||
          function (e) {
            return e && e.__esModule ? e : { default: e };
          };
      Object.defineProperty(e, "__esModule", { value: !0 });
      var s = o(hd()),
        a = Qh(),
        l = o(pd()),
        c = o(od()),
        u = i(fd()),
        h = o(md()),
        d = o(qd()),
        p = o(Yd()),
        f = o(Kd()),
        m = vd(),
        g = $d(),
        _ = o(Ep()),
        v = i(wp()),
        y =
          globalThis.setImmediate ||
          ((...e) => {
            let t = e.shift();
            (0, m.nextTick)(() => {
              t(...e);
            });
          }),
        b = {
          keepalive: 60,
          reschedulePings: !0,
          protocolId: "MQTT",
          protocolVersion: 4,
          reconnectPeriod: 1e3,
          connectTimeout: 3e4,
          clean: !0,
          resubscribe: !0,
          subscribeBatchSize: null,
          writeCache: !0,
          timerVariant: "auto",
        },
        x = class e extends g.TypedEventEmitter {
          static VERSION = m.MQTTJS_VERSION;
          connected;
          disconnecting;
          disconnected;
          reconnecting;
          incomingStore;
          outgoingStore;
          options;
          queueQoSZero;
          _reconnectCount;
          log;
          messageIdProvider;
          outgoing;
          messageIdToTopic;
          noop;
          keepaliveManager;
          stream;
          queue;
          streamBuilder;
          _resubscribeTopics;
          connackTimer;
          reconnectTimer;
          _storeProcessing;
          _packetIdsDuringStoreProcessing;
          _storeProcessingQueue;
          _firstConnection;
          topicAliasRecv;
          topicAliasSend;
          _deferredReconnect;
          connackPacket;
          static defaultId() {
            return `mqttjs_${Math.random().toString(16).substr(2, 8)}`;
          }
          constructor(t, r) {
            super(), (this.options = r || {});
            for (let e in b)
              typeof this.options[e] > "u"
                ? (this.options[e] = b[e])
                : (this.options[e] = r[e]);
            (this.log = this.options.log || (0, c.default)("mqttjs:client")),
              (this.noop = this._noop.bind(this)),
              this.log("MqttClient :: version:", e.VERSION),
              v.isWebWorker
                ? this.log("MqttClient :: environment", "webworker")
                : this.log(
                    "MqttClient :: environment",
                    v.default ? "browser" : "node"
                  ),
              this.log("MqttClient :: options.protocol", r.protocol),
              this.log(
                "MqttClient :: options.protocolVersion",
                r.protocolVersion
              ),
              this.log("MqttClient :: options.username", r.username),
              this.log("MqttClient :: options.keepalive", r.keepalive),
              this.log(
                "MqttClient :: options.reconnectPeriod",
                r.reconnectPeriod
              ),
              this.log(
                "MqttClient :: options.rejectUnauthorized",
                r.rejectUnauthorized
              ),
              this.log(
                "MqttClient :: options.properties.topicAliasMaximum",
                r.properties ? r.properties.topicAliasMaximum : void 0
              ),
              (this.options.clientId =
                "string" == typeof r.clientId ? r.clientId : e.defaultId()),
              this.log("MqttClient :: clientId", this.options.clientId),
              (this.options.customHandleAcks =
                5 === r.protocolVersion && r.customHandleAcks
                  ? r.customHandleAcks
                  : (...e) => {
                      e[3](null, 0);
                    }),
              this.options.writeCache ||
                (s.default.writeToStream.cacheNumbers = !1),
              (this.streamBuilder = t),
              (this.messageIdProvider =
                typeof this.options.messageIdProvider > "u"
                  ? new p.default()
                  : this.options.messageIdProvider),
              (this.outgoingStore = r.outgoingStore || new h.default()),
              (this.incomingStore = r.incomingStore || new h.default()),
              (this.queueQoSZero = void 0 === r.queueQoSZero || r.queueQoSZero),
              (this._resubscribeTopics = {}),
              (this.messageIdToTopic = {}),
              (this.keepaliveManager = null),
              (this.connected = !1),
              (this.disconnecting = !1),
              (this.reconnecting = !1),
              (this.queue = []),
              (this.connackTimer = null),
              (this.reconnectTimer = null),
              (this._storeProcessing = !1),
              (this._packetIdsDuringStoreProcessing = {}),
              (this._storeProcessingQueue = []),
              (this.outgoing = {}),
              (this._firstConnection = !0),
              r.properties &&
                r.properties.topicAliasMaximum > 0 &&
                (r.properties.topicAliasMaximum > 65535
                  ? this.log(
                      "MqttClient :: options.properties.topicAliasMaximum is out of range"
                    )
                  : (this.topicAliasRecv = new f.default(
                      r.properties.topicAliasMaximum
                    ))),
              this.on("connect", () => {
                let { queue: e } = this,
                  t = () => {
                    let r = e.shift();
                    this.log("deliver :: entry %o", r);
                    let n = null;
                    if (!r) return void this._resubscribe();
                    (n = r.packet),
                      this.log("deliver :: call _sendPacket for %o", n);
                    let i = !0;
                    n.messageId &&
                      0 !== n.messageId &&
                      (this.messageIdProvider.register(n.messageId) ||
                        (i = !1)),
                      i
                        ? this._sendPacket(n, (e) => {
                            r.cb && r.cb(e), t();
                          })
                        : (this.log(
                            "messageId: %d has already used. The message is skipped and removed.",
                            n.messageId
                          ),
                          t());
                  };
                this.log("connect :: sending queued packets"), t();
              }),
              this.on("close", () => {
                this.log("close :: connected set to `false`"),
                  (this.connected = !1),
                  this.log("close :: clearing connackTimer"),
                  clearTimeout(this.connackTimer),
                  this._destroyKeepaliveManager(),
                  this.topicAliasRecv && this.topicAliasRecv.clear(),
                  this.log("close :: calling _setupReconnect"),
                  this._setupReconnect();
              }),
              this.options.manualConnect ||
                (this.log("MqttClient :: setting up stream"), this.connect());
          }
          handleAuth(e, t) {
            t();
          }
          handleMessage(e, t) {
            t();
          }
          _nextId() {
            return this.messageIdProvider.allocate();
          }
          getLastMessageId() {
            return this.messageIdProvider.getLastAllocated();
          }
          connect() {
            let e = new a.Writable(),
              t = s.default.parser(this.options),
              r = null,
              n = [];
            this.log("connect :: calling method to clear reconnect"),
              this._clearReconnect(),
              this.disconnected &&
                !this.reconnecting &&
                ((this.incomingStore =
                  this.options.incomingStore || new h.default()),
                (this.outgoingStore =
                  this.options.outgoingStore || new h.default()),
                (this.disconnecting = !1),
                (this.disconnected = !1)),
              this.log(
                "connect :: using streamBuilder provided to client to create stream"
              ),
              (this.stream = this.streamBuilder(this)),
              t.on("packet", (e) => {
                this.log("parser :: on packet push to packets array."),
                  n.push(e);
              });
            let i = () => {
                this.log("work :: getting next packet in queue");
                let e = n.shift();
                if (e)
                  this.log("work :: packet pulled from queue"),
                    (0, d.default)(this, e, o);
                else {
                  this.log("work :: no packets in queue");
                  let e = r;
                  (r = null),
                    this.log("work :: done flag is %s", !!e),
                    e && e();
                }
              },
              o = () => {
                if (n.length) (0, m.nextTick)(i);
                else {
                  let e = r;
                  (r = null), e();
                }
              };
            (e._write = (e, n, o) => {
              (r = o),
                this.log("writable stream :: parsing buffer"),
                t.parse(e),
                i();
            }),
              this.log("connect :: pipe stream to writable stream"),
              this.stream.pipe(e),
              this.stream.on("error", (e) => {
                this.log("streamErrorHandler :: error", e.message),
                  e.code
                    ? (this.log("streamErrorHandler :: emitting error"),
                      this.emit("error", e))
                    : this.noop(e);
              }),
              this.stream.on("close", () => {
                this.log("(%s)stream :: on close", this.options.clientId),
                  this._flushVolatile(),
                  this.log("stream: emit close to MqttClient"),
                  this.emit("close");
              }),
              this.log("connect: sending packet `connect`");
            let l = {
              cmd: "connect",
              protocolId: this.options.protocolId,
              protocolVersion: this.options.protocolVersion,
              clean: this.options.clean,
              clientId: this.options.clientId,
              keepalive: this.options.keepalive,
              username: this.options.username,
              password: this.options.password,
              properties: this.options.properties,
            };
            if (
              (this.options.will &&
                (l.will = {
                  ...this.options.will,
                  payload: this.options.will?.payload,
                }),
              this.topicAliasRecv &&
                (l.properties || (l.properties = {}),
                this.topicAliasRecv &&
                  (l.properties.topicAliasMaximum = this.topicAliasRecv.max)),
              this._writePacket(l),
              t.on("error", this.emit.bind(this, "error")),
              this.options.properties)
            ) {
              if (
                !this.options.properties.authenticationMethod &&
                this.options.properties.authenticationData
              )
                return (
                  this.end(() =>
                    this.emit(
                      "error",
                      new Error("Packet has no Authentication Method")
                    )
                  ),
                  this
                );
              if (
                this.options.properties.authenticationMethod &&
                this.options.authPacket &&
                "object" == typeof this.options.authPacket
              ) {
                let e = {
                  cmd: "auth",
                  reasonCode: 0,
                  ...this.options.authPacket,
                };
                this._writePacket(e);
              }
            }
            return (
              this.stream.setMaxListeners(1e3),
              clearTimeout(this.connackTimer),
              (this.connackTimer = setTimeout(() => {
                this.log(
                  "!!connectTimeout hit!! Calling _cleanUp with force `true`"
                ),
                  this.emit("error", new Error("connack timeout")),
                  this._cleanUp(!0);
              }, this.options.connectTimeout)),
              this
            );
          }
          publish(e, t, r, n) {
            this.log("publish :: message `%s` to topic `%s`", t, e);
            let { options: i } = this;
            "function" == typeof r && ((n = r), (r = null)),
              (r = r || {}),
              (r = { qos: 0, retain: !1, dup: !1, ...r });
            let { qos: o, retain: s, dup: a, properties: l, cbStorePut: c } = r;
            if (this._checkDisconnecting(n)) return this;
            let u = () => {
              let r = 0;
              if ((1 === o || 2 === o) && ((r = this._nextId()), null === r))
                return this.log("No messageId left"), !1;
              let u = {
                cmd: "publish",
                topic: e,
                payload: t,
                qos: o,
                retain: s,
                messageId: r,
                dup: a,
              };
              switch (
                (5 === i.protocolVersion && (u.properties = l),
                this.log("publish :: qos", o),
                o)
              ) {
                case 1:
                case 2:
                  (this.outgoing[u.messageId] = {
                    volatile: !1,
                    cb: n || this.noop,
                  }),
                    this.log("MqttClient:publish: packet cmd: %s", u.cmd),
                    this._sendPacket(u, void 0, c);
                  break;
                default:
                  this.log("MqttClient:publish: packet cmd: %s", u.cmd),
                    this._sendPacket(u, n, c);
              }
              return !0;
            };
            return (
              (this._storeProcessing ||
                this._storeProcessingQueue.length > 0 ||
                !u()) &&
                this._storeProcessingQueue.push({
                  invoke: u,
                  cbStorePut: r.cbStorePut,
                  callback: n,
                }),
              this
            );
          }
          publishAsync(e, t, r) {
            return new Promise((n, i) => {
              this.publish(e, t, r, (e, t) => {
                e ? i(e) : n(t);
              });
            });
          }
          subscribe(e, t, r) {
            let n = this.options.protocolVersion;
            "function" == typeof t && (r = t), (r = r || this.noop);
            let i = !1,
              o = [];
            "string" == typeof e
              ? (o = e = [e])
              : Array.isArray(e)
              ? (o = e)
              : "object" == typeof e &&
                ((i = e.resubscribe),
                delete e.resubscribe,
                (o = Object.keys(e)));
            let s = u.validateTopics(o);
            if (null !== s) return y(r, new Error(`Invalid topic ${s}`)), this;
            if (this._checkDisconnecting(r))
              return this.log("subscribe: discconecting true"), this;
            let a = { qos: 0 };
            5 === n && ((a.nl = !1), (a.rap = !1), (a.rh = 0)),
              (t = { ...a, ...t });
            let { properties: l } = t,
              c = [],
              h = (e, r) => {
                if (
                  ((r = r || t),
                  !Object.prototype.hasOwnProperty.call(
                    this._resubscribeTopics,
                    e
                  ) ||
                    this._resubscribeTopics[e].qos < r.qos ||
                    i)
                ) {
                  let t = { topic: e, qos: r.qos };
                  5 === n &&
                    ((t.nl = r.nl),
                    (t.rap = r.rap),
                    (t.rh = r.rh),
                    (t.properties = l)),
                    this.log(
                      "subscribe: pushing topic `%s` and qos `%s` to subs list",
                      t.topic,
                      t.qos
                    ),
                    c.push(t);
                }
              };
            if (
              (Array.isArray(e)
                ? e.forEach((e) => {
                    this.log("subscribe: array topic %s", e), h(e);
                  })
                : Object.keys(e).forEach((t) => {
                    this.log("subscribe: object topic %s, %o", t, e[t]),
                      h(t, e[t]);
                  }),
              !c.length)
            )
              return r(null, []), this;
            let d = (e, t) => {
                let r = { cmd: "subscribe", subscriptions: e, messageId: t };
                if ((l && (r.properties = l), this.options.resubscribe)) {
                  this.log("subscribe :: resubscribe true");
                  let t = [];
                  e.forEach((e) => {
                    if (this.options.reconnectPeriod > 0) {
                      let r = { qos: e.qos };
                      5 === n &&
                        ((r.nl = e.nl || !1),
                        (r.rap = e.rap || !1),
                        (r.rh = e.rh || 0),
                        (r.properties = e.properties)),
                        (this._resubscribeTopics[e.topic] = r),
                        t.push(e.topic);
                    }
                  }),
                    (this.messageIdToTopic[r.messageId] = t);
                }
                let i = new Promise((t, n) => {
                  this.outgoing[r.messageId] = {
                    volatile: !0,
                    cb(r, i) {
                      if (!r) {
                        let { granted: t } = i;
                        for (let r = 0; r < t.length; r += 1) e[r].qos = t[r];
                      }
                      r ? n(new m.ErrorWithSubackPacket(r.message, i)) : t(i);
                    },
                  };
                });
                return (
                  this.log("subscribe :: call _sendPacket"),
                  this._sendPacket(r),
                  i
                );
              },
              p = () => {
                let e = this.options.subscribeBatchSize ?? c.length,
                  t = [];
                for (let r = 0; r < c.length; r += e) {
                  let n = c.slice(r, r + e),
                    i = this._nextId();
                  if (null === i) return this.log("No messageId left"), !1;
                  t.push(d(n, i));
                }
                return (
                  Promise.all(t)
                    .then((e) => {
                      r(null, c, e.at(-1));
                    })
                    .catch((e) => {
                      r(e, c, e.packet);
                    }),
                  !0
                );
              };
            return (
              (this._storeProcessing ||
                this._storeProcessingQueue.length > 0 ||
                !p()) &&
                this._storeProcessingQueue.push({ invoke: p, callback: r }),
              this
            );
          }
          subscribeAsync(e, t) {
            return new Promise((r, n) => {
              this.subscribe(e, t, (e, t) => {
                e ? n(e) : r(t);
              });
            });
          }
          unsubscribe(e, t, r) {
            "string" == typeof e && (e = [e]),
              "function" == typeof t && (r = t),
              (r = r || this.noop);
            let n = u.validateTopics(e);
            if (null !== n) return y(r, new Error(`Invalid topic ${n}`)), this;
            if (this._checkDisconnecting(r)) return this;
            let i = () => {
              let n = this._nextId();
              if (null === n) return this.log("No messageId left"), !1;
              let i = { cmd: "unsubscribe", messageId: n, unsubscriptions: [] };
              return (
                "string" == typeof e
                  ? (i.unsubscriptions = [e])
                  : Array.isArray(e) && (i.unsubscriptions = e),
                this.options.resubscribe &&
                  i.unsubscriptions.forEach((e) => {
                    delete this._resubscribeTopics[e];
                  }),
                "object" == typeof t &&
                  t.properties &&
                  (i.properties = t.properties),
                (this.outgoing[i.messageId] = { volatile: !0, cb: r }),
                this.log("unsubscribe: call _sendPacket"),
                this._sendPacket(i),
                !0
              );
            };
            return (
              (this._storeProcessing ||
                this._storeProcessingQueue.length > 0 ||
                !i()) &&
                this._storeProcessingQueue.push({ invoke: i, callback: r }),
              this
            );
          }
          unsubscribeAsync(e, t) {
            return new Promise((r, n) => {
              this.unsubscribe(e, t, (e, t) => {
                e ? n(e) : r(t);
              });
            });
          }
          end(e, t, r) {
            this.log("end :: (%s)", this.options.clientId),
              (null == e || "boolean" != typeof e) &&
                ((r = r || t), (t = e), (e = !1)),
              "object" != typeof t && ((r = r || t), (t = null)),
              this.log("end :: cb? %s", !!r),
              (!r || "function" != typeof r) && (r = this.noop);
            let n = () => {
                this.log(
                  "end :: closeStores: closing incoming and outgoing stores"
                ),
                  (this.disconnected = !0),
                  this.incomingStore.close((e) => {
                    this.outgoingStore.close((t) => {
                      if (
                        (this.log("end :: closeStores: emitting end"),
                        this.emit("end"),
                        r)
                      ) {
                        let n = e || t;
                        this.log(
                          "end :: closeStores: invoking callback with args"
                        ),
                          r(n);
                      }
                    });
                  }),
                  this._deferredReconnect
                    ? this._deferredReconnect()
                    : (0 === this.options.reconnectPeriod ||
                        this.options.manualConnect) &&
                      (this.disconnecting = !1);
              },
              i = () => {
                this.log(
                  "end :: (%s) :: finish :: calling _cleanUp with force %s",
                  this.options.clientId,
                  e
                ),
                  this._cleanUp(
                    e,
                    () => {
                      this.log(
                        "end :: finish :: calling process.nextTick on closeStores"
                      ),
                        (0, m.nextTick)(n);
                    },
                    t
                  );
              };
            return this.disconnecting
              ? (r(), this)
              : (this._clearReconnect(),
                (this.disconnecting = !0),
                !e && Object.keys(this.outgoing).length > 0
                  ? (this.log(
                      "end :: (%s) :: calling finish in 10ms once outgoing is empty",
                      this.options.clientId
                    ),
                    this.once("outgoingEmpty", setTimeout.bind(null, i, 10)))
                  : (this.log(
                      "end :: (%s) :: immediately calling finish",
                      this.options.clientId
                    ),
                    i()),
                this);
          }
          endAsync(e, t) {
            return new Promise((r, n) => {
              this.end(e, t, (e) => {
                e ? n(e) : r();
              });
            });
          }
          removeOutgoingMessage(e) {
            if (this.outgoing[e]) {
              let { cb: t } = this.outgoing[e];
              this._removeOutgoingAndStoreMessage(e, () => {
                t(new Error("Message removed"));
              });
            }
            return this;
          }
          reconnect(e) {
            this.log("client reconnect");
            let t = () => {
              e
                ? ((this.options.incomingStore = e.incomingStore),
                  (this.options.outgoingStore = e.outgoingStore))
                : ((this.options.incomingStore = null),
                  (this.options.outgoingStore = null)),
                (this.incomingStore =
                  this.options.incomingStore || new h.default()),
                (this.outgoingStore =
                  this.options.outgoingStore || new h.default()),
                (this.disconnecting = !1),
                (this.disconnected = !1),
                (this._deferredReconnect = null),
                this._reconnect();
            };
            return (
              this.disconnecting && !this.disconnected
                ? (this._deferredReconnect = t)
                : t(),
              this
            );
          }
          _flushVolatile() {
            this.outgoing &&
              (this.log(
                "_flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function"
              ),
              Object.keys(this.outgoing).forEach((e) => {
                this.outgoing[e].volatile &&
                  "function" == typeof this.outgoing[e].cb &&
                  (this.outgoing[e].cb(new Error("Connection closed")),
                  delete this.outgoing[e]);
              }));
          }
          _flush() {
            this.outgoing &&
              (this.log("_flush: queue exists? %b", !!this.outgoing),
              Object.keys(this.outgoing).forEach((e) => {
                "function" == typeof this.outgoing[e].cb &&
                  (this.outgoing[e].cb(new Error("Connection closed")),
                  delete this.outgoing[e]);
              }));
          }
          _removeTopicAliasAndRecoverTopicName(e) {
            let t;
            e.properties && (t = e.properties.topicAlias);
            let r = e.topic.toString();
            if (
              (this.log(
                "_removeTopicAliasAndRecoverTopicName :: alias %d, topic %o",
                t,
                r
              ),
              0 === r.length)
            ) {
              if (typeof t > "u") return new Error("Unregistered Topic Alias");
              if (
                ((r = this.topicAliasSend.getTopicByAlias(t)), typeof r > "u")
              )
                return new Error("Unregistered Topic Alias");
              e.topic = r;
            }
            t && delete e.properties.topicAlias;
          }
          _checkDisconnecting(e) {
            return (
              this.disconnecting &&
                (e && e !== this.noop
                  ? e(new Error("client disconnecting"))
                  : this.emit("error", new Error("client disconnecting"))),
              this.disconnecting
            );
          }
          _reconnect() {
            this.log("_reconnect: emitting reconnect to client"),
              this.emit("reconnect"),
              this.connected
                ? (this.end(() => {
                    this.connect();
                  }),
                  this.log("client already connected. disconnecting first."))
                : (this.log("_reconnect: calling connect"), this.connect());
          }
          _setupReconnect() {
            !this.disconnecting &&
            !this.reconnectTimer &&
            this.options.reconnectPeriod > 0
              ? (this.reconnecting ||
                  (this.log("_setupReconnect :: emit `offline` state"),
                  this.emit("offline"),
                  this.log("_setupReconnect :: set `reconnecting` to `true`"),
                  (this.reconnecting = !0)),
                this.log(
                  "_setupReconnect :: setting reconnectTimer for %d ms",
                  this.options.reconnectPeriod
                ),
                (this.reconnectTimer = setInterval(() => {
                  this.log("reconnectTimer :: reconnect triggered!"),
                    this._reconnect();
                }, this.options.reconnectPeriod)))
              : this.log("_setupReconnect :: doing nothing...");
          }
          _clearReconnect() {
            this.log("_clearReconnect : clearing reconnect timer"),
              this.reconnectTimer &&
                (clearInterval(this.reconnectTimer),
                (this.reconnectTimer = null));
          }
          _cleanUp(e, t, r = {}) {
            if (
              (t &&
                (this.log(
                  "_cleanUp :: done callback provided for on stream close"
                ),
                this.stream.on("close", t)),
              this.log("_cleanUp :: forced? %s", e),
              e)
            )
              0 === this.options.reconnectPeriod &&
                this.options.clean &&
                this._flush(),
                this.log(
                  "_cleanUp :: (%s) :: destroying stream",
                  this.options.clientId
                ),
                this.stream.destroy();
            else {
              let e = { cmd: "disconnect", ...r };
              this.log(
                "_cleanUp :: (%s) :: call _sendPacket with disconnect packet",
                this.options.clientId
              ),
                this._sendPacket(e, () => {
                  this.log(
                    "_cleanUp :: (%s) :: destroying stream",
                    this.options.clientId
                  ),
                    y(() => {
                      this.stream.end(() => {
                        this.log(
                          "_cleanUp :: (%s) :: stream destroyed",
                          this.options.clientId
                        );
                      });
                    });
                });
            }
            !this.disconnecting &&
              !this.reconnecting &&
              (this.log(
                "_cleanUp :: client not disconnecting/reconnecting. Clearing and resetting reconnect."
              ),
              this._clearReconnect(),
              this._setupReconnect()),
              this._destroyKeepaliveManager(),
              t &&
                !this.connected &&
                (this.log(
                  "_cleanUp :: (%s) :: removing stream `done` callback `close` listener",
                  this.options.clientId
                ),
                this.stream.removeListener("close", t),
                t());
          }
          _storeAndSend(e, t, r) {
            this.log(
              "storeAndSend :: store packet with cmd %s to outgoingStore",
              e.cmd
            );
            let n,
              i = e;
            if (
              "publish" === i.cmd &&
              ((i = (0, l.default)(e)),
              (n = this._removeTopicAliasAndRecoverTopicName(i)),
              n)
            )
              return t && t(n);
            this.outgoingStore.put(i, (n) => {
              if (n) return t && t(n);
              r(), this._writePacket(e, t);
            });
          }
          _applyTopicAlias(e) {
            if (5 === this.options.protocolVersion && "publish" === e.cmd) {
              let t;
              e.properties && (t = e.properties.topicAlias);
              let r = e.topic.toString();
              if (this.topicAliasSend)
                if (t) {
                  if (
                    0 !== r.length &&
                    (this.log(
                      "applyTopicAlias :: register topic: %s - alias: %d",
                      r,
                      t
                    ),
                    !this.topicAliasSend.put(r, t))
                  )
                    return (
                      this.log(
                        "applyTopicAlias :: error out of range. topic: %s - alias: %d",
                        r,
                        t
                      ),
                      new Error("Sending Topic Alias out of range")
                    );
                } else
                  0 !== r.length &&
                    (this.options.autoAssignTopicAlias
                      ? ((t = this.topicAliasSend.getAliasByTopic(r)),
                        t
                          ? ((e.topic = ""),
                            (e.properties = { ...e.properties, topicAlias: t }),
                            this.log(
                              "applyTopicAlias :: auto assign(use) topic: %s - alias: %d",
                              r,
                              t
                            ))
                          : ((t = this.topicAliasSend.getLruAlias()),
                            this.topicAliasSend.put(r, t),
                            (e.properties = { ...e.properties, topicAlias: t }),
                            this.log(
                              "applyTopicAlias :: auto assign topic: %s - alias: %d",
                              r,
                              t
                            )))
                      : this.options.autoUseTopicAlias &&
                        ((t = this.topicAliasSend.getAliasByTopic(r)),
                        t &&
                          ((e.topic = ""),
                          (e.properties = { ...e.properties, topicAlias: t }),
                          this.log(
                            "applyTopicAlias :: auto use topic: %s - alias: %d",
                            r,
                            t
                          ))));
              else if (t)
                return (
                  this.log(
                    "applyTopicAlias :: error out of range. topic: %s - alias: %d",
                    r,
                    t
                  ),
                  new Error("Sending Topic Alias out of range")
                );
            }
          }
          _noop(e) {
            this.log("noop ::", e);
          }
          _writePacket(e, t) {
            this.log("_writePacket :: packet: %O", e),
              this.log("_writePacket :: emitting `packetsend`"),
              this.emit("packetsend", e),
              this.log("_writePacket :: writing to stream");
            let r = s.default.writeToStream(e, this.stream, this.options);
            this.log("_writePacket :: writeToStream result %s", r),
              !r && t && t !== this.noop
                ? (this.log(
                    "_writePacket :: handle events on `drain` once through callback."
                  ),
                  this.stream.once("drain", t))
                : t && (this.log("_writePacket :: invoking cb"), t());
          }
          _sendPacket(e, t, r, n) {
            this.log("_sendPacket :: (%s) ::  start", this.options.clientId),
              (r = r || this.noop),
              (t = t || this.noop);
            let i = this._applyTopicAlias(e);
            if (i) t(i);
            else {
              if (!this.connected)
                return "auth" === e.cmd
                  ? void this._writePacket(e, t)
                  : (this.log(
                      "_sendPacket :: client not connected. Storing packet offline."
                    ),
                    void this._storePacket(e, t, r));
              if (n) this._writePacket(e, t);
              else {
                switch (e.cmd) {
                  case "publish":
                    break;
                  case "pubrel":
                    return void this._storeAndSend(e, t, r);
                  default:
                    return void this._writePacket(e, t);
                }
                switch (e.qos) {
                  case 2:
                  case 1:
                    this._storeAndSend(e, t, r);
                    break;
                  default:
                    this._writePacket(e, t);
                }
                this.log("_sendPacket :: (%s) ::  end", this.options.clientId);
              }
            }
          }
          _storePacket(e, t, r) {
            this.log("_storePacket :: packet: %o", e),
              this.log("_storePacket :: cb? %s", !!t),
              (r = r || this.noop);
            let n = e;
            if ("publish" === n.cmd) {
              n = (0, l.default)(e);
              let r = this._removeTopicAliasAndRecoverTopicName(n);
              if (r) return t && t(r);
            }
            let i = n.qos || 0;
            (0 === i && this.queueQoSZero) || "publish" !== n.cmd
              ? this.queue.push({ packet: n, cb: t })
              : i > 0
              ? ((t = this.outgoing[n.messageId]
                  ? this.outgoing[n.messageId].cb
                  : null),
                this.outgoingStore.put(n, (e) => {
                  if (e) return t && t(e);
                  r();
                }))
              : t && t(new Error("No connection to broker"));
          }
          _setupKeepaliveManager() {
            this.log(
              "_setupKeepaliveManager :: keepalive %d (seconds)",
              this.options.keepalive
            ),
              !this.keepaliveManager &&
                this.options.keepalive &&
                (this.keepaliveManager = new _.default(
                  this,
                  this.options.timerVariant
                ));
          }
          _destroyKeepaliveManager() {
            this.keepaliveManager &&
              (this.log(
                "_destroyKeepaliveManager :: destroying keepalive manager"
              ),
              this.keepaliveManager.destroy(),
              (this.keepaliveManager = null));
          }
          reschedulePing(e = !1) {
            this.keepaliveManager &&
              this.options.keepalive &&
              (e || this.options.reschedulePings) &&
              this._reschedulePing();
          }
          _reschedulePing() {
            this.log("_reschedulePing :: rescheduling ping"),
              this.keepaliveManager.reschedule();
          }
          sendPing() {
            this.log("_sendPing :: sending pingreq"),
              this._sendPacket({ cmd: "pingreq" });
          }
          onKeepaliveTimeout() {
            this.emit("error", new Error("Keepalive timeout")),
              this.log(
                "onKeepaliveTimeout :: calling _cleanUp with force true"
              ),
              this._cleanUp(!0);
          }
          _resubscribe() {
            this.log("_resubscribe");
            let e = Object.keys(this._resubscribeTopics);
            if (
              !this._firstConnection &&
              (this.options.clean ||
                (this.options.protocolVersion >= 4 &&
                  !this.connackPacket.sessionPresent)) &&
              e.length > 0
            )
              if (this.options.resubscribe)
                if (5 === this.options.protocolVersion) {
                  this.log("_resubscribe: protocolVersion 5");
                  for (let t = 0; t < e.length; t++) {
                    let r = {};
                    (r[e[t]] = this._resubscribeTopics[e[t]]),
                      (r.resubscribe = !0),
                      this.subscribe(r, { properties: r[e[t]].properties });
                  }
                } else
                  (this._resubscribeTopics.resubscribe = !0),
                    this.subscribe(this._resubscribeTopics);
              else this._resubscribeTopics = {};
            this._firstConnection = !1;
          }
          _onConnect(e) {
            if (this.disconnected) return void this.emit("connect", e);
            (this.connackPacket = e),
              this.messageIdProvider.clear(),
              this._setupKeepaliveManager(),
              (this.connected = !0);
            let t = () => {
              let r = this.outgoingStore.createStream(),
                n = () => {
                  r.destroy(),
                    (r = null),
                    this._flushStoreProcessingQueue(),
                    i();
                },
                i = () => {
                  (this._storeProcessing = !1),
                    (this._packetIdsDuringStoreProcessing = {});
                };
              this.once("close", n),
                r.on("error", (e) => {
                  i(),
                    this._flushStoreProcessingQueue(),
                    this.removeListener("close", n),
                    this.emit("error", e);
                });
              let o = () => {
                if (!r) return;
                let e,
                  t = r.read(1);
                t
                  ? ((this._storeProcessing = !0),
                    this._packetIdsDuringStoreProcessing[t.messageId]
                      ? o()
                      : this.disconnecting || this.reconnectTimer
                      ? r.destroy && r.destroy()
                      : ((e = this.outgoing[t.messageId]
                          ? this.outgoing[t.messageId].cb
                          : null),
                        (this.outgoing[t.messageId] = {
                          volatile: !1,
                          cb(t, r) {
                            e && e(t, r), o();
                          },
                        }),
                        (this._packetIdsDuringStoreProcessing[t.messageId] =
                          !0),
                        this.messageIdProvider.register(t.messageId)
                          ? this._sendPacket(t, void 0, void 0, !0)
                          : this.log(
                              "messageId: %d has already used.",
                              t.messageId
                            )))
                  : r.once("readable", o);
              };
              r.on("end", () => {
                let r = !0;
                for (let e in this._packetIdsDuringStoreProcessing)
                  if (!this._packetIdsDuringStoreProcessing[e]) {
                    r = !1;
                    break;
                  }
                this.removeListener("close", n),
                  r
                    ? (i(),
                      this._invokeAllStoreProcessingQueue(),
                      this.emit("connect", e))
                    : t();
              }),
                o();
            };
            t();
          }
          _invokeStoreProcessingQueue() {
            if (
              !this._storeProcessing &&
              this._storeProcessingQueue.length > 0
            ) {
              let e = this._storeProcessingQueue[0];
              if (e && e.invoke())
                return this._storeProcessingQueue.shift(), !0;
            }
            return !1;
          }
          _invokeAllStoreProcessingQueue() {
            for (; this._invokeStoreProcessingQueue(); );
          }
          _flushStoreProcessingQueue() {
            for (let e of this._storeProcessingQueue)
              e.cbStorePut && e.cbStorePut(new Error("Connection closed")),
                e.callback && e.callback(new Error("Connection closed"));
            this._storeProcessingQueue.splice(0);
          }
          _removeOutgoingAndStoreMessage(e, t) {
            delete this.outgoing[e],
              this.outgoingStore.del({ messageId: e }, (r, n) => {
                t(r, n),
                  this.messageIdProvider.deallocate(e),
                  this._invokeStoreProcessingQueue();
              });
          }
        };
      e.default = x;
    }),
    Tp = dc((e) => {
      mc(), lh(), qu(), Object.defineProperty(e, "__esModule", { value: !0 });
      var t = jd();
      e.default = class {
        numberAllocator;
        lastId;
        constructor() {
          this.numberAllocator = new t.NumberAllocator(1, 65535);
        }
        allocate() {
          return (this.lastId = this.numberAllocator.alloc()), this.lastId;
        }
        getLastAllocated() {
          return this.lastId;
        }
        register(e) {
          return this.numberAllocator.use(e);
        }
        deallocate(e) {
          this.numberAllocator.free(e);
        }
        clear() {
          this.numberAllocator.clear();
        }
      };
    }),
    Ap = hc(() => {
      mc(),
        lh(),
        qu(),
        (Sh = {}),
        (Eh = !1),
        (Mh = (function () {
          if (Eh) return Sh;
          Eh = !0;
          let e = 2147483647,
            t = 36,
            r = /^xn--/,
            n = /[^\0-\x7F]/,
            i = /[\x2E\u3002\uFF0E\uFF61]/g,
            o = {
              overflow: "Overflow: input needs wider integers to process",
              "not-basic": "Illegal input >= 0x80 (not a basic code point)",
              "invalid-input": "Invalid input",
            },
            s = Math.floor,
            a = String.fromCharCode;
          function l(e) {
            throw new RangeError(o[e]);
          }
          function c(e, t) {
            let r = e.split("@"),
              n = "";
            r.length > 1 && ((n = r[0] + "@"), (e = r[1]));
            let o = (function (e, t) {
              let r = [],
                n = e.length;
              for (; n--; ) r[n] = t(e[n]);
              return r;
            })((e = e.replace(i, ".")).split("."), t).join(".");
            return n + o;
          }
          function u(e) {
            let t = [],
              r = 0,
              n = e.length;
            for (; r < n; ) {
              let i = e.charCodeAt(r++);
              if (i >= 55296 && i <= 56319 && r < n) {
                let n = e.charCodeAt(r++);
                56320 == (64512 & n)
                  ? t.push(((1023 & i) << 10) + (1023 & n) + 65536)
                  : (t.push(i), r--);
              } else t.push(i);
            }
            return t;
          }
          let h = function (e) {
              return e >= 48 && e < 58
                ? e - 48 + 26
                : e >= 65 && e < 91
                ? e - 65
                : e >= 97 && e < 123
                ? e - 97
                : t;
            },
            d = function (e, t) {
              return e + 22 + 75 * (e < 26) - ((0 != t) << 5);
            },
            p = function (e, r, n) {
              let i = 0;
              for (e = n ? s(e / 700) : e >> 1, e += s(e / r); e > 455; i += t)
                e = s(e / 35);
              return s(i + (36 * e) / (e + 38));
            },
            f = function (r) {
              let n = [],
                i = r.length,
                o = 0,
                a = 128,
                c = 72,
                u = r.lastIndexOf("-");
              u < 0 && (u = 0);
              for (let e = 0; e < u; ++e)
                r.charCodeAt(e) >= 128 && l("not-basic"),
                  n.push(r.charCodeAt(e));
              for (let d = u > 0 ? u + 1 : 0; d < i; ) {
                let u = o;
                for (let n = 1, a = t; ; a += t) {
                  d >= i && l("invalid-input");
                  let u = h(r.charCodeAt(d++));
                  u >= t && l("invalid-input"),
                    u > s((e - o) / n) && l("overflow"),
                    (o += u * n);
                  let p = a <= c ? 1 : a >= c + 26 ? 26 : a - c;
                  if (u < p) break;
                  let f = t - p;
                  n > s(e / f) && l("overflow"), (n *= f);
                }
                let f = n.length + 1;
                (c = p(o - u, f, 0 == u)),
                  s(o / f) > e - a && l("overflow"),
                  (a += s(o / f)),
                  (o %= f),
                  n.splice(o++, 0, a);
              }
              return String.fromCodePoint(...n);
            },
            m = function (r) {
              let n = [],
                i = (r = u(r)).length,
                o = 128,
                c = 0,
                h = 72;
              for (let e of r) e < 128 && n.push(a(e));
              let f = n.length,
                m = f;
              for (f && n.push("-"); m < i; ) {
                let i = e;
                for (let e of r) e >= o && e < i && (i = e);
                let u = m + 1;
                i - o > s((e - c) / u) && l("overflow"),
                  (c += (i - o) * u),
                  (o = i);
                for (let i of r)
                  if ((i < o && ++c > e && l("overflow"), i === o)) {
                    let e = c;
                    for (let r = t; ; r += t) {
                      let i = r <= h ? 1 : r >= h + 26 ? 26 : r - h;
                      if (e < i) break;
                      let o = e - i,
                        l = t - i;
                      n.push(a(d(i + (o % l), 0))), (e = s(o / l));
                    }
                    n.push(a(d(e, 0))), (h = p(c, u, m === f)), (c = 0), ++m;
                  }
                ++c, ++o;
              }
              return n.join("");
            };
          return (Sh = {
            version: "2.3.1",
            ucs2: { decode: u, encode: (e) => String.fromCodePoint(...e) },
            decode: f,
            encode: m,
            toASCII: function (e) {
              return c(e, function (e) {
                return n.test(e) ? "xn--" + m(e) : e;
              });
            },
            toUnicode: function (e) {
              return c(e, function (e) {
                return r.test(e) ? f(e.slice(4).toLowerCase()) : e;
              });
            },
          });
        })()).decode,
        Mh.encode,
        Mh.toASCII,
        Mh.toUnicode,
        Mh.ucs2,
        Mh.version;
    });
  function Rp() {
    return Xp || ((Xp = !0), (Gp = SyntaxError)), Gp;
  }
  function Pp() {
    return Yp || ((Yp = !0), (qp = TypeError)), qp;
  }
  function Cp() {
    if (of) return nf;
    of = !0;
    var e = (function () {
      if (rf) return tf;
      rf = !0;
      var e = Object.prototype.toString,
        t = Math.max,
        r = function (e, t) {
          for (var r = [], n = 0; n < e.length; n += 1) r[n] = e[n];
          for (var i = 0; i < t.length; i += 1) r[i + e.length] = t[i];
          return r;
        };
      return (
        (tf = function (n) {
          var i = this;
          if ("function" != typeof i || "[object Function]" !== e.apply(i))
            throw new TypeError(
              "Function.prototype.bind called on incompatible " + i
            );
          for (
            var o,
              s = (function (e) {
                for (var t = [], r = 1, n = 0; r < e.length; r += 1, n += 1)
                  t[n] = e[r];
                return t;
              })(arguments),
              a = t(0, i.length - s.length),
              l = [],
              c = 0;
            c < a;
            c++
          )
            l[c] = "$" + c;
          if (
            ((o = Function(
              "binder",
              "return function (" +
                (function (e) {
                  for (var t = "", r = 0; r < e.length; r += 1)
                    (t += e[r]), r + 1 < e.length && (t += ",");
                  return t;
                })(l) +
                "){ return binder.apply(this,arguments); }"
            )(function () {
              if (this instanceof o) {
                var e = i.apply(this, r(s, arguments));
                return Object(e) === e ? e : this;
              }
              return i.apply(n, r(s, arguments));
            })),
            i.prototype)
          ) {
            var u = function () {};
            (u.prototype = i.prototype),
              (o.prototype = new u()),
              (u.prototype = null);
          }
          return o;
        }),
        tf
      );
    })();
    return (nf = Function.prototype.bind || e);
  }
  function Ip() {
    if (cf) return lf;
    cf = !0;
    var e,
      t = (Bp || ((Bp = !0), (kp = Error)), kp),
      r = (Hp || ((Hp = !0), (Fp = EvalError)), Fp),
      n = (Vp || ((Vp = !0), (zp = RangeError)), zp),
      i = (Wp || ((Wp = !0), (jp = ReferenceError)), jp),
      o = Rp(),
      s = Pp(),
      a = ($p || (($p = !0), (Kp = URIError)), Kp),
      l = Function,
      c = function (e) {
        try {
          return l('"use strict"; return (' + e + ").constructor;")();
        } catch {}
      },
      u = Object.getOwnPropertyDescriptor;
    if (u)
      try {
        u({}, "");
      } catch {
        u = null;
      }
    var h = function () {
        throw new s();
      },
      d = u
        ? (function () {
            try {
              return h;
            } catch {
              try {
                return u(arguments, "callee").get;
              } catch {
                return h;
              }
            }
          })()
        : h,
      p = (function () {
        if (Jp) return Qp;
        Jp = !0;
        var e = typeof Symbol < "u" && Symbol,
          t =
            (Dp ||
              ((Dp = !0),
              (Up = function () {
                if (
                  "function" != typeof Symbol ||
                  "function" != typeof Object.getOwnPropertySymbols
                )
                  return !1;
                if ("symbol" == typeof Symbol.iterator) return !0;
                var e = {},
                  t = Symbol("test"),
                  r = Object(t);
                if (
                  "string" == typeof t ||
                  "[object Symbol]" !== Object.prototype.toString.call(t) ||
                  "[object Symbol]" !== Object.prototype.toString.call(r)
                )
                  return !1;
                for (t in ((e[t] = 42), e)) return !1;
                if (
                  ("function" == typeof Object.keys &&
                    0 !== Object.keys(e).length) ||
                  ("function" == typeof Object.getOwnPropertyNames &&
                    0 !== Object.getOwnPropertyNames(e).length)
                )
                  return !1;
                var n = Object.getOwnPropertySymbols(e);
                if (
                  1 !== n.length ||
                  n[0] !== t ||
                  !Object.prototype.propertyIsEnumerable.call(e, t)
                )
                  return !1;
                if ("function" == typeof Object.getOwnPropertyDescriptor) {
                  var i = Object.getOwnPropertyDescriptor(e, t);
                  if (42 !== i.value || !0 !== i.enumerable) return !1;
                }
                return !0;
              })),
            Up);
        return (Qp = function () {
          return (
            "function" == typeof e &&
            "function" == typeof Symbol &&
            "symbol" == typeof e("foo") &&
            "symbol" == typeof Symbol("bar") &&
            t()
          );
        });
      })()(),
      f = (function () {
        if (ef) return Zp;
        ef = !0;
        var e = { __proto__: null, foo: {} },
          t = Object;
        return (Zp = function () {
          return { __proto__: e }.foo === e.foo && !(e instanceof t);
        });
      })()(),
      m =
        Object.getPrototypeOf ||
        (f
          ? function (e) {
              return e.__proto__;
            }
          : null),
      g = {},
      _ = typeof Uint8Array > "u" || !m ? e : m(Uint8Array),
      v = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError > "u" ? e : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer > "u" ? e : ArrayBuffer,
        "%ArrayIteratorPrototype%": p && m ? m([][Symbol.iterator]()) : e,
        "%AsyncFromSyncIteratorPrototype%": e,
        "%AsyncFunction%": g,
        "%AsyncGenerator%": g,
        "%AsyncGeneratorFunction%": g,
        "%AsyncIteratorPrototype%": g,
        "%Atomics%": typeof Atomics > "u" ? e : Atomics,
        "%BigInt%": typeof BigInt > "u" ? e : BigInt,
        "%BigInt64Array%": typeof BigInt64Array > "u" ? e : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array > "u" ? e : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView > "u" ? e : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": t,
        "%eval%": eval,
        "%EvalError%": r,
        "%Float32Array%": typeof Float32Array > "u" ? e : Float32Array,
        "%Float64Array%": typeof Float64Array > "u" ? e : Float64Array,
        "%FinalizationRegistry%":
          typeof FinalizationRegistry > "u" ? e : FinalizationRegistry,
        "%Function%": l,
        "%GeneratorFunction%": g,
        "%Int8Array%": typeof Int8Array > "u" ? e : Int8Array,
        "%Int16Array%": typeof Int16Array > "u" ? e : Int16Array,
        "%Int32Array%": typeof Int32Array > "u" ? e : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": p && m ? m(m([][Symbol.iterator]())) : e,
        "%JSON%": "object" == typeof JSON ? JSON : e,
        "%Map%": typeof Map > "u" ? e : Map,
        "%MapIteratorPrototype%":
          typeof Map > "u" || !p || !m ? e : m(new Map()[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise > "u" ? e : Promise,
        "%Proxy%": typeof Proxy > "u" ? e : Proxy,
        "%RangeError%": n,
        "%ReferenceError%": i,
        "%Reflect%": typeof Reflect > "u" ? e : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set > "u" ? e : Set,
        "%SetIteratorPrototype%":
          typeof Set > "u" || !p || !m ? e : m(new Set()[Symbol.iterator]()),
        "%SharedArrayBuffer%":
          typeof SharedArrayBuffer > "u" ? e : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": p && m ? m(""[Symbol.iterator]()) : e,
        "%Symbol%": p ? Symbol : e,
        "%SyntaxError%": o,
        "%ThrowTypeError%": d,
        "%TypedArray%": _,
        "%TypeError%": s,
        "%Uint8Array%": typeof Uint8Array > "u" ? e : Uint8Array,
        "%Uint8ClampedArray%":
          typeof Uint8ClampedArray > "u" ? e : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array > "u" ? e : Uint16Array,
        "%Uint32Array%": typeof Uint32Array > "u" ? e : Uint32Array,
        "%URIError%": a,
        "%WeakMap%": typeof WeakMap > "u" ? e : WeakMap,
        "%WeakRef%": typeof WeakRef > "u" ? e : WeakRef,
        "%WeakSet%": typeof WeakSet > "u" ? e : WeakSet,
      };
    if (m)
      try {
        null.error;
      } catch (e) {
        var y = m(m(e));
        v["%Error.prototype%"] = y;
      }
    var b = function e(t) {
        var r;
        if ("%AsyncFunction%" === t) r = c("async function () {}");
        else if ("%GeneratorFunction%" === t) r = c("function* () {}");
        else if ("%AsyncGeneratorFunction%" === t)
          r = c("async function* () {}");
        else if ("%AsyncGenerator%" === t) {
          var n = e("%AsyncGeneratorFunction%");
          n && (r = n.prototype);
        } else if ("%AsyncIteratorPrototype%" === t) {
          var i = e("%AsyncGenerator%");
          i && m && (r = m(i.prototype));
        }
        return (v[t] = r), r;
      },
      x = {
        __proto__: null,
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": [
          "AsyncGeneratorFunction",
          "prototype",
          "prototype",
        ],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"],
      },
      w = Cp(),
      S = (function () {
        if (af) return sf;
        af = !0;
        var e = Function.prototype.call,
          t = Object.prototype.hasOwnProperty,
          r = Cp();
        return (sf = r.call(e, t));
      })(),
      E = w.call(Function.call, Array.prototype.concat),
      M = w.call(Function.apply, Array.prototype.splice),
      T = w.call(Function.call, String.prototype.replace),
      A = w.call(Function.call, String.prototype.slice),
      R = w.call(Function.call, RegExp.prototype.exec),
      P =
        /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
      C = /\\(\\)?/g,
      I = function (e, t) {
        var r,
          n = e;
        if ((S(x, n) && (n = "%" + (r = x[n])[0] + "%"), S(v, n))) {
          var i = v[n];
          if ((i === g && (i = b(n)), typeof i > "u" && !t))
            throw new s(
              "intrinsic " +
                e +
                " exists, but is not available. Please file an issue!"
            );
          return { alias: r, name: n, value: i };
        }
        throw new o("intrinsic " + e + " does not exist!");
      };
    return (
      (lf = function (e, t) {
        if ("string" != typeof e || 0 === e.length)
          throw new s("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && "boolean" != typeof t)
          throw new s('"allowMissing" argument must be a boolean');
        if (null === R(/^%?[^%]*%?$/, e))
          throw new o(
            "`%` may not be present anywhere but at the beginning and end of the intrinsic name"
          );
        var r = (function (e) {
            var t = A(e, 0, 1),
              r = A(e, -1);
            if ("%" === t && "%" !== r)
              throw new o("invalid intrinsic syntax, expected closing `%`");
            if ("%" === r && "%" !== t)
              throw new o("invalid intrinsic syntax, expected opening `%`");
            var n = [];
            return (
              T(e, P, function (e, t, r, i) {
                n[n.length] = r ? T(i, C, "$1") : t || e;
              }),
              n
            );
          })(e),
          n = r.length > 0 ? r[0] : "",
          i = I("%" + n + "%", t),
          a = i.name,
          l = i.value,
          c = !1,
          h = i.alias;
        h && ((n = h[0]), M(r, E([0, 1], h)));
        for (var d = 1, p = !0; d < r.length; d += 1) {
          var f = r[d],
            m = A(f, 0, 1),
            g = A(f, -1);
          if (
            ('"' === m ||
              "'" === m ||
              "`" === m ||
              '"' === g ||
              "'" === g ||
              "`" === g) &&
            m !== g
          )
            throw new o("property names with quotes must have matching quotes");
          if (
            (("constructor" === f || !p) && (c = !0),
            S(v, (a = "%" + (n += "." + f) + "%")))
          )
            l = v[a];
          else if (null != l) {
            if (!(f in l)) {
              if (!t)
                throw new s(
                  "base intrinsic for " +
                    e +
                    " exists, but the property is not available."
                );
              return;
            }
            if (u && d + 1 >= r.length) {
              var _ = u(l, f);
              l =
                (p = !!_) && "get" in _ && !("originalValue" in _.get)
                  ? _.get
                  : l[f];
            } else (p = S(l, f)), (l = l[f]);
            p && !c && (v[a] = l);
          }
        }
        return l;
      }),
      lf
    );
  }
  function Lp() {
    if (hf) return uf;
    hf = !0;
    var e = Ip()("%Object.defineProperty%", !0) || !1;
    if (e)
      try {
        e({}, "a", { value: 1 });
      } catch {
        e = !1;
      }
    return (uf = e);
  }
  function Op() {
    if (pf) return df;
    pf = !0;
    var e = Ip()("%Object.getOwnPropertyDescriptor%", !0);
    if (e)
      try {
        e([], "length");
      } catch {
        e = null;
      }
    return (df = e);
  }
  function Np() {
    if (Sf) return wf;
    Sf = !0;
    var e = Ip(),
      t = (function () {
        if (xf) return bf;
        xf = !0;
        var e = Cp(),
          t = Ip(),
          r = (function () {
            if (yf) return vf;
            yf = !0;
            var e = Ip(),
              t = (function () {
                if (mf) return ff;
                mf = !0;
                var e = Lp(),
                  t = Rp(),
                  r = Pp(),
                  n = Op();
                return (
                  (ff = function (i, o, s) {
                    if (!i || ("object" != typeof i && "function" != typeof i))
                      throw new r("`obj` must be an object or a function`");
                    if ("string" != typeof o && "symbol" != typeof o)
                      throw new r("`property` must be a string or a symbol`");
                    if (
                      arguments.length > 3 &&
                      "boolean" != typeof arguments[3] &&
                      null !== arguments[3]
                    )
                      throw new r(
                        "`nonEnumerable`, if provided, must be a boolean or null"
                      );
                    if (
                      arguments.length > 4 &&
                      "boolean" != typeof arguments[4] &&
                      null !== arguments[4]
                    )
                      throw new r(
                        "`nonWritable`, if provided, must be a boolean or null"
                      );
                    if (
                      arguments.length > 5 &&
                      "boolean" != typeof arguments[5] &&
                      null !== arguments[5]
                    )
                      throw new r(
                        "`nonConfigurable`, if provided, must be a boolean or null"
                      );
                    if (
                      arguments.length > 6 &&
                      "boolean" != typeof arguments[6]
                    )
                      throw new r("`loose`, if provided, must be a boolean");
                    var a = arguments.length > 3 ? arguments[3] : null,
                      l = arguments.length > 4 ? arguments[4] : null,
                      c = arguments.length > 5 ? arguments[5] : null,
                      u = arguments.length > 6 && arguments[6],
                      h = !!n && n(i, o);
                    if (e)
                      e(i, o, {
                        configurable: null === c && h ? h.configurable : !c,
                        enumerable: null === a && h ? h.enumerable : !a,
                        value: s,
                        writable: null === l && h ? h.writable : !l,
                      });
                    else {
                      if (!u && (a || l || c))
                        throw new t(
                          "This environment does not support defining a property as non-configurable, non-writable, or non-enumerable."
                        );
                      i[o] = s;
                    }
                  }),
                  ff
                );
              })(),
              r = (function () {
                if (_f) return gf;
                _f = !0;
                var e = Lp(),
                  t = function () {
                    return !!e;
                  };
                return (
                  (t.hasArrayLengthDefineBug = function () {
                    if (!e) return null;
                    try {
                      return 1 !== e([], "length", { value: 1 }).length;
                    } catch {
                      return !0;
                    }
                  }),
                  (gf = t)
                );
              })()(),
              n = Op(),
              i = Pp(),
              o = e("%Math.floor%");
            return (
              (vf = function (e, s) {
                if ("function" != typeof e)
                  throw new i("`fn` is not a function");
                if (
                  "number" != typeof s ||
                  s < 0 ||
                  s > 4294967295 ||
                  o(s) !== s
                )
                  throw new i("`length` must be a positive 32-bit integer");
                var a = arguments.length > 2 && !!arguments[2],
                  l = !0,
                  c = !0;
                if ("length" in e && n) {
                  var u = n(e, "length");
                  u && !u.configurable && (l = !1),
                    u && !u.writable && (c = !1);
                }
                return (
                  (l || c || !a) &&
                    (r ? t(e, "length", s, !0, !0) : t(e, "length", s)),
                  e
                );
              }),
              vf
            );
          })(),
          n = Pp(),
          i = t("%Function.prototype.apply%"),
          o = t("%Function.prototype.call%"),
          s = t("%Reflect.apply%", !0) || e.call(o, i),
          a = Lp(),
          l = t("%Math.max%");
        bf = function (t) {
          if ("function" != typeof t) throw new n("a function is required");
          var i = s(e, o, arguments);
          return r(i, 1 + l(0, t.length - (arguments.length - 1)), !0);
        };
        var c = function () {
          return s(e, i, arguments);
        };
        return a ? a(bf, "apply", { value: c }) : (bf.apply = c), bf;
      })(),
      r = t(e("String.prototype.indexOf"));
    return (wf = function (n, i) {
      var o = e(n, !!i);
      return "function" == typeof o && r(n, ".prototype.") > -1 ? t(o) : o;
    });
  }
  var Up,
    Dp,
    kp,
    Bp,
    Fp,
    Hp,
    zp,
    Vp,
    jp,
    Wp,
    Gp,
    Xp,
    qp,
    Yp,
    Kp,
    $p,
    Qp,
    Jp,
    Zp,
    ef,
    tf,
    rf,
    nf,
    of,
    sf,
    af,
    lf,
    cf,
    uf,
    hf,
    df,
    pf,
    ff,
    mf,
    gf,
    _f,
    vf,
    yf,
    bf,
    xf,
    wf,
    Sf,
    Ef = hc(() => {
      mc(),
        lh(),
        qu(),
        (Up = {}),
        (Dp = !1),
        (kp = {}),
        (Bp = !1),
        (Fp = {}),
        (Hp = !1),
        (zp = {}),
        (Vp = !1),
        (jp = {}),
        (Wp = !1),
        (Gp = {}),
        (Xp = !1),
        (qp = {}),
        (Yp = !1),
        (Kp = {}),
        ($p = !1),
        (Qp = {}),
        (Jp = !1),
        (Zp = {}),
        (ef = !1),
        (tf = {}),
        (rf = !1),
        (nf = {}),
        (of = !1),
        (sf = {}),
        (af = !1),
        (lf = {}),
        (cf = !1),
        (uf = {}),
        (hf = !1),
        (df = {}),
        (pf = !1),
        (ff = {}),
        (mf = !1),
        (gf = {}),
        (_f = !1),
        (vf = {}),
        (yf = !1),
        (bf = {}),
        (xf = !1),
        (wf = {}),
        (Sf = !1);
    });
  function Mf(e) {
    throw new Error(
      "Node.js process " +
        e +
        " is not supported by JSPM core outside of Node.js"
    );
  }
  function Tf() {
    !Vf ||
      !jf ||
      ((Vf = !1),
      jf.length ? (zf = jf.concat(zf)) : (Wf = -1),
      zf.length && Af());
  }
  function Af() {
    if (!Vf) {
      var e = setTimeout(Tf, 0);
      Vf = !0;
      for (var t = zf.length; t; ) {
        for (jf = zf, zf = []; ++Wf < t; ) jf && jf[Wf].run();
        (Wf = -1), (t = zf.length);
      }
      (jf = null), (Vf = !1), clearTimeout(e);
    }
  }
  function Rf(e) {
    var t = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
    zf.push(new Pf(e, t)), 1 === zf.length && !Vf && setTimeout(Af, 0);
  }
  function Pf(e, t) {
    (this.fun = e), (this.array = t);
  }
  function Cf() {}
  function If(e) {
    Mf("_linkedBinding");
  }
  function Lf(e) {
    Mf("dlopen");
  }
  function Of() {
    return [];
  }
  function Nf() {
    return [];
  }
  function Uf(e, t) {
    if (!e) throw new Error(t || "assertion error");
  }
  function Df() {
    return !1;
  }
  function kf() {
    return Mm.now() / 1e3;
  }
  function Bf(e) {
    var t = Math.floor(0.001 * (Date.now() - Mm.now())),
      r = 0.001 * Mm.now(),
      n = Math.floor(r) + t,
      i = Math.floor((r % 1) * 1e9);
    return e && ((n -= e[0]), (i -= e[1]) < 0 && (n--, (i += Am))), [n, i];
  }
  function Ff() {
    return Rm;
  }
  function Hf(e) {
    return [];
  }
  var zf,
    Vf,
    jf,
    Wf,
    Gf,
    Xf,
    qf,
    Yf,
    Kf,
    $f,
    Qf,
    Jf,
    Zf,
    em,
    tm,
    rm,
    nm,
    im,
    om,
    sm,
    am,
    lm,
    cm,
    um,
    hm,
    dm,
    pm,
    fm,
    mm,
    gm,
    _m,
    vm,
    ym,
    bm,
    xm,
    wm,
    Sm,
    Em,
    Mm,
    Tm,
    Am,
    Rm,
    Pm,
    Cm,
    Im,
    Lm = hc(() => {
      mc(),
        lh(),
        qu(),
        (zf = []),
        (Vf = !1),
        (Wf = -1),
        (Pf.prototype.run = function () {
          this.fun.apply(null, this.array);
        }),
        (Gf = {
          PATH: "/usr/bin",
          LANG: navigator.language + ".UTF-8",
          PWD: "/",
          HOME: "/home",
          TMP: "/tmp",
        }),
        (Xf = ["/usr/bin/node"]),
        (qf = []),
        (Yf = {}),
        (Kf = function (e, t) {
          console.warn((t ? t + ": " : "") + e);
        }),
        ($f = function (e) {
          Mf("binding");
        }),
        (Qf = function (e) {
          return 0;
        }),
        (Jf = function () {
          return "/";
        }),
        (Zf = function (e) {}),
        (em = { name: "node", sourceUrl: "", headersUrl: "", libUrl: "" }),
        (tm = Cf),
        (rm = []),
        (nm = {}),
        (im = {}),
        (om = Cf),
        (sm = Cf),
        (lm = am =
          function () {
            return {};
          }),
        (cm = am),
        (um = Cf),
        (hm = Cf),
        (dm = Cf),
        (pm = {}),
        (fm = {
          inspector: !1,
          debug: !1,
          uv: !1,
          ipv6: !1,
          tls_alpn: !1,
          tls_sni: !1,
          tls_ocsp: !1,
          tls: !1,
          cached_builtins: !0,
        }),
        (mm = Cf),
        (gm = Cf),
        (_m = Cf),
        (vm = Cf),
        (ym = Cf),
        (bm = Cf),
        (xm = Cf),
        (wm = Cf),
        (Sm = []),
        (Em = Cf),
        void 0 ===
          (Mm = {
            now:
              typeof performance < "u"
                ? performance.now.bind(performance)
                : void 0,
            timing: typeof performance < "u" ? performance.timing : void 0,
          }).now &&
          ((Tm = Date.now()),
          Mm.timing &&
            Mm.timing.navigationStart &&
            (Tm = Mm.timing.navigationStart),
          (Mm.now = () => Date.now() - Tm)),
        (Am = 1e9),
        (Bf.bigint = function (e) {
          var t = Bf(e);
          return typeof BigInt > "u"
            ? t[0] * Am + t[1]
            : BigInt(t[0] * Am) + BigInt(t[1]);
        }),
        (Rm = {
          version: "v16.8.0",
          versions: Yf,
          arch: "x64",
          platform: "browser",
          release: em,
          _rawDebug: tm,
          moduleLoadList: rm,
          binding: $f,
          _linkedBinding: If,
          _events: {},
          _eventsCount: 0,
          _maxListeners: 10,
          on: Ff,
          addListener: Ff,
          once: Ff,
          off: Ff,
          removeListener: Ff,
          removeAllListeners: Ff,
          emit: Cf,
          prependListener: Ff,
          prependOnceListener: Ff,
          listeners: Hf,
          domain: nm,
          _exiting: !1,
          config: im,
          dlopen: Lf,
          uptime: kf,
          _getActiveRequests: Of,
          _getActiveHandles: Nf,
          reallyExit: om,
          _kill: sm,
          cpuUsage: am,
          resourceUsage: lm,
          memoryUsage: cm,
          kill: um,
          exit: hm,
          openStdin: dm,
          allowedNodeEnvironmentFlags: pm,
          assert: Uf,
          features: fm,
          _fatalExceptions: mm,
          setUncaughtExceptionCaptureCallback: gm,
          hasUncaughtExceptionCaptureCallback: Df,
          emitWarning: Kf,
          nextTick: Rf,
          _tickCallback: _m,
          _debugProcess: vm,
          _debugEnd: ym,
          _startProfilerIdleNotifier: bm,
          _stopProfilerIdleNotifier: xm,
          stdout: void 0,
          stdin: void 0,
          stderr: void 0,
          abort: wm,
          umask: Qf,
          chdir: Zf,
          cwd: Jf,
          env: Gf,
          title: "browser",
          argv: Xf,
          execArgv: qf,
          pid: 2,
          ppid: 1,
          execPath: "/bin/usr/node",
          debugPort: 9229,
          hrtime: Bf,
          argv0: "node",
          _preload_modules: Sm,
          setSourceMapsEnabled: Em,
        });
    }),
    Om = hc(() => {
      mc(),
        lh(),
        qu(),
        Lm(),
        (Pm = {}),
        (Cm = !1),
        (Im = (function () {
          if (Cm) return Pm;
          Cm = !0;
          var e = Rm;
          function t(e) {
            if ("string" != typeof e)
              throw new TypeError(
                "Path must be a string. Received " + JSON.stringify(e)
              );
          }
          function r(e, t) {
            for (
              var r, n = "", i = 0, o = -1, s = 0, a = 0;
              a <= e.length;
              ++a
            ) {
              if (a < e.length) r = e.charCodeAt(a);
              else {
                if (47 === r) break;
                r = 47;
              }
              if (47 === r) {
                if (o !== a - 1 && 1 !== s)
                  if (o !== a - 1 && 2 === s) {
                    if (
                      n.length < 2 ||
                      2 !== i ||
                      46 !== n.charCodeAt(n.length - 1) ||
                      46 !== n.charCodeAt(n.length - 2)
                    )
                      if (n.length > 2) {
                        var l = n.lastIndexOf("/");
                        if (l !== n.length - 1) {
                          -1 === l
                            ? ((n = ""), (i = 0))
                            : (i =
                                (n = n.slice(0, l)).length -
                                1 -
                                n.lastIndexOf("/")),
                            (o = a),
                            (s = 0);
                          continue;
                        }
                      } else if (2 === n.length || 1 === n.length) {
                        (n = ""), (i = 0), (o = a), (s = 0);
                        continue;
                      }
                    t && (n.length > 0 ? (n += "/..") : (n = ".."), (i = 2));
                  } else
                    n.length > 0
                      ? (n += "/" + e.slice(o + 1, a))
                      : (n = e.slice(o + 1, a)),
                      (i = a - o - 1);
                (o = a), (s = 0);
              } else 46 === r && -1 !== s ? ++s : (s = -1);
            }
            return n;
          }
          var n = {
            resolve: function () {
              for (
                var n, i = "", o = !1, s = arguments.length - 1;
                s >= -1 && !o;
                s--
              ) {
                var a;
                s >= 0
                  ? (a = arguments[s])
                  : (void 0 === n && (n = e.cwd()), (a = n)),
                  t(a),
                  0 !== a.length &&
                    ((i = a + "/" + i), (o = 47 === a.charCodeAt(0)));
              }
              return (
                (i = r(i, !o)),
                o ? (i.length > 0 ? "/" + i : "/") : i.length > 0 ? i : "."
              );
            },
            normalize: function (e) {
              if ((t(e), 0 === e.length)) return ".";
              var n = 47 === e.charCodeAt(0),
                i = 47 === e.charCodeAt(e.length - 1);
              return (
                0 === (e = r(e, !n)).length && !n && (e = "."),
                e.length > 0 && i && (e += "/"),
                n ? "/" + e : e
              );
            },
            isAbsolute: function (e) {
              return t(e), e.length > 0 && 47 === e.charCodeAt(0);
            },
            join: function () {
              if (0 === arguments.length) return ".";
              for (var e, r = 0; r < arguments.length; ++r) {
                var i = arguments[r];
                t(i), i.length > 0 && (void 0 === e ? (e = i) : (e += "/" + i));
              }
              return void 0 === e ? "." : n.normalize(e);
            },
            relative: function (e, r) {
              if (
                (t(e),
                t(r),
                e === r || (e = n.resolve(e)) === (r = n.resolve(r)))
              )
                return "";
              for (var i = 1; i < e.length && 47 === e.charCodeAt(i); ++i);
              for (
                var o = e.length, s = o - i, a = 1;
                a < r.length && 47 === r.charCodeAt(a);
                ++a
              );
              for (
                var l = r.length - a, c = s < l ? s : l, u = -1, h = 0;
                h <= c;
                ++h
              ) {
                if (h === c) {
                  if (l > c) {
                    if (47 === r.charCodeAt(a + h)) return r.slice(a + h + 1);
                    if (0 === h) return r.slice(a + h);
                  } else
                    s > c &&
                      (47 === e.charCodeAt(i + h)
                        ? (u = h)
                        : 0 === h && (u = 0));
                  break;
                }
                var d = e.charCodeAt(i + h);
                if (d !== r.charCodeAt(a + h)) break;
                47 === d && (u = h);
              }
              var p = "";
              for (h = i + u + 1; h <= o; ++h)
                (h === o || 47 === e.charCodeAt(h)) &&
                  (0 === p.length ? (p += "..") : (p += "/.."));
              return p.length > 0
                ? p + r.slice(a + u)
                : ((a += u), 47 === r.charCodeAt(a) && ++a, r.slice(a));
            },
            _makeLong: function (e) {
              return e;
            },
            dirname: function (e) {
              if ((t(e), 0 === e.length)) return ".";
              for (
                var r = e.charCodeAt(0),
                  n = 47 === r,
                  i = -1,
                  o = !0,
                  s = e.length - 1;
                s >= 1;
                --s
              )
                if (47 === (r = e.charCodeAt(s))) {
                  if (!o) {
                    i = s;
                    break;
                  }
                } else o = !1;
              return -1 === i
                ? n
                  ? "/"
                  : "."
                : n && 1 === i
                ? "//"
                : e.slice(0, i);
            },
            basename: function (e, r) {
              if (void 0 !== r && "string" != typeof r)
                throw new TypeError('"ext" argument must be a string');
              t(e);
              var n,
                i = 0,
                o = -1,
                s = !0;
              if (void 0 !== r && r.length > 0 && r.length <= e.length) {
                if (r.length === e.length && r === e) return "";
                var a = r.length - 1,
                  l = -1;
                for (n = e.length - 1; n >= 0; --n) {
                  var c = e.charCodeAt(n);
                  if (47 === c) {
                    if (!s) {
                      i = n + 1;
                      break;
                    }
                  } else
                    -1 === l && ((s = !1), (l = n + 1)),
                      a >= 0 &&
                        (c === r.charCodeAt(a)
                          ? -1 === --a && (o = n)
                          : ((a = -1), (o = l)));
                }
                return (
                  i === o ? (o = l) : -1 === o && (o = e.length), e.slice(i, o)
                );
              }
              for (n = e.length - 1; n >= 0; --n)
                if (47 === e.charCodeAt(n)) {
                  if (!s) {
                    i = n + 1;
                    break;
                  }
                } else -1 === o && ((s = !1), (o = n + 1));
              return -1 === o ? "" : e.slice(i, o);
            },
            extname: function (e) {
              t(e);
              for (
                var r = -1, n = 0, i = -1, o = !0, s = 0, a = e.length - 1;
                a >= 0;
                --a
              ) {
                var l = e.charCodeAt(a);
                if (47 !== l)
                  -1 === i && ((o = !1), (i = a + 1)),
                    46 === l
                      ? -1 === r
                        ? (r = a)
                        : 1 !== s && (s = 1)
                      : -1 !== r && (s = -1);
                else if (!o) {
                  n = a + 1;
                  break;
                }
              }
              return -1 === r ||
                -1 === i ||
                0 === s ||
                (1 === s && r === i - 1 && r === n + 1)
                ? ""
                : e.slice(r, i);
            },
            format: function (e) {
              if (null === e || "object" != typeof e)
                throw new TypeError(
                  'The "pathObject" argument must be of type Object. Received type ' +
                    typeof e
                );
              return (function (e, t) {
                var r = t.dir || t.root,
                  n = t.base || (t.name || "") + (t.ext || "");
                return r ? (r === t.root ? r + n : r + "/" + n) : n;
              })(0, e);
            },
            parse: function (e) {
              t(e);
              var r = { root: "", dir: "", base: "", ext: "", name: "" };
              if (0 === e.length) return r;
              var n,
                i = e.charCodeAt(0),
                o = 47 === i;
              o ? ((r.root = "/"), (n = 1)) : (n = 0);
              for (
                var s = -1, a = 0, l = -1, c = !0, u = e.length - 1, h = 0;
                u >= n;
                --u
              )
                if (47 !== (i = e.charCodeAt(u)))
                  -1 === l && ((c = !1), (l = u + 1)),
                    46 === i
                      ? -1 === s
                        ? (s = u)
                        : 1 !== h && (h = 1)
                      : -1 !== s && (h = -1);
                else if (!c) {
                  a = u + 1;
                  break;
                }
              return (
                -1 === s ||
                -1 === l ||
                0 === h ||
                (1 === h && s === l - 1 && s === a + 1)
                  ? -1 !== l &&
                    (r.base = r.name =
                      0 === a && o ? e.slice(1, l) : e.slice(a, l))
                  : (0 === a && o
                      ? ((r.name = e.slice(1, s)), (r.base = e.slice(1, l)))
                      : ((r.name = e.slice(a, s)), (r.base = e.slice(a, l))),
                    (r.ext = e.slice(s, l))),
                a > 0 ? (r.dir = e.slice(0, a - 1)) : o && (r.dir = "/"),
                r
              );
            },
            sep: "/",
            delimiter: ":",
            win32: null,
            posix: null,
          };
          return (n.posix = n), (Pm = n);
        })());
    }),
    Nm = {};
  function Um() {
    if (Wm) return jm;
    Wm = !0;
    var e = "function" == typeof Map && Map.prototype,
      t =
        Object.getOwnPropertyDescriptor && e
          ? Object.getOwnPropertyDescriptor(Map.prototype, "size")
          : null,
      r = e && t && "function" == typeof t.get ? t.get : null,
      n = e && Map.prototype.forEach,
      i = "function" == typeof Set && Set.prototype,
      o =
        Object.getOwnPropertyDescriptor && i
          ? Object.getOwnPropertyDescriptor(Set.prototype, "size")
          : null,
      s = i && o && "function" == typeof o.get ? o.get : null,
      a = i && Set.prototype.forEach,
      l =
        "function" == typeof WeakMap && WeakMap.prototype
          ? WeakMap.prototype.has
          : null,
      c =
        "function" == typeof WeakSet && WeakSet.prototype
          ? WeakSet.prototype.has
          : null,
      u =
        "function" == typeof WeakRef && WeakRef.prototype
          ? WeakRef.prototype.deref
          : null,
      h = Boolean.prototype.valueOf,
      d = Object.prototype.toString,
      p = Function.prototype.toString,
      f = String.prototype.match,
      m = String.prototype.slice,
      g = String.prototype.replace,
      _ = String.prototype.toUpperCase,
      v = String.prototype.toLowerCase,
      y = RegExp.prototype.test,
      b = Array.prototype.concat,
      x = Array.prototype.join,
      w = Array.prototype.slice,
      S = Math.floor,
      E = "function" == typeof BigInt ? BigInt.prototype.valueOf : null,
      M = Object.getOwnPropertySymbols,
      T =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? Symbol.prototype.toString
          : null,
      A = "function" == typeof Symbol && "object" == typeof Symbol.iterator,
      R =
        "function" == typeof Symbol &&
        Symbol.toStringTag &&
        (Symbol.toStringTag, 1)
          ? Symbol.toStringTag
          : null,
      P = Object.prototype.propertyIsEnumerable,
      C =
        ("function" == typeof Reflect
          ? Reflect.getPrototypeOf
          : Object.getPrototypeOf) ||
        ([].__proto__ === Array.prototype
          ? function (e) {
              return e.__proto__;
            }
          : null);
    function I(e, t) {
      if (
        e === 1 / 0 ||
        e === -1 / 0 ||
        e != e ||
        (e && e > -1e3 && e < 1e3) ||
        y.call(/e/, t)
      )
        return t;
      var r = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if ("number" == typeof e) {
        var n = e < 0 ? -S(-e) : S(e);
        if (n !== e) {
          var i = String(n),
            o = m.call(t, i.length + 1);
          return (
            g.call(i, r, "$&_") +
            "." +
            g.call(g.call(o, /([0-9]{3})/g, "$&_"), /_$/, "")
          );
        }
      }
      return g.call(t, r, "$&_");
    }
    var L = Vm,
      O = L.custom,
      N = F(O) ? O : null;
    function U(e, t, r) {
      var n = "double" === (r.quoteStyle || t) ? '"' : "'";
      return n + e + n;
    }
    function D(e) {
      return g.call(String(e), /"/g, "&quot;");
    }
    function k(e) {
      return !(
        "[object Array]" !== V(e) ||
        (R && "object" == typeof e && R in e)
      );
    }
    function B(e) {
      return !(
        "[object RegExp]" !== V(e) ||
        (R && "object" == typeof e && R in e)
      );
    }
    function F(e) {
      if (A) return e && "object" == typeof e && e instanceof Symbol;
      if ("symbol" == typeof e) return !0;
      if (!e || "object" != typeof e || !T) return !1;
      try {
        return T.call(e), !0;
      } catch {}
      return !1;
    }
    jm = function e(t, i, o, d) {
      var _ = i || {};
      if (
        z(_, "quoteStyle") &&
        "single" !== _.quoteStyle &&
        "double" !== _.quoteStyle
      )
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      if (
        z(_, "maxStringLength") &&
        ("number" == typeof _.maxStringLength
          ? _.maxStringLength < 0 && _.maxStringLength !== 1 / 0
          : null !== _.maxStringLength)
      )
        throw new TypeError(
          'option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`'
        );
      var y = !z(_, "customInspect") || _.customInspect;
      if ("boolean" != typeof y && "symbol" !== y)
        throw new TypeError(
          "option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`"
        );
      if (
        z(_, "indent") &&
        null !== _.indent &&
        "\t" !== _.indent &&
        !(parseInt(_.indent, 10) === _.indent && _.indent > 0)
      )
        throw new TypeError(
          'option "indent" must be "\\t", an integer > 0, or `null`'
        );
      if (z(_, "numericSeparator") && "boolean" != typeof _.numericSeparator)
        throw new TypeError(
          'option "numericSeparator", if provided, must be `true` or `false`'
        );
      var S = _.numericSeparator;
      if (typeof t > "u") return "undefined";
      if (null === t) return "null";
      if ("boolean" == typeof t) return t ? "true" : "false";
      if ("string" == typeof t) return W(t, _);
      if ("number" == typeof t) {
        if (0 === t) return 1 / 0 / t > 0 ? "0" : "-0";
        var M = String(t);
        return S ? I(t, M) : M;
      }
      if ("bigint" == typeof t) {
        var O = String(t) + "n";
        return S ? I(t, O) : O;
      }
      var H = typeof _.depth > "u" ? 5 : _.depth;
      if ((typeof o > "u" && (o = 0), o >= H && H > 0 && "object" == typeof t))
        return k(t) ? "[Array]" : "[Object]";
      var G = (function (e, t) {
        var r;
        if ("\t" === e.indent) r = "\t";
        else {
          if (!("number" == typeof e.indent && e.indent > 0)) return null;
          r = x.call(Array(e.indent + 1), " ");
        }
        return { base: r, prev: x.call(Array(t + 1), r) };
      })(_, o);
      if (typeof d > "u") d = [];
      else if (j(d, t) >= 0) return "[Circular]";
      function Q(t, r, n) {
        if ((r && (d = w.call(d)).push(r), n)) {
          var i = { depth: _.depth };
          return (
            z(_, "quoteStyle") && (i.quoteStyle = _.quoteStyle),
            e(t, i, o + 1, d)
          );
        }
        return e(t, _, o + 1, d);
      }
      if ("function" == typeof t && !B(t)) {
        var J = (function (e) {
            if (e.name) return e.name;
            var t = f.call(p.call(e), /^function\s*([\w$]+)/);
            return t ? t[1] : null;
          })(t),
          Z = $(t, Q);
        return (
          "[Function" +
          (J ? ": " + J : " (anonymous)") +
          "]" +
          (Z.length > 0 ? " { " + x.call(Z, ", ") + " }" : "")
        );
      }
      if (F(t)) {
        var ee = A
          ? g.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1")
          : T.call(t);
        return "object" != typeof t || A ? ee : X(ee);
      }
      if (
        (function (e) {
          return (
            !(!e || "object" != typeof e) &&
            ((typeof HTMLElement < "u" && e instanceof HTMLElement) ||
              ("string" == typeof e.nodeName &&
                "function" == typeof e.getAttribute))
          );
        })(t)
      ) {
        for (
          var te = "<" + v.call(String(t.nodeName)),
            re = t.attributes || [],
            ne = 0;
          ne < re.length;
          ne++
        )
          te += " " + re[ne].name + "=" + U(D(re[ne].value), "double", _);
        return (
          (te += ">"),
          t.childNodes && t.childNodes.length && (te += "..."),
          te + "</" + v.call(String(t.nodeName)) + ">"
        );
      }
      if (k(t)) {
        if (0 === t.length) return "[]";
        var ie = $(t, Q);
        return G &&
          !(function (e) {
            for (var t = 0; t < e.length; t++)
              if (j(e[t], "\n") >= 0) return !1;
            return !0;
          })(ie)
          ? "[" + K(ie, G) + "]"
          : "[ " + x.call(ie, ", ") + " ]";
      }
      if (
        (function (e) {
          return !(
            "[object Error]" !== V(e) ||
            (R && "object" == typeof e && R in e)
          );
        })(t)
      ) {
        var oe = $(t, Q);
        return "cause" in Error.prototype ||
          !("cause" in t) ||
          P.call(t, "cause")
          ? 0 === oe.length
            ? "[" + String(t) + "]"
            : "{ [" + String(t) + "] " + x.call(oe, ", ") + " }"
          : "{ [" +
              String(t) +
              "] " +
              x.call(b.call("[cause]: " + Q(t.cause), oe), ", ") +
              " }";
      }
      if ("object" == typeof t && y) {
        if (N && "function" == typeof t[N] && L) return L(t, { depth: H - o });
        if ("symbol" !== y && "function" == typeof t.inspect)
          return t.inspect();
      }
      if (
        (function (e) {
          if (!r || !e || "object" != typeof e) return !1;
          try {
            r.call(e);
            try {
              s.call(e);
            } catch {
              return !0;
            }
            return e instanceof Map;
          } catch {}
          return !1;
        })(t)
      ) {
        var se = [];
        return (
          n &&
            n.call(t, function (e, r) {
              se.push(Q(r, t, !0) + " => " + Q(e, t));
            }),
          Y("Map", r.call(t), se, G)
        );
      }
      if (
        (function (e) {
          if (!s || !e || "object" != typeof e) return !1;
          try {
            s.call(e);
            try {
              r.call(e);
            } catch {
              return !0;
            }
            return e instanceof Set;
          } catch {}
          return !1;
        })(t)
      ) {
        var ae = [];
        return (
          a &&
            a.call(t, function (e) {
              ae.push(Q(e, t));
            }),
          Y("Set", s.call(t), ae, G)
        );
      }
      if (
        (function (e) {
          if (!l || !e || "object" != typeof e) return !1;
          try {
            l.call(e, l);
            try {
              c.call(e, c);
            } catch {
              return !0;
            }
            return e instanceof WeakMap;
          } catch {}
          return !1;
        })(t)
      )
        return q("WeakMap");
      if (
        (function (e) {
          if (!c || !e || "object" != typeof e) return !1;
          try {
            c.call(e, c);
            try {
              l.call(e, l);
            } catch {
              return !0;
            }
            return e instanceof WeakSet;
          } catch {}
          return !1;
        })(t)
      )
        return q("WeakSet");
      if (
        (function (e) {
          if (!u || !e || "object" != typeof e) return !1;
          try {
            return u.call(e), !0;
          } catch {}
          return !1;
        })(t)
      )
        return q("WeakRef");
      if (
        (function (e) {
          return !(
            "[object Number]" !== V(e) ||
            (R && "object" == typeof e && R in e)
          );
        })(t)
      )
        return X(Q(Number(t)));
      if (
        (function (e) {
          if (!e || "object" != typeof e || !E) return !1;
          try {
            return E.call(e), !0;
          } catch {}
          return !1;
        })(t)
      )
        return X(Q(E.call(t)));
      if (
        (function (e) {
          return !(
            "[object Boolean]" !== V(e) ||
            (R && "object" == typeof e && R in e)
          );
        })(t)
      )
        return X(h.call(t));
      if (
        (function (e) {
          return !(
            "[object String]" !== V(e) ||
            (R && "object" == typeof e && R in e)
          );
        })(t)
      )
        return X(Q(String(t)));
      if (typeof window < "u" && t === window) return "{ [object Window] }";
      if (
        (typeof globalThis < "u" && t === globalThis) ||
        (typeof Gm < "u" && t === Gm)
      )
        return "{ [object globalThis] }";
      if (
        !(function (e) {
          return !(
            "[object Date]" !== V(e) ||
            (R && "object" == typeof e && R in e)
          );
        })(t) &&
        !B(t)
      ) {
        var le = $(t, Q),
          ce = C
            ? C(t) === Object.prototype
            : t instanceof Object || t.constructor === Object,
          ue = t instanceof Object ? "" : "null prototype",
          he =
            !ce && R && Object(t) === t && R in t
              ? m.call(V(t), 8, -1)
              : ue
              ? "Object"
              : "",
          de =
            (ce || "function" != typeof t.constructor
              ? ""
              : t.constructor.name
              ? t.constructor.name + " "
              : "") +
            (he || ue
              ? "[" + x.call(b.call([], he || [], ue || []), ": ") + "] "
              : "");
        return 0 === le.length
          ? de + "{}"
          : G
          ? de + "{" + K(le, G) + "}"
          : de + "{ " + x.call(le, ", ") + " }";
      }
      return String(t);
    };
    var H =
      Object.prototype.hasOwnProperty ||
      function (e) {
        return e in (this || Gm);
      };
    function z(e, t) {
      return H.call(e, t);
    }
    function V(e) {
      return d.call(e);
    }
    function j(e, t) {
      if (e.indexOf) return e.indexOf(t);
      for (var r = 0, n = e.length; r < n; r++) if (e[r] === t) return r;
      return -1;
    }
    function W(e, t) {
      if (e.length > t.maxStringLength) {
        var r = e.length - t.maxStringLength,
          n = "... " + r + " more character" + (r > 1 ? "s" : "");
        return W(m.call(e, 0, t.maxStringLength), t) + n;
      }
      return U(
        g.call(g.call(e, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, G),
        "single",
        t
      );
    }
    function G(e) {
      var t = e.charCodeAt(0),
        r = { 8: "b", 9: "t", 10: "n", 12: "f", 13: "r" }[t];
      return r
        ? "\\" + r
        : "\\x" + (t < 16 ? "0" : "") + _.call(t.toString(16));
    }
    function X(e) {
      return "Object(" + e + ")";
    }
    function q(e) {
      return e + " { ? }";
    }
    function Y(e, t, r, n) {
      return e + " (" + t + ") {" + (n ? K(r, n) : x.call(r, ", ")) + "}";
    }
    function K(e, t) {
      if (0 === e.length) return "";
      var r = "\n" + t.prev + t.base;
      return r + x.call(e, "," + r) + "\n" + t.prev;
    }
    function $(e, t) {
      var r = k(e),
        n = [];
      if (r) {
        n.length = e.length;
        for (var i = 0; i < e.length; i++) n[i] = z(e, i) ? t(e[i], e) : "";
      }
      var o,
        s = "function" == typeof M ? M(e) : [];
      if (A) {
        o = {};
        for (var a = 0; a < s.length; a++) o["$" + s[a]] = s[a];
      }
      for (var l in e)
        z(e, l) &&
          ((r && String(Number(l)) === l && l < e.length) ||
            (A && o["$" + l] instanceof Symbol) ||
            (y.call(/[^\w$]/, l)
              ? n.push(t(l, e) + ": " + t(e[l], e))
              : n.push(l + ": " + t(e[l], e))));
      if ("function" == typeof M)
        for (var c = 0; c < s.length; c++)
          P.call(e, s[c]) && n.push("[" + t(s[c]) + "]: " + t(e[s[c]], e));
      return n;
    }
    return jm;
  }
  function Dm() {
    if (Km) return Ym;
    Km = !0;
    var e = String.prototype.replace,
      t = /%20/g,
      r = "RFC3986";
    return (Ym = {
      default: r,
      formatters: {
        RFC1738: function (r) {
          return e.call(r, t, "+");
        },
        RFC3986: function (e) {
          return String(e);
        },
      },
      RFC1738: "RFC1738",
      RFC3986: r,
    });
  }
  function km() {
    if (Qm) return $m;
    Qm = !0;
    var e = Dm(),
      t = Object.prototype.hasOwnProperty,
      r = Array.isArray,
      n = (function () {
        for (var e = [], t = 0; t < 256; ++t)
          e.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
        return e;
      })(),
      i = function (e, t) {
        for (
          var r = t && t.plainObjects ? Object.create(null) : {}, n = 0;
          n < e.length;
          ++n
        )
          typeof e[n] < "u" && (r[n] = e[n]);
        return r;
      },
      o = 1024;
    return ($m = {
      arrayToObject: i,
      assign: function (e, t) {
        return Object.keys(t).reduce(function (e, r) {
          return (e[r] = t[r]), e;
        }, e);
      },
      combine: function (e, t) {
        return [].concat(e, t);
      },
      compact: function (e) {
        for (
          var t = [{ obj: { o: e }, prop: "o" }], n = [], i = 0;
          i < t.length;
          ++i
        )
          for (
            var o = t[i], s = o.obj[o.prop], a = Object.keys(s), l = 0;
            l < a.length;
            ++l
          ) {
            var c = a[l],
              u = s[c];
            "object" == typeof u &&
              null !== u &&
              -1 === n.indexOf(u) &&
              (t.push({ obj: s, prop: c }), n.push(u));
          }
        return (
          (function (e) {
            for (; e.length > 1; ) {
              var t = e.pop(),
                n = t.obj[t.prop];
              if (r(n)) {
                for (var i = [], o = 0; o < n.length; ++o)
                  typeof n[o] < "u" && i.push(n[o]);
                t.obj[t.prop] = i;
              }
            }
          })(t),
          e
        );
      },
      decode: function (e, t, r) {
        var n = e.replace(/\+/g, " ");
        if ("iso-8859-1" === r) return n.replace(/%[0-9a-f]{2}/gi, unescape);
        try {
          return decodeURIComponent(n);
        } catch {
          return n;
        }
      },
      encode: function (t, r, i, s, a) {
        if (0 === t.length) return t;
        var l = t;
        if (
          ("symbol" == typeof t
            ? (l = Symbol.prototype.toString.call(t))
            : "string" != typeof t && (l = String(t)),
          "iso-8859-1" === i)
        )
          return escape(l).replace(/%u[0-9a-f]{4}/gi, function (e) {
            return "%26%23" + parseInt(e.slice(2), 16) + "%3B";
          });
        for (var c = "", u = 0; u < l.length; u += o) {
          for (
            var h = l.length >= o ? l.slice(u, u + o) : l, d = [], p = 0;
            p < h.length;
            ++p
          ) {
            var f = h.charCodeAt(p);
            45 === f ||
            46 === f ||
            95 === f ||
            126 === f ||
            (f >= 48 && f <= 57) ||
            (f >= 65 && f <= 90) ||
            (f >= 97 && f <= 122) ||
            (a === e.RFC1738 && (40 === f || 41 === f))
              ? (d[d.length] = h.charAt(p))
              : f < 128
              ? (d[d.length] = n[f])
              : f < 2048
              ? (d[d.length] = n[192 | (f >> 6)] + n[128 | (63 & f)])
              : f < 55296 || f >= 57344
              ? (d[d.length] =
                  n[224 | (f >> 12)] +
                  n[128 | ((f >> 6) & 63)] +
                  n[128 | (63 & f)])
              : ((p += 1),
                (f = 65536 + (((1023 & f) << 10) | (1023 & h.charCodeAt(p)))),
                (d[d.length] =
                  n[240 | (f >> 18)] +
                  n[128 | ((f >> 12) & 63)] +
                  n[128 | ((f >> 6) & 63)] +
                  n[128 | (63 & f)]));
          }
          c += d.join("");
        }
        return c;
      },
      isBuffer: function (e) {
        return !(
          !e ||
          "object" != typeof e ||
          !(
            e.constructor &&
            e.constructor.isBuffer &&
            e.constructor.isBuffer(e)
          )
        );
      },
      isRegExp: function (e) {
        return "[object RegExp]" === Object.prototype.toString.call(e);
      },
      maybeMap: function (e, t) {
        if (r(e)) {
          for (var n = [], i = 0; i < e.length; i += 1) n.push(t(e[i]));
          return n;
        }
        return t(e);
      },
      merge: function e(n, o, s) {
        if (!o) return n;
        if ("object" != typeof o) {
          if (r(n)) n.push(o);
          else {
            if (!n || "object" != typeof n) return [n, o];
            ((s && (s.plainObjects || s.allowPrototypes)) ||
              !t.call(Object.prototype, o)) &&
              (n[o] = !0);
          }
          return n;
        }
        if (!n || "object" != typeof n) return [n].concat(o);
        var a = n;
        return (
          r(n) && !r(o) && (a = i(n, s)),
          r(n) && r(o)
            ? (o.forEach(function (r, i) {
                if (t.call(n, i)) {
                  var o = n[i];
                  o && "object" == typeof o && r && "object" == typeof r
                    ? (n[i] = e(o, r, s))
                    : n.push(r);
                } else n[i] = r;
              }),
              n)
            : Object.keys(o).reduce(function (r, n) {
                var i = o[n];
                return t.call(r, n) ? (r[n] = e(r[n], i, s)) : (r[n] = i), r;
              }, a)
        );
      },
    });
  }
  function Bm() {
    if (Zm) return Jm;
    Zm = !0;
    var e = (function () {
        if (qm) return Xm;
        qm = !0;
        var e = Ip(),
          t = Np(),
          r = Um(),
          n = Pp(),
          i = e("%WeakMap%", !0),
          o = e("%Map%", !0),
          s = t("WeakMap.prototype.get", !0),
          a = t("WeakMap.prototype.set", !0),
          l = t("WeakMap.prototype.has", !0),
          c = t("Map.prototype.get", !0),
          u = t("Map.prototype.set", !0),
          h = t("Map.prototype.has", !0),
          d = function (e, t) {
            for (var r, n = e; null !== (r = n.next); n = r)
              if (r.key === t)
                return (n.next = r.next), (r.next = e.next), (e.next = r), r;
          };
        return (Xm = function () {
          var e,
            t,
            p,
            f = {
              assert: function (e) {
                if (!f.has(e))
                  throw new n("Side channel does not contain " + r(e));
              },
              get: function (r) {
                if (
                  i &&
                  r &&
                  ("object" == typeof r || "function" == typeof r)
                ) {
                  if (e) return s(e, r);
                } else if (o) {
                  if (t) return c(t, r);
                } else if (p)
                  return (function (e, t) {
                    var r = d(e, t);
                    return r && r.value;
                  })(p, r);
              },
              has: function (r) {
                if (
                  i &&
                  r &&
                  ("object" == typeof r || "function" == typeof r)
                ) {
                  if (e) return l(e, r);
                } else if (o) {
                  if (t) return h(t, r);
                } else if (p)
                  return (function (e, t) {
                    return !!d(e, t);
                  })(p, r);
                return !1;
              },
              set: function (r, n) {
                i && r && ("object" == typeof r || "function" == typeof r)
                  ? (e || (e = new i()), a(e, r, n))
                  : o
                  ? (t || (t = new o()), u(t, r, n))
                  : (p || (p = { key: {}, next: null }),
                    (function (e, t, r) {
                      var n = d(e, t);
                      n
                        ? (n.value = r)
                        : (e.next = { key: t, next: e.next, value: r });
                    })(p, r, n));
              },
            };
          return f;
        });
      })(),
      t = km(),
      r = Dm(),
      n = Object.prototype.hasOwnProperty,
      i = {
        brackets: function (e) {
          return e + "[]";
        },
        comma: "comma",
        indices: function (e, t) {
          return e + "[" + t + "]";
        },
        repeat: function (e) {
          return e;
        },
      },
      o = Array.isArray,
      s = Array.prototype.push,
      a = function (e, t) {
        s.apply(e, o(t) ? t : [t]);
      },
      l = Date.prototype.toISOString,
      c = r.default,
      u = {
        addQueryPrefix: !1,
        allowDots: !1,
        allowEmptyArrays: !1,
        arrayFormat: "indices",
        charset: "utf-8",
        charsetSentinel: !1,
        delimiter: "&",
        encode: !0,
        encodeDotInKeys: !1,
        encoder: t.encode,
        encodeValuesOnly: !1,
        format: c,
        formatter: r.formatters[c],
        indices: !1,
        serializeDate: function (e) {
          return l.call(e);
        },
        skipNulls: !1,
        strictNullHandling: !1,
      },
      h = {},
      d = function r(n, i, s, l, c, d, p, f, m, g, _, v, y, b, x, w, S, E) {
        for (
          var M = n, T = E, A = 0, R = !1;
          void 0 !== (T = T.get(h)) && !R;

        ) {
          var P = T.get(n);
          if (((A += 1), typeof P < "u")) {
            if (P === A) throw new RangeError("Cyclic object value");
            R = !0;
          }
          typeof T.get(h) > "u" && (A = 0);
        }
        if (
          ("function" == typeof g
            ? (M = g(i, M))
            : M instanceof Date
            ? (M = y(M))
            : "comma" === s &&
              o(M) &&
              (M = t.maybeMap(M, function (e) {
                return e instanceof Date ? y(e) : e;
              })),
          null === M)
        ) {
          if (d) return m && !w ? m(i, u.encoder, S, "key", b) : i;
          M = "";
        }
        if (
          (function (e) {
            return (
              "string" == typeof e ||
              "number" == typeof e ||
              "boolean" == typeof e ||
              "symbol" == typeof e ||
              "bigint" == typeof e
            );
          })(M) ||
          t.isBuffer(M)
        )
          return m
            ? [
                x(w ? i : m(i, u.encoder, S, "key", b)) +
                  "=" +
                  x(m(M, u.encoder, S, "value", b)),
              ]
            : [x(i) + "=" + x(String(M))];
        var C,
          I = [];
        if (typeof M > "u") return I;
        if ("comma" === s && o(M))
          w && m && (M = t.maybeMap(M, m)),
            (C = [{ value: M.length > 0 ? M.join(",") || null : void 0 }]);
        else if (o(g)) C = g;
        else {
          var L = Object.keys(M);
          C = _ ? L.sort(_) : L;
        }
        var O = f ? i.replace(/\./g, "%2E") : i,
          N = l && o(M) && 1 === M.length ? O + "[]" : O;
        if (c && o(M) && 0 === M.length) return N + "[]";
        for (var U = 0; U < C.length; ++U) {
          var D = C[U],
            k = "object" == typeof D && typeof D.value < "u" ? D.value : M[D];
          if (!p || null !== k) {
            var B = v && f ? D.replace(/\./g, "%2E") : D,
              F = o(M)
                ? "function" == typeof s
                  ? s(N, B)
                  : N
                : N + (v ? "." + B : "[" + B + "]");
            E.set(n, A);
            var H = e();
            H.set(h, E),
              a(
                I,
                r(
                  k,
                  F,
                  s,
                  l,
                  c,
                  d,
                  p,
                  f,
                  "comma" === s && w && o(M) ? null : m,
                  g,
                  _,
                  v,
                  y,
                  b,
                  x,
                  w,
                  S,
                  H
                )
              );
          }
        }
        return I;
      };
    return (Jm = function (t, s) {
      var l,
        c = t,
        h = (function (e) {
          if (!e) return u;
          if (
            typeof e.allowEmptyArrays < "u" &&
            "boolean" != typeof e.allowEmptyArrays
          )
            throw new TypeError(
              "`allowEmptyArrays` option can only be `true` or `false`, when provided"
            );
          if (
            typeof e.encodeDotInKeys < "u" &&
            "boolean" != typeof e.encodeDotInKeys
          )
            throw new TypeError(
              "`encodeDotInKeys` option can only be `true` or `false`, when provided"
            );
          if (
            null !== e.encoder &&
            typeof e.encoder < "u" &&
            "function" != typeof e.encoder
          )
            throw new TypeError("Encoder has to be a function.");
          var t = e.charset || u.charset;
          if (
            typeof e.charset < "u" &&
            "utf-8" !== e.charset &&
            "iso-8859-1" !== e.charset
          )
            throw new TypeError(
              "The charset option must be either utf-8, iso-8859-1, or undefined"
            );
          var s = r.default;
          if (typeof e.format < "u") {
            if (!n.call(r.formatters, e.format))
              throw new TypeError("Unknown format option provided.");
            s = e.format;
          }
          var a,
            l = r.formatters[s],
            c = u.filter;
          if (
            (("function" == typeof e.filter || o(e.filter)) && (c = e.filter),
            (a =
              e.arrayFormat in i
                ? e.arrayFormat
                : "indices" in e
                ? e.indices
                  ? "indices"
                  : "repeat"
                : u.arrayFormat),
            "commaRoundTrip" in e && "boolean" != typeof e.commaRoundTrip)
          )
            throw new TypeError(
              "`commaRoundTrip` must be a boolean, or absent"
            );
          var h =
            typeof e.allowDots > "u"
              ? !0 === e.encodeDotInKeys || u.allowDots
              : !!e.allowDots;
          return {
            addQueryPrefix:
              "boolean" == typeof e.addQueryPrefix
                ? e.addQueryPrefix
                : u.addQueryPrefix,
            allowDots: h,
            allowEmptyArrays:
              "boolean" == typeof e.allowEmptyArrays
                ? !!e.allowEmptyArrays
                : u.allowEmptyArrays,
            arrayFormat: a,
            charset: t,
            charsetSentinel:
              "boolean" == typeof e.charsetSentinel
                ? e.charsetSentinel
                : u.charsetSentinel,
            commaRoundTrip: e.commaRoundTrip,
            delimiter: typeof e.delimiter > "u" ? u.delimiter : e.delimiter,
            encode: "boolean" == typeof e.encode ? e.encode : u.encode,
            encodeDotInKeys:
              "boolean" == typeof e.encodeDotInKeys
                ? e.encodeDotInKeys
                : u.encodeDotInKeys,
            encoder: "function" == typeof e.encoder ? e.encoder : u.encoder,
            encodeValuesOnly:
              "boolean" == typeof e.encodeValuesOnly
                ? e.encodeValuesOnly
                : u.encodeValuesOnly,
            filter: c,
            format: s,
            formatter: l,
            serializeDate:
              "function" == typeof e.serializeDate
                ? e.serializeDate
                : u.serializeDate,
            skipNulls:
              "boolean" == typeof e.skipNulls ? e.skipNulls : u.skipNulls,
            sort: "function" == typeof e.sort ? e.sort : null,
            strictNullHandling:
              "boolean" == typeof e.strictNullHandling
                ? e.strictNullHandling
                : u.strictNullHandling,
          };
        })(s);
      "function" == typeof h.filter
        ? (c = (0, h.filter)("", c))
        : o(h.filter) && (l = h.filter);
      var p = [];
      if ("object" != typeof c || null === c) return "";
      var f = i[h.arrayFormat],
        m = "comma" === f && h.commaRoundTrip;
      l || (l = Object.keys(c)), h.sort && l.sort(h.sort);
      for (var g = e(), _ = 0; _ < l.length; ++_) {
        var v = l[_];
        (h.skipNulls && null === c[v]) ||
          a(
            p,
            d(
              c[v],
              v,
              f,
              m,
              h.allowEmptyArrays,
              h.strictNullHandling,
              h.skipNulls,
              h.encodeDotInKeys,
              h.encode ? h.encoder : null,
              h.filter,
              h.sort,
              h.allowDots,
              h.serializeDate,
              h.format,
              h.formatter,
              h.encodeValuesOnly,
              h.charset,
              g
            )
          );
      }
      var y = p.join(h.delimiter),
        b = !0 === h.addQueryPrefix ? "?" : "";
      return (
        h.charsetSentinel &&
          ("iso-8859-1" === h.charset
            ? (b += "utf8=%26%2310003%3B&")
            : (b += "utf8=%E2%9C%93&")),
        y.length > 0 ? b + y : ""
      );
    });
  }
  function Fm() {
    if (og) return ig;
    og = !0;
    var e = Mh;
    function t() {
      (this.protocol = null),
        (this.slashes = null),
        (this.auth = null),
        (this.host = null),
        (this.port = null),
        (this.hostname = null),
        (this.hash = null),
        (this.search = null),
        (this.query = null),
        (this.pathname = null),
        (this.path = null),
        (this.href = null);
    }
    var r = /^([a-z0-9.+-]+:)/i,
      n = /:[0-9]*$/,
      i = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,
      o = ["{", "}", "|", "\\", "^", "`"].concat([
        "<",
        ">",
        '"',
        "`",
        " ",
        "\r",
        "\n",
        "\t",
      ]),
      s = ["'"].concat(o),
      a = ["%", "/", "?", ";", "#"].concat(s),
      l = ["/", "?", "#"],
      c = /^[+a-z0-9A-Z_-]{0,63}$/,
      u = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
      h = { javascript: !0, "javascript:": !0 },
      d = { javascript: !0, "javascript:": !0 },
      p = {
        http: !0,
        https: !0,
        ftp: !0,
        gopher: !0,
        file: !0,
        "http:": !0,
        "https:": !0,
        "ftp:": !0,
        "gopher:": !0,
        "file:": !0,
      },
      f = (function () {
        if (ng) return rg;
        ng = !0;
        var e = Bm(),
          t = (function () {
            if (tg) return eg;
            tg = !0;
            var e = km(),
              t = Object.prototype.hasOwnProperty,
              r = Array.isArray,
              n = {
                allowDots: !1,
                allowEmptyArrays: !1,
                allowPrototypes: !1,
                allowSparse: !1,
                arrayLimit: 20,
                charset: "utf-8",
                charsetSentinel: !1,
                comma: !1,
                decodeDotInKeys: !1,
                decoder: e.decode,
                delimiter: "&",
                depth: 5,
                duplicates: "combine",
                ignoreQueryPrefix: !1,
                interpretNumericEntities: !1,
                parameterLimit: 1e3,
                parseArrays: !0,
                plainObjects: !1,
                strictDepth: !1,
                strictNullHandling: !1,
              },
              i = function (e) {
                return e.replace(/&#(\d+);/g, function (e, t) {
                  return String.fromCharCode(parseInt(t, 10));
                });
              },
              o = function (e, t) {
                return e &&
                  "string" == typeof e &&
                  t.comma &&
                  e.indexOf(",") > -1
                  ? e.split(",")
                  : e;
              },
              s = function (e, r, n, i) {
                if (e) {
                  var s = n.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e,
                    a = /(\[[^[\]]*])/g,
                    l = n.depth > 0 && /(\[[^[\]]*])/.exec(s),
                    c = l ? s.slice(0, l.index) : s,
                    u = [];
                  if (c) {
                    if (
                      !n.plainObjects &&
                      t.call(Object.prototype, c) &&
                      !n.allowPrototypes
                    )
                      return;
                    u.push(c);
                  }
                  for (
                    var h = 0;
                    n.depth > 0 && null !== (l = a.exec(s)) && h < n.depth;

                  ) {
                    if (
                      ((h += 1),
                      !n.plainObjects &&
                        t.call(Object.prototype, l[1].slice(1, -1)) &&
                        !n.allowPrototypes)
                    )
                      return;
                    u.push(l[1]);
                  }
                  if (l) {
                    if (!0 === n.strictDepth)
                      throw new RangeError(
                        "Input depth exceeded depth option of " +
                          n.depth +
                          " and strictDepth is true"
                      );
                    u.push("[" + s.slice(l.index) + "]");
                  }
                  return (function (e, t, r, n) {
                    for (
                      var i = n ? t : o(t, r), s = e.length - 1;
                      s >= 0;
                      --s
                    ) {
                      var a,
                        l = e[s];
                      if ("[]" === l && r.parseArrays)
                        a =
                          r.allowEmptyArrays &&
                          ("" === i || (r.strictNullHandling && null === i))
                            ? []
                            : [].concat(i);
                      else {
                        a = r.plainObjects ? Object.create(null) : {};
                        var c =
                            "[" === l.charAt(0) &&
                            "]" === l.charAt(l.length - 1)
                              ? l.slice(1, -1)
                              : l,
                          u = r.decodeDotInKeys ? c.replace(/%2E/g, ".") : c,
                          h = parseInt(u, 10);
                        r.parseArrays || "" !== u
                          ? !isNaN(h) &&
                            l !== u &&
                            String(h) === u &&
                            h >= 0 &&
                            r.parseArrays &&
                            h <= r.arrayLimit
                            ? ((a = [])[h] = i)
                            : "__proto__" !== u && (a[u] = i)
                          : (a = { 0: i });
                      }
                      i = a;
                    }
                    return i;
                  })(u, r, n, i);
                }
              };
            return (eg = function (a, l) {
              var c = (function (t) {
                if (!t) return n;
                if (
                  typeof t.allowEmptyArrays < "u" &&
                  "boolean" != typeof t.allowEmptyArrays
                )
                  throw new TypeError(
                    "`allowEmptyArrays` option can only be `true` or `false`, when provided"
                  );
                if (
                  typeof t.decodeDotInKeys < "u" &&
                  "boolean" != typeof t.decodeDotInKeys
                )
                  throw new TypeError(
                    "`decodeDotInKeys` option can only be `true` or `false`, when provided"
                  );
                if (
                  null !== t.decoder &&
                  typeof t.decoder < "u" &&
                  "function" != typeof t.decoder
                )
                  throw new TypeError("Decoder has to be a function.");
                if (
                  typeof t.charset < "u" &&
                  "utf-8" !== t.charset &&
                  "iso-8859-1" !== t.charset
                )
                  throw new TypeError(
                    "The charset option must be either utf-8, iso-8859-1, or undefined"
                  );
                var r = typeof t.charset > "u" ? n.charset : t.charset,
                  i = typeof t.duplicates > "u" ? n.duplicates : t.duplicates;
                if ("combine" !== i && "first" !== i && "last" !== i)
                  throw new TypeError(
                    "The duplicates option must be either combine, first, or last"
                  );
                return {
                  allowDots:
                    typeof t.allowDots > "u"
                      ? !0 === t.decodeDotInKeys || n.allowDots
                      : !!t.allowDots,
                  allowEmptyArrays:
                    "boolean" == typeof t.allowEmptyArrays
                      ? !!t.allowEmptyArrays
                      : n.allowEmptyArrays,
                  allowPrototypes:
                    "boolean" == typeof t.allowPrototypes
                      ? t.allowPrototypes
                      : n.allowPrototypes,
                  allowSparse:
                    "boolean" == typeof t.allowSparse
                      ? t.allowSparse
                      : n.allowSparse,
                  arrayLimit:
                    "number" == typeof t.arrayLimit
                      ? t.arrayLimit
                      : n.arrayLimit,
                  charset: r,
                  charsetSentinel:
                    "boolean" == typeof t.charsetSentinel
                      ? t.charsetSentinel
                      : n.charsetSentinel,
                  comma: "boolean" == typeof t.comma ? t.comma : n.comma,
                  decodeDotInKeys:
                    "boolean" == typeof t.decodeDotInKeys
                      ? t.decodeDotInKeys
                      : n.decodeDotInKeys,
                  decoder:
                    "function" == typeof t.decoder ? t.decoder : n.decoder,
                  delimiter:
                    "string" == typeof t.delimiter || e.isRegExp(t.delimiter)
                      ? t.delimiter
                      : n.delimiter,
                  depth:
                    "number" == typeof t.depth || !1 === t.depth
                      ? +t.depth
                      : n.depth,
                  duplicates: i,
                  ignoreQueryPrefix: !0 === t.ignoreQueryPrefix,
                  interpretNumericEntities:
                    "boolean" == typeof t.interpretNumericEntities
                      ? t.interpretNumericEntities
                      : n.interpretNumericEntities,
                  parameterLimit:
                    "number" == typeof t.parameterLimit
                      ? t.parameterLimit
                      : n.parameterLimit,
                  parseArrays: !1 !== t.parseArrays,
                  plainObjects:
                    "boolean" == typeof t.plainObjects
                      ? t.plainObjects
                      : n.plainObjects,
                  strictDepth:
                    "boolean" == typeof t.strictDepth
                      ? !!t.strictDepth
                      : n.strictDepth,
                  strictNullHandling:
                    "boolean" == typeof t.strictNullHandling
                      ? t.strictNullHandling
                      : n.strictNullHandling,
                };
              })(l);
              if ("" === a || null === a || typeof a > "u")
                return c.plainObjects ? Object.create(null) : {};
              for (
                var u =
                    "string" == typeof a
                      ? (function (s, a) {
                          var l = { __proto__: null },
                            c = a.ignoreQueryPrefix ? s.replace(/^\?/, "") : s;
                          c = c.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
                          var u,
                            h =
                              a.parameterLimit === 1 / 0
                                ? void 0
                                : a.parameterLimit,
                            d = c.split(a.delimiter, h),
                            p = -1,
                            f = a.charset;
                          if (a.charsetSentinel)
                            for (u = 0; u < d.length; ++u)
                              0 === d[u].indexOf("utf8=") &&
                                ("utf8=%E2%9C%93" === d[u]
                                  ? (f = "utf-8")
                                  : "utf8=%26%2310003%3B" === d[u] &&
                                    (f = "iso-8859-1"),
                                (p = u),
                                (u = d.length));
                          for (u = 0; u < d.length; ++u)
                            if (u !== p) {
                              var m,
                                g,
                                _ = d[u],
                                v = _.indexOf("]="),
                                y = -1 === v ? _.indexOf("=") : v + 1;
                              -1 === y
                                ? ((m = a.decoder(_, n.decoder, f, "key")),
                                  (g = a.strictNullHandling ? null : ""))
                                : ((m = a.decoder(
                                    _.slice(0, y),
                                    n.decoder,
                                    f,
                                    "key"
                                  )),
                                  (g = e.maybeMap(
                                    o(_.slice(y + 1), a),
                                    function (e) {
                                      return a.decoder(
                                        e,
                                        n.decoder,
                                        f,
                                        "value"
                                      );
                                    }
                                  ))),
                                g &&
                                  a.interpretNumericEntities &&
                                  "iso-8859-1" === f &&
                                  (g = i(g)),
                                _.indexOf("[]=") > -1 && (g = r(g) ? [g] : g);
                              var b = t.call(l, m);
                              b && "combine" === a.duplicates
                                ? (l[m] = e.combine(l[m], g))
                                : (!b || "last" === a.duplicates) && (l[m] = g);
                            }
                          return l;
                        })(a, c)
                      : a,
                  h = c.plainObjects ? Object.create(null) : {},
                  d = Object.keys(u),
                  p = 0;
                p < d.length;
                ++p
              ) {
                var f = d[p],
                  m = s(f, u[f], c, "string" == typeof a);
                h = e.merge(h, m, c);
              }
              return !0 === c.allowSparse ? h : e.compact(h);
            });
          })(),
          r = Dm();
        return (rg = { formats: r, parse: t, stringify: e });
      })();
    function m(e, r, n) {
      if (e && "object" == typeof e && e instanceof t) return e;
      var i = new t();
      return i.parse(e, r, n), i;
    }
    return (
      (t.prototype.parse = function (t, n, o) {
        if ("string" != typeof t)
          throw new TypeError(
            "Parameter 'url' must be a string, not " + typeof t
          );
        var m = t.indexOf("?"),
          g = -1 !== m && m < t.indexOf("#") ? "?" : "#",
          _ = t.split(g);
        _[0] = _[0].replace(/\\/g, "/");
        var v = (t = _.join(g));
        if (((v = v.trim()), !o && 1 === t.split("#").length)) {
          var y = i.exec(v);
          if (y)
            return (
              (this.path = v),
              (this.href = v),
              (this.pathname = y[1]),
              y[2]
                ? ((this.search = y[2]),
                  (this.query = n
                    ? f.parse(this.search.substr(1))
                    : this.search.substr(1)))
                : n && ((this.search = ""), (this.query = {})),
              this
            );
        }
        var b = r.exec(v);
        if (b) {
          var x = (b = b[0]).toLowerCase();
          (this.protocol = x), (v = v.substr(b.length));
        }
        if (o || b || v.match(/^\/\/[^@/]+@[^@/]+/)) {
          var w = "//" === v.substr(0, 2);
          w && (!b || !d[b]) && ((v = v.substr(2)), (this.slashes = !0));
        }
        if (!d[b] && (w || (b && !p[b]))) {
          for (var S = -1, E = 0; E < l.length; E++)
            -1 !== (A = v.indexOf(l[E])) && (-1 === S || A < S) && (S = A);
          var M, T;
          for (
            -1 !==
              (T = -1 === S ? v.lastIndexOf("@") : v.lastIndexOf("@", S)) &&
              ((M = v.slice(0, T)),
              (v = v.slice(T + 1)),
              (this.auth = decodeURIComponent(M))),
              S = -1,
              E = 0;
            E < a.length;
            E++
          ) {
            var A;
            -1 !== (A = v.indexOf(a[E])) && (-1 === S || A < S) && (S = A);
          }
          -1 === S && (S = v.length),
            (this.host = v.slice(0, S)),
            (v = v.slice(S)),
            this.parseHost(),
            (this.hostname = this.hostname || "");
          var R =
            "[" === this.hostname[0] &&
            "]" === this.hostname[this.hostname.length - 1];
          if (!R)
            for (
              var P = this.hostname.split(/\./), C = ((E = 0), P.length);
              E < C;
              E++
            ) {
              var I = P[E];
              if (I && !I.match(c)) {
                for (var L = "", O = 0, N = I.length; O < N; O++)
                  I.charCodeAt(O) > 127 ? (L += "x") : (L += I[O]);
                if (!L.match(c)) {
                  var U = P.slice(0, E),
                    D = P.slice(E + 1),
                    k = I.match(u);
                  k && (U.push(k[1]), D.unshift(k[2])),
                    D.length && (v = "/" + D.join(".") + v),
                    (this.hostname = U.join("."));
                  break;
                }
              }
            }
          this.hostname.length > 255
            ? (this.hostname = "")
            : (this.hostname = this.hostname.toLowerCase()),
            R || (this.hostname = e.toASCII(this.hostname));
          var B = this.port ? ":" + this.port : "",
            F = this.hostname || "";
          (this.host = F + B),
            (this.href += this.host),
            R &&
              ((this.hostname = this.hostname.substr(
                1,
                this.hostname.length - 2
              )),
              "/" !== v[0] && (v = "/" + v));
        }
        if (!h[x])
          for (E = 0, C = s.length; E < C; E++) {
            var H = s[E];
            if (-1 !== v.indexOf(H)) {
              var z = encodeURIComponent(H);
              z === H && (z = escape(H)), (v = v.split(H).join(z));
            }
          }
        var V = v.indexOf("#");
        -1 !== V && ((this.hash = v.substr(V)), (v = v.slice(0, V)));
        var j = v.indexOf("?");
        if (
          (-1 !== j
            ? ((this.search = v.substr(j)),
              (this.query = v.substr(j + 1)),
              n && (this.query = f.parse(this.query)),
              (v = v.slice(0, j)))
            : n && ((this.search = ""), (this.query = {})),
          v && (this.pathname = v),
          p[x] && this.hostname && !this.pathname && (this.pathname = "/"),
          this.pathname || this.search)
        ) {
          B = this.pathname || "";
          var W = this.search || "";
          this.path = B + W;
        }
        return (this.href = this.format()), this;
      }),
      (t.prototype.format = function () {
        var e = this.auth || "";
        e &&
          ((e = (e = encodeURIComponent(e)).replace(/%3A/i, ":")), (e += "@"));
        var t = this.protocol || "",
          r = this.pathname || "",
          n = this.hash || "",
          i = !1,
          o = "";
        this.host
          ? (i = e + this.host)
          : this.hostname &&
            ((i =
              e +
              (-1 === this.hostname.indexOf(":")
                ? this.hostname
                : "[" + this.hostname + "]")),
            this.port && (i += ":" + this.port)),
          this.query &&
            "object" == typeof this.query &&
            Object.keys(this.query).length &&
            (o = f.stringify(this.query, {
              arrayFormat: "repeat",
              addQueryPrefix: !1,
            }));
        var s = this.search || (o && "?" + o) || "";
        return (
          t && ":" !== t.substr(-1) && (t += ":"),
          this.slashes || ((!t || p[t]) && !1 !== i)
            ? ((i = "//" + (i || "")),
              r && "/" !== r.charAt(0) && (r = "/" + r))
            : i || (i = ""),
          n && "#" !== n.charAt(0) && (n = "#" + n),
          s && "?" !== s.charAt(0) && (s = "?" + s),
          t +
            i +
            (r = r.replace(/[?#]/g, function (e) {
              return encodeURIComponent(e);
            })) +
            (s = s.replace("#", "%23")) +
            n
        );
      }),
      (t.prototype.resolve = function (e) {
        return this.resolveObject(m(e, !1, !0)).format();
      }),
      (t.prototype.resolveObject = function (e) {
        if ("string" == typeof e) {
          var r = new t();
          r.parse(e, !1, !0), (e = r);
        }
        for (var n = new t(), i = Object.keys(this), o = 0; o < i.length; o++) {
          var s = i[o];
          n[s] = this[s];
        }
        if (((n.hash = e.hash), "" === e.href)) return (n.href = n.format()), n;
        if (e.slashes && !e.protocol) {
          for (var a = Object.keys(e), l = 0; l < a.length; l++) {
            var c = a[l];
            "protocol" !== c && (n[c] = e[c]);
          }
          return (
            p[n.protocol] &&
              n.hostname &&
              !n.pathname &&
              ((n.pathname = "/"), (n.path = n.pathname)),
            (n.href = n.format()),
            n
          );
        }
        if (e.protocol && e.protocol !== n.protocol) {
          if (!p[e.protocol]) {
            for (var u = Object.keys(e), h = 0; h < u.length; h++) {
              var f = u[h];
              n[f] = e[f];
            }
            return (n.href = n.format()), n;
          }
          if (((n.protocol = e.protocol), e.host || d[e.protocol]))
            n.pathname = e.pathname;
          else {
            for (
              var m = (e.pathname || "").split("/");
              m.length && !(e.host = m.shift());

            );
            e.host || (e.host = ""),
              e.hostname || (e.hostname = ""),
              "" !== m[0] && m.unshift(""),
              m.length < 2 && m.unshift(""),
              (n.pathname = m.join("/"));
          }
          if (
            ((n.search = e.search),
            (n.query = e.query),
            (n.host = e.host || ""),
            (n.auth = e.auth),
            (n.hostname = e.hostname || e.host),
            (n.port = e.port),
            n.pathname || n.search)
          ) {
            var g = n.pathname || "",
              _ = n.search || "";
            n.path = g + _;
          }
          return (n.slashes = n.slashes || e.slashes), (n.href = n.format()), n;
        }
        var v = n.pathname && "/" === n.pathname.charAt(0),
          y = e.host || (e.pathname && "/" === e.pathname.charAt(0)),
          b = y || v || (n.host && e.pathname),
          x = b,
          w = (n.pathname && n.pathname.split("/")) || [],
          S =
            ((m = (e.pathname && e.pathname.split("/")) || []),
            n.protocol && !p[n.protocol]);
        if (
          (S &&
            ((n.hostname = ""),
            (n.port = null),
            n.host && ("" === w[0] ? (w[0] = n.host) : w.unshift(n.host)),
            (n.host = ""),
            e.protocol &&
              ((e.hostname = null),
              (e.port = null),
              e.host && ("" === m[0] ? (m[0] = e.host) : m.unshift(e.host)),
              (e.host = null)),
            (b = b && ("" === m[0] || "" === w[0]))),
          y)
        )
          (n.host = e.host || "" === e.host ? e.host : n.host),
            (n.hostname =
              e.hostname || "" === e.hostname ? e.hostname : n.hostname),
            (n.search = e.search),
            (n.query = e.query),
            (w = m);
        else if (m.length)
          w || (w = []),
            w.pop(),
            (w = w.concat(m)),
            (n.search = e.search),
            (n.query = e.query);
        else if (null != e.search)
          return (
            S &&
              ((n.host = w.shift()),
              (n.hostname = n.host),
              (R =
                !!(n.host && n.host.indexOf("@") > 0) && n.host.split("@")) &&
                ((n.auth = R.shift()),
                (n.hostname = R.shift()),
                (n.host = n.hostname))),
            (n.search = e.search),
            (n.query = e.query),
            (null !== n.pathname || null !== n.search) &&
              (n.path =
                (n.pathname ? n.pathname : "") + (n.search ? n.search : "")),
            (n.href = n.format()),
            n
          );
        if (!w.length)
          return (
            (n.pathname = null),
            n.search ? (n.path = "/" + n.search) : (n.path = null),
            (n.href = n.format()),
            n
          );
        for (
          var E = w.slice(-1)[0],
            M =
              ((n.host || e.host || w.length > 1) &&
                ("." === E || ".." === E)) ||
              "" === E,
            T = 0,
            A = w.length;
          A >= 0;
          A--
        )
          "." === (E = w[A])
            ? w.splice(A, 1)
            : ".." === E
            ? (w.splice(A, 1), T++)
            : T && (w.splice(A, 1), T--);
        if (!b && !x) for (; T--; T) w.unshift("..");
        b && "" !== w[0] && (!w[0] || "/" !== w[0].charAt(0)) && w.unshift(""),
          M && "/" !== w.join("/").substr(-1) && w.push("");
        var R,
          P = "" === w[0] || (w[0] && "/" === w[0].charAt(0));
        return (
          S &&
            ((n.hostname = P ? "" : w.length ? w.shift() : ""),
            (n.host = n.hostname),
            (R = !!(n.host && n.host.indexOf("@") > 0) && n.host.split("@")) &&
              ((n.auth = R.shift()),
              (n.hostname = R.shift()),
              (n.host = n.hostname))),
          (b = b || (n.host && w.length)) && !P && w.unshift(""),
          w.length > 0
            ? (n.pathname = w.join("/"))
            : ((n.pathname = null), (n.path = null)),
          (null !== n.pathname || null !== n.search) &&
            (n.path =
              (n.pathname ? n.pathname : "") + (n.search ? n.search : "")),
          (n.auth = e.auth || n.auth),
          (n.slashes = n.slashes || e.slashes),
          (n.href = n.format()),
          n
        );
      }),
      (t.prototype.parseHost = function () {
        var e = this.host,
          t = n.exec(e);
        t &&
          (":" !== (t = t[0]) && (this.port = t.substr(1)),
          (e = e.substr(0, e.length - t.length))),
          e && (this.hostname = e);
      }),
      (ig.parse = m),
      (ig.resolve = function (e, t) {
        return m(e, !1, !0).resolve(t);
      }),
      (ig.resolveObject = function (e, t) {
        return e ? m(e, !1, !0).resolveObject(t) : t;
      }),
      (ig.format = function (e) {
        return (
          "string" == typeof e && (e = m(e)),
          e instanceof t ? e.format() : t.prototype.format.call(e)
        );
      }),
      (ig.Url = t),
      ig
    );
  }
  function Hm(e) {
    if ("string" == typeof e) e = new URL(e);
    else if (!(e instanceof URL))
      throw new Deno.errors.InvalidData(
        "invalid argument path , must be a string or URL"
      );
    if ("file:" !== e.protocol)
      throw new Deno.errors.InvalidData("invalid url scheme");
    return vg
      ? (function (e) {
          let t = e.hostname,
            r = e.pathname;
          for (let e = 0; e < r.length; e++)
            if ("%" === r[e]) {
              let t = r.codePointAt(e + 2) || 32;
              if (
                ("2" === r[e + 1] && 102 === t) ||
                ("5" === r[e + 1] && 99 === t)
              )
                throw new Deno.errors.InvalidData(
                  "must not include encoded \\ or / characters"
                );
            }
          if (
            ((r = r.replace(yg, "\\")), (r = decodeURIComponent(r)), "" !== t)
          )
            return `\\\\${t}${r}`;
          {
            let e = 32 | r.codePointAt(1),
              t = r[2];
            if (e < gg || e > _g || ":" !== t)
              throw new Deno.errors.InvalidData(
                "file url path must be absolute"
              );
            return r.slice(1);
          }
        })(e)
      : (function (e) {
          if ("" !== e.hostname)
            throw new Deno.errors.InvalidData("invalid file url hostname");
          let t = e.pathname;
          for (let e = 0; e < t.length; e++)
            if ("%" === t[e]) {
              let r = t.codePointAt(e + 2) || 32;
              if ("2" === t[e + 1] && 102 === r)
                throw new Deno.errors.InvalidData(
                  "must not include encoded / characters"
                );
            }
          return decodeURIComponent(t);
        })(e);
  }
  function zm(e) {
    let t = Im.resolve(e),
      r = e.charCodeAt(e.length - 1);
    (r === mg || (vg && r === fg)) && t[t.length - 1] !== Im.sep && (t += "/");
    let n = new URL("file://");
    return (
      t.includes("%") && (t = t.replace(bg, "%25")),
      !vg && t.includes("\\") && (t = t.replace(xg, "%5C")),
      t.includes("\n") && (t = t.replace(wg, "%0A")),
      t.includes("\r") && (t = t.replace(Sg, "%0D")),
      t.includes("\t") && (t = t.replace(Eg, "%09")),
      (n.pathname = t),
      n
    );
  }
  pc(Nm, {
    URL: () => pg,
    Url: () => lg,
    default: () => sg,
    fileURLToPath: () => Hm,
    format: () => cg,
    parse: () => dg,
    pathToFileURL: () => zm,
    resolve: () => ug,
    resolveObject: () => hg,
  });
  var Vm,
    jm,
    Wm,
    Gm,
    Xm,
    qm,
    Ym,
    Km,
    $m,
    Qm,
    Jm,
    Zm,
    eg,
    tg,
    rg,
    ng,
    ig,
    og,
    sg,
    ag,
    lg,
    cg,
    ug,
    hg,
    dg,
    pg,
    fg,
    mg,
    gg,
    _g,
    vg,
    yg,
    bg,
    xg,
    wg,
    Sg,
    Eg,
    Mg = hc(() => {
      mc(),
        lh(),
        qu(),
        Ap(),
        Ef(),
        Om(),
        Lm(),
        (Vm = Object.freeze(Object.create(null))),
        (jm = {}),
        (Wm = !1),
        (Gm =
          typeof globalThis < "u"
            ? globalThis
            : typeof self < "u"
            ? self
            : e.g),
        (Xm = {}),
        (qm = !1),
        (Ym = {}),
        (Km = !1),
        ($m = {}),
        (Qm = !1),
        (Jm = {}),
        (Zm = !1),
        (eg = {}),
        (tg = !1),
        (rg = {}),
        (ng = !1),
        (ig = {}),
        (og = !1),
        (sg = Fm()).parse,
        sg.resolve,
        sg.resolveObject,
        sg.format,
        sg.Url,
        (ag =
          typeof Deno < "u"
            ? "windows" === Deno.build.os
              ? "win32"
              : Deno.build.os
            : void 0),
        (sg.URL = typeof URL < "u" ? URL : null),
        (sg.pathToFileURL = zm),
        (sg.fileURLToPath = Hm),
        (lg = sg.Url),
        (cg = sg.format),
        (ug = sg.resolve),
        (hg = sg.resolveObject),
        (dg = sg.parse),
        (pg = sg.URL),
        (fg = 92),
        (mg = 47),
        (gg = 97),
        (_g = 122),
        (vg = "win32" === ag),
        (yg = /\//g),
        (bg = /%/g),
        (xg = /\\/g),
        (wg = /\n/g),
        (Sg = /\r/g),
        (Eg = /\t/g);
    }),
    Tg = dc((e, t) => {
      mc(),
        lh(),
        qu(),
        (t.exports = function () {
          throw new Error(
            "ws does not work in the browser. Browser clients must use the native WebSocket object"
          );
        });
    }),
    Ag = dc((e) => {
      mc(),
        lh(),
        qu(),
        Object.defineProperty(e, "__esModule", { value: !0 }),
        (e.BufferedDuplex = void 0),
        (e.writev = n);
      var t = Qh(),
        r = (ah(), fc(rh));
      function n(e, t) {
        let n = new Array(e.length);
        for (let t = 0; t < e.length; t++)
          "string" == typeof e[t].chunk
            ? (n[t] = r.Buffer.from(e[t].chunk, "utf8"))
            : (n[t] = e[t].chunk);
        this._write(r.Buffer.concat(n), "binary", t);
      }
      var i = class extends t.Duplex {
        socket;
        proxy;
        isSocketOpen;
        writeQueue;
        constructor(e, t, r) {
          super({ objectMode: !0 }),
            (this.proxy = t),
            (this.socket = r),
            (this.writeQueue = []),
            e.objectMode || (this._writev = n.bind(this)),
            (this.isSocketOpen = !1),
            this.proxy.on("data", (e) => {
              !this.destroyed && this.readable && this.push(e);
            });
        }
        _read(e) {
          this.proxy.read(e);
        }
        _write(e, t, r) {
          this.isSocketOpen
            ? this.writeToProxy(e, t, r)
            : this.writeQueue.push({ chunk: e, encoding: t, cb: r });
        }
        _final(e) {
          (this.writeQueue = []), this.proxy.end(e);
        }
        _destroy(e, t) {
          (this.writeQueue = []), this.proxy.destroy(), t(e);
        }
        socketReady() {
          this.emit("connect"),
            (this.isSocketOpen = !0),
            this.processWriteQueue();
        }
        writeToProxy(e, t, r) {
          !1 === this.proxy.write(e, t) ? this.proxy.once("drain", r) : r();
        }
        processWriteQueue() {
          for (; this.writeQueue.length > 0; ) {
            let { chunk: e, encoding: t, cb: r } = this.writeQueue.shift();
            this.writeToProxy(e, t, r);
          }
        }
      };
      e.BufferedDuplex = i;
    }),
    Rg = dc((e) => {
      mc(), lh(), qu();
      var t =
        (e && e.__importDefault) ||
        function (e) {
          return e && e.__esModule ? e : { default: e };
        };
      Object.defineProperty(e, "__esModule", { value: !0 }),
        (e.streamBuilder = e.browserStreamBuilder = void 0);
      var r = (ah(), fc(rh)),
        n = t(Tg()),
        i = t(od()),
        o = Qh(),
        s = t(wp()),
        a = Ag(),
        l = (0, i.default)("mqttjs:ws"),
        c = ["rejectUnauthorized", "ca", "cert", "key", "pfx", "passphrase"];
      function u(e, t) {
        let r = `${e.protocol}://${e.hostname}:${e.port}${e.path}`;
        return (
          "function" == typeof e.transformWsUrl &&
            (r = e.transformWsUrl(r, e, t)),
          r
        );
      }
      function h(e) {
        let t = e;
        return (
          e.port || ("wss" === e.protocol ? (t.port = 443) : (t.port = 80)),
          e.path || (t.path = "/"),
          e.wsOptions || (t.wsOptions = {}),
          !s.default &&
            !e.forceNativeWebSocket &&
            "wss" === e.protocol &&
            c.forEach((r) => {
              Object.prototype.hasOwnProperty.call(e, r) &&
                !Object.prototype.hasOwnProperty.call(e.wsOptions, r) &&
                (t.wsOptions[r] = e[r]);
            }),
          t
        );
      }
      (e.streamBuilder = (e, t) => {
        l("streamBuilder");
        let r = h(t);
        r.hostname = r.hostname || r.host || "localhost";
        let i = u(r, e),
          o = (function (e, t, r) {
            l("createWebSocket"),
              l(`protocol: ${r.protocolId} ${r.protocolVersion}`);
            let i,
              o =
                "MQIsdp" === r.protocolId && 3 === r.protocolVersion
                  ? "mqttv3.1"
                  : "mqtt";
            return (
              l(`creating new Websocket for url: ${t} and protocol: ${o}`),
              (i = r.createWebsocket
                ? r.createWebsocket(t, [o], r)
                : new n.default(t, [o], r.wsOptions)),
              i
            );
          })(0, i, r),
          s = n.default.createWebSocketStream(o, r.wsOptions);
        return (
          (s.url = i),
          o.on("close", () => {
            s.destroy();
          }),
          s
        );
      }),
        (e.browserStreamBuilder = (e, t) => {
          l("browserStreamBuilder");
          let n,
            i =
              (function (e) {
                let t = h(e);
                if ((t.hostname || (t.hostname = t.host), !t.hostname)) {
                  if (typeof document > "u")
                    throw new Error(
                      "Could not determine host. Specify host manually."
                    );
                  let e = new URL(document.URL);
                  (t.hostname = e.hostname),
                    t.port || (t.port = Number(e.port));
                }
                return (
                  void 0 === t.objectMode &&
                    (t.objectMode = !(!0 === t.binary || void 0 === t.binary)),
                  t
                );
              })(t).browserBufferSize || 524288,
            s = t.browserBufferTimeout || 1e3,
            c = !t.objectMode,
            d = (function (e, t) {
              let r,
                n =
                  "MQIsdp" === t.protocolId && 3 === t.protocolVersion
                    ? "mqttv3.1"
                    : "mqtt",
                i = u(t, e);
              return (
                (r = t.createWebsocket
                  ? t.createWebsocket(i, [n], t)
                  : new WebSocket(i, [n])),
                (r.binaryType = "arraybuffer"),
                r
              );
            })(e, t),
            p = (function (e) {
              let t = new o.Transform({ objectMode: e.objectMode });
              return (
                (t._write = function e(t, n, o) {
                  if (d.bufferedAmount > i)
                    return void setTimeout(e, s, t, n, o);
                  c && "string" == typeof t && (t = r.Buffer.from(t, "utf8"));
                  try {
                    d.send(t);
                  } catch (e) {
                    return o(e);
                  }
                  o();
                }),
                (t._flush = function (e) {
                  d.close(), e();
                }),
                t
              );
            })(t);
          t.objectMode || (p._writev = a.writev.bind(p)),
            p.on("close", () => {
              d.close();
            });
          let f = typeof d.addEventListener < "u";
          function m() {
            l("WebSocket onOpen"),
              n instanceof a.BufferedDuplex && n.socketReady();
          }
          function g(e) {
            l("WebSocket onClose", e), n.end(), n.destroy();
          }
          function _(e) {
            l("WebSocket onError", e);
            let t = new Error("WebSocket error");
            (t.event = e), n.destroy(t);
          }
          async function v(e) {
            if (!p || !p.readable || !p.writable) return;
            let { data: t } = e;
            (t =
              t instanceof ArrayBuffer
                ? r.Buffer.from(t)
                : t instanceof Blob
                ? r.Buffer.from(await new Response(t).arrayBuffer())
                : r.Buffer.from(t, "utf8")),
              p.push(t);
          }
          return (
            d.readyState === d.OPEN
              ? ((n = p), (n.socket = d))
              : ((n = new a.BufferedDuplex(t, p, d)),
                f ? d.addEventListener("open", m) : (d.onopen = m)),
            f
              ? (d.addEventListener("close", g),
                d.addEventListener("error", _),
                d.addEventListener("message", v))
              : ((d.onclose = g), (d.onerror = _), (d.onmessage = v)),
            n
          );
        });
    }),
    Pg = {};
  function Cg() {
    throw new Error(
      "Node.js net module is not supported by JSPM core outside of Node.js"
    );
  }
  pc(Pg, {
    Server: () => Cg,
    Socket: () => Cg,
    Stream: () => Cg,
    _createServerHandle: () => Cg,
    _normalizeArgs: () => Cg,
    _setSimultaneousAccepts: () => Cg,
    connect: () => Cg,
    createConnection: () => Cg,
    createServer: () => Cg,
    default: () => Ig,
    isIP: () => Cg,
    isIPv4: () => Cg,
    isIPv6: () => Cg,
  });
  var Ig,
    Lg = hc(() => {
      mc(),
        lh(),
        qu(),
        (Ig = {
          _createServerHandle: Cg,
          _normalizeArgs: Cg,
          _setSimultaneousAccepts: Cg,
          connect: Cg,
          createConnection: Cg,
          createServer: Cg,
          isIP: Cg,
          isIPv4: Cg,
          isIPv6: Cg,
          Server: Cg,
          Socket: Cg,
          Stream: Cg,
        });
    }),
    Og = dc((e, t) => {
      mc(), lh(), qu(), (t.exports = {});
    }),
    Ng = dc((e) => {
      mc(), lh(), qu();
      var t =
        (e && e.__importDefault) ||
        function (e) {
          return e && e.__esModule ? e : { default: e };
        };
      Object.defineProperty(e, "__esModule", { value: !0 });
      var r = t((Lg(), fc(Pg))),
        n = t(od()),
        i = t(Og()),
        o = (0, n.default)("mqttjs:tcp");
      e.default = (e, t) => {
        if (
          ((t.port = t.port || 1883),
          (t.hostname = t.hostname || t.host || "localhost"),
          t.socksProxy)
        )
          return (0, i.default)(t.hostname, t.port, t.socksProxy, {
            timeout: t.socksTimeout,
          });
        let { port: n, path: s } = t,
          a = t.hostname;
        return (
          o("port %d and host %s", n, a),
          r.default.createConnection({ port: n, host: a, path: s })
        );
      };
    }),
    Ug = {};
  pc(Ug, { default: () => Dg });
  var Dg,
    kg = hc(() => {
      mc(), lh(), qu(), (Dg = {});
    }),
    Bg = dc((e) => {
      mc(), lh(), qu();
      var t =
        (e && e.__importDefault) ||
        function (e) {
          return e && e.__esModule ? e : { default: e };
        };
      Object.defineProperty(e, "__esModule", { value: !0 });
      var r = (kg(), fc(Ug)),
        n = t((Lg(), fc(Pg))),
        i = t(od()),
        o = t(Og()),
        s = (0, i.default)("mqttjs:tls");
      e.default = (e, t) => {
        (t.port = t.port || 8883),
          (t.host = t.hostname || t.host || "localhost"),
          0 === n.default.isIP(t.host) && (t.servername = t.host),
          (t.rejectUnauthorized = !1 !== t.rejectUnauthorized),
          delete t.path,
          s(
            "port %d host %s rejectUnauthorized %b",
            t.port,
            t.host,
            t.rejectUnauthorized
          );
        let i = (function (e) {
          let { host: t, port: n, socksProxy: i, ...s } = e;
          if (void 0 !== i) {
            let a = (0, o.default)(t, n, i, { timeout: e.socksTimeout });
            return (0, r.connect)({ ...s, socket: a });
          }
          return (0, r.connect)(e);
        })(t);
        function a(r) {
          t.rejectUnauthorized && e.emit("error", r), i.end();
        }
        return (
          i.on("secureConnect", () => {
            t.rejectUnauthorized && !i.authorized
              ? i.emit("error", new Error("TLS not authorized"))
              : i.removeListener("error", a);
          }),
          i.on("error", a),
          i
        );
      };
    }),
    Fg = dc((e) => {
      mc(), lh(), qu(), Object.defineProperty(e, "__esModule", { value: !0 });
      var t,
        r,
        n,
        i = (ah(), fc(rh)),
        o = Qh(),
        s = Ag();
      e.default = (e, a) => {
        if (((a.hostname = a.hostname || a.host), !a.hostname))
          throw new Error("Could not determine host. Specify host manually.");
        let l =
          "MQIsdp" === a.protocolId && 3 === a.protocolVersion
            ? "mqttv3.1"
            : "mqtt";
        !(function (e) {
          e.hostname || (e.hostname = "localhost"),
            e.path || (e.path = "/"),
            e.wsOptions || (e.wsOptions = {});
        })(a);
        let c = (function (e, t) {
          let r = "wxs" === e.protocol ? "wss" : "ws",
            n = `${r}://${e.hostname}${e.path}`;
          return (
            e.port &&
              80 !== e.port &&
              443 !== e.port &&
              (n = `${r}://${e.hostname}:${e.port}${e.path}`),
            "function" == typeof e.transformWsUrl &&
              (n = e.transformWsUrl(n, e, t)),
            n
          );
        })(a, e);
        (t = wx.connectSocket({ url: c, protocols: [l] })),
          (r = (function () {
            let e = new o.Transform();
            return (
              (e._write = (e, r, n) => {
                t.send({
                  data: e.buffer,
                  success() {
                    n();
                  },
                  fail(e) {
                    n(new Error(e));
                  },
                });
              }),
              (e._flush = (e) => {
                t.close({
                  success() {
                    e();
                  },
                });
              }),
              e
            );
          })()),
          ((n = new s.BufferedDuplex(a, r, t))._destroy = (e, r) => {
            t.close({
              success() {
                r && r(e);
              },
            });
          });
        let u = n.destroy;
        return (
          (n.destroy = (e, r) => (
            (n.destroy = u),
            setTimeout(() => {
              t.close({
                fail() {
                  n._destroy(e, r);
                },
              });
            }, 0),
            n
          )),
          t.onOpen(() => {
            n.socketReady();
          }),
          t.onMessage((e) => {
            let { data: t } = e;
            (t =
              t instanceof ArrayBuffer
                ? i.Buffer.from(t)
                : i.Buffer.from(t, "utf8")),
              r.push(t);
          }),
          t.onClose(() => {
            n.emit("close"), n.end(), n.destroy();
          }),
          t.onError((e) => {
            let t = new Error(e.errMsg);
            n.destroy(t);
          }),
          n
        );
      };
    }),
    Hg = dc((e) => {
      mc(), lh(), qu(), Object.defineProperty(e, "__esModule", { value: !0 });
      var t,
        r,
        n,
        i = (ah(), fc(rh)),
        o = Qh(),
        s = Ag(),
        a = !1;
      e.default = (e, l) => {
        if (((l.hostname = l.hostname || l.host), !l.hostname))
          throw new Error("Could not determine host. Specify host manually.");
        let c =
          "MQIsdp" === l.protocolId && 3 === l.protocolVersion
            ? "mqttv3.1"
            : "mqtt";
        !(function (e) {
          e.hostname || (e.hostname = "localhost"),
            e.path || (e.path = "/"),
            e.wsOptions || (e.wsOptions = {});
        })(l);
        let u = (function (e, t) {
          let r = "alis" === e.protocol ? "wss" : "ws",
            n = `${r}://${e.hostname}${e.path}`;
          return (
            e.port &&
              80 !== e.port &&
              443 !== e.port &&
              (n = `${r}://${e.hostname}:${e.port}${e.path}`),
            "function" == typeof e.transformWsUrl &&
              (n = e.transformWsUrl(n, e, t)),
            n
          );
        })(l, e);
        return (
          (t = l.my).connectSocket({ url: u, protocols: c }),
          (r = (function () {
            let e = new o.Transform();
            return (
              (e._write = (e, r, n) => {
                t.sendSocketMessage({
                  data: e.buffer,
                  success() {
                    n();
                  },
                  fail() {
                    n(new Error());
                  },
                });
              }),
              (e._flush = (e) => {
                t.closeSocket({
                  success() {
                    e();
                  },
                });
              }),
              e
            );
          })()),
          (n = new s.BufferedDuplex(l, r, t)),
          a ||
            ((a = !0),
            t.onSocketOpen(() => {
              n.socketReady();
            }),
            t.onSocketMessage((e) => {
              if ("string" == typeof e.data) {
                let t = i.Buffer.from(e.data, "base64");
                r.push(t);
              } else {
                let t = new FileReader();
                t.addEventListener("load", () => {
                  t.result instanceof ArrayBuffer
                    ? r.push(i.Buffer.from(t.result))
                    : r.push(i.Buffer.from(t.result, "utf-8"));
                }),
                  t.readAsArrayBuffer(e.data);
              }
            }),
            t.onSocketClose(() => {
              n.end(), n.destroy();
            }),
            t.onSocketError((e) => {
              n.destroy(e);
            })),
          n
        );
      };
    }),
    zg = dc((e) => {
      mc(), lh(), qu();
      var t =
        (e && e.__importDefault) ||
        function (e) {
          return e && e.__esModule ? e : { default: e };
        };
      Object.defineProperty(e, "__esModule", { value: !0 }),
        (e.connectAsync = function (e, t, r = !0) {
          return new Promise((n, i) => {
            let o = l(e, t),
              s = {
                connect: (e) => {
                  a(), n(o);
                },
                end: () => {
                  a(), n(o);
                },
                error: (e) => {
                  a(), o.end(), i(e);
                },
              };
            function a() {
              Object.keys(s).forEach((e) => {
                o.off(e, s[e]);
              });
            }
            !1 === r &&
              (s.close = () => {
                s.error(new Error("Couldn't connect to server"));
              }),
              Object.keys(s).forEach((e) => {
                o.on(e, s[e]);
              });
          });
        });
      var r = t(od()),
        n = t((Mg(), fc(Nm))),
        i = t(Mp()),
        o = t(wp());
      "function" != typeof gc?.nextTick && (gc.nextTick = setImmediate);
      var s = (0, r.default)("mqttjs"),
        a = null;
      function l(e, t) {
        if (
          (s("connecting to an MQTT broker..."),
          "object" == typeof e && !t && ((t = e), (e = "")),
          (t = t || {}),
          e && "string" == typeof e)
        ) {
          let r = n.default.parse(e, !0),
            i = {};
          if (
            (null != r.port && (i.port = Number(r.port)),
            (i.host = r.hostname),
            (i.query = r.query),
            (i.auth = r.auth),
            (i.protocol = r.protocol),
            (i.path = r.path),
            !(t = { ...i, ...t }).protocol)
          )
            throw new Error("Missing protocol");
          t.protocol = t.protocol.replace(/:$/, "");
        }
        if (
          ((t.unixSocket = t.unixSocket || t.protocol?.includes("+unix")),
          t.unixSocket
            ? (t.protocol = t.protocol.replace("+unix", ""))
            : !t.protocol?.startsWith("ws") &&
              !t.protocol?.startsWith("wx") &&
              delete t.path,
          (function (e) {
            let t;
            if (e.auth)
              if (((t = e.auth.match(/^(.+):(.+)$/)), t)) {
                let [, r, n] = t;
                (e.username = r), (e.password = n);
              } else e.username = e.auth;
          })(t),
          t.query &&
            "string" == typeof t.query.clientId &&
            (t.clientId = t.query.clientId),
          o.default || t.unixSocket
            ? (t.socksProxy = void 0)
            : void 0 === t.socksProxy &&
              typeof gc < "u" &&
              (t.socksProxy = gc.env.MQTTJS_SOCKS_PROXY),
          t.cert && t.key)
        ) {
          if (!t.protocol) throw new Error("Missing secure protocol key");
          if (-1 === ["mqtts", "wss", "wxs", "alis"].indexOf(t.protocol))
            switch (t.protocol) {
              case "mqtt":
                t.protocol = "mqtts";
                break;
              case "ws":
                t.protocol = "wss";
                break;
              case "wx":
                t.protocol = "wxs";
                break;
              case "ali":
                t.protocol = "alis";
                break;
              default:
                throw new Error(
                  `Unknown protocol for secure connection: "${t.protocol}"!`
                );
            }
        }
        if (
          (a ||
            ((a = {}),
            o.default || t.forceNativeWebSocket
              ? ((a.ws = Rg().browserStreamBuilder),
                (a.wss = Rg().browserStreamBuilder),
                (a.wx = Fg().default),
                (a.wxs = Fg().default),
                (a.ali = Hg().default),
                (a.alis = Hg().default))
              : ((a.ws = Rg().streamBuilder),
                (a.wss = Rg().streamBuilder),
                (a.mqtt = Ng().default),
                (a.tcp = Ng().default),
                (a.ssl = Bg().default),
                (a.tls = a.ssl),
                (a.mqtts = Bg().default))),
          !a[t.protocol])
        ) {
          let e = -1 !== ["mqtts", "wss"].indexOf(t.protocol);
          t.protocol = [
            "mqtt",
            "mqtts",
            "ws",
            "wss",
            "wx",
            "wxs",
            "ali",
            "alis",
          ].filter(
            (t, r) => (!e || r % 2 != 0) && "function" == typeof a[t]
          )[0];
        }
        if (!1 === t.clean && !t.clientId)
          throw new Error("Missing clientId for unclean clients");
        t.protocol && (t.defaultProtocol = t.protocol);
        let r = new i.default(function (e) {
          return (
            t.servers &&
              ((!e._reconnectCount || e._reconnectCount === t.servers.length) &&
                (e._reconnectCount = 0),
              (t.host = t.servers[e._reconnectCount].host),
              (t.port = t.servers[e._reconnectCount].port),
              (t.protocol = t.servers[e._reconnectCount].protocol
                ? t.servers[e._reconnectCount].protocol
                : t.defaultProtocol),
              (t.hostname = t.host),
              e._reconnectCount++),
            s("calling streambuilder for", t.protocol),
            a[t.protocol](e, t)
          );
        }, t);
        return r.on("error", () => {}), r;
      }
      e.default = l;
    }),
    Vg = dc((e) => {
      mc(), lh(), qu();
      var t,
        r =
          (e && e.__createBinding) ||
          (Object.create
            ? function (e, t, r, n) {
                void 0 === n && (n = r);
                var i = Object.getOwnPropertyDescriptor(t, r);
                (!i ||
                  ("get" in i
                    ? !t.__esModule
                    : i.writable || i.configurable)) &&
                  (i = {
                    enumerable: !0,
                    get: function () {
                      return t[r];
                    },
                  }),
                  Object.defineProperty(e, n, i);
              }
            : function (e, t, r, n) {
                void 0 === n && (n = r), (e[n] = t[r]);
              }),
        n =
          (e && e.__setModuleDefault) ||
          (Object.create
            ? function (e, t) {
                Object.defineProperty(e, "default", {
                  enumerable: !0,
                  value: t,
                });
              }
            : function (e, t) {
                e.default = t;
              }),
        i =
          (e && e.__importStar) ||
          ((t = function (e) {
            return (t =
              Object.getOwnPropertyNames ||
              function (e) {
                var t = [];
                for (var r in e)
                  Object.prototype.hasOwnProperty.call(e, r) &&
                    (t[t.length] = r);
                return t;
              })(e);
          }),
          function (e) {
            if (e && e.__esModule) return e;
            var i = {};
            if (null != e)
              for (var o = t(e), s = 0; s < o.length; s++)
                "default" !== o[s] && r(i, e, o[s]);
            return n(i, e), i;
          }),
        o =
          (e && e.__exportStar) ||
          function (e, t) {
            for (var n in e)
              "default" !== n &&
                !Object.prototype.hasOwnProperty.call(t, n) &&
                r(t, e, n);
          },
        s =
          (e && e.__importDefault) ||
          function (e) {
            return e && e.__esModule ? e : { default: e };
          };
      Object.defineProperty(e, "__esModule", { value: !0 }),
        (e.ReasonCodes =
          e.KeepaliveManager =
          e.UniqueMessageIdProvider =
          e.DefaultMessageIdProvider =
          e.Store =
          e.MqttClient =
          e.connectAsync =
          e.connect =
          e.Client =
            void 0);
      var a = s(Mp());
      e.MqttClient = a.default;
      var l = s(Yd());
      e.DefaultMessageIdProvider = l.default;
      var c = s(Tp());
      e.UniqueMessageIdProvider = c.default;
      var u = s(md());
      e.Store = u.default;
      var h = i(zg());
      (e.connect = h.default),
        Object.defineProperty(e, "connectAsync", {
          enumerable: !0,
          get: function () {
            return h.connectAsync;
          },
        });
      var d = s(Ep());
      (e.KeepaliveManager = d.default),
        (e.Client = a.default),
        o(Mp(), e),
        o(vd(), e);
      var p = yd();
      Object.defineProperty(e, "ReasonCodes", {
        enumerable: !0,
        get: function () {
          return p.ReasonCodes;
        },
      });
    });
  const jg = dc((e) => {
    mc(), lh(), qu();
    var t,
      r =
        (e && e.__createBinding) ||
        (Object.create
          ? function (e, t, r, n) {
              void 0 === n && (n = r);
              var i = Object.getOwnPropertyDescriptor(t, r);
              (!i ||
                ("get" in i ? !t.__esModule : i.writable || i.configurable)) &&
                (i = {
                  enumerable: !0,
                  get: function () {
                    return t[r];
                  },
                }),
                Object.defineProperty(e, n, i);
            }
          : function (e, t, r, n) {
              void 0 === n && (n = r), (e[n] = t[r]);
            }),
      n =
        (e && e.__setModuleDefault) ||
        (Object.create
          ? function (e, t) {
              Object.defineProperty(e, "default", { enumerable: !0, value: t });
            }
          : function (e, t) {
              e.default = t;
            }),
      i =
        (e && e.__importStar) ||
        ((t = function (e) {
          return (t =
            Object.getOwnPropertyNames ||
            function (e) {
              var t = [];
              for (var r in e)
                Object.prototype.hasOwnProperty.call(e, r) && (t[t.length] = r);
              return t;
            })(e);
        }),
        function (e) {
          if (e && e.__esModule) return e;
          var i = {};
          if (null != e)
            for (var o = t(e), s = 0; s < o.length; s++)
              "default" !== o[s] && r(i, e, o[s]);
          return n(i, e), i;
        }),
      o =
        (e && e.__exportStar) ||
        function (e, t) {
          for (var n in e)
            "default" !== n &&
              !Object.prototype.hasOwnProperty.call(t, n) &&
              r(t, e, n);
        };
    Object.defineProperty(e, "__esModule", { value: !0 });
    var s = i(Vg());
    (e.default = s), o(Vg(), e);
  })();
  var Wg = {
    get broker() {
      if ("https:" === window.location.protocol) {
        if (window.location.hostname.includes("ngrok")) {
          console.log(" ngrok HTTPS   - WSS  ");
          var e = localStorage.getItem("ngrok_mqtt_host") || "localhost",
            t = localStorage.getItem("ngrok_mqtt_port") || "9001";
          return "wss://".concat(e, ":").concat(t);
        }
        return (
          console.log(" HTTPS   - WSS  "),
          "wss://192.168.27.92:3000"
        );
      }
      return (
        console.log(" HTTP  () - WS  "),
        "ws://192.168.27.92:3000"
      );
    },
    topic: "sandbox/digitaltwin",
    options: {
      clientId: "webxr-client-".concat(Math.random().toString(16).substr(2, 8)),
      username: "",
      password: "",
      clean: !0,
      connectTimeout: 5e3,
      reconnectPeriod: 500,
      keepalive: 60,
      reschedulePings: !0,
      queueQoSZero: !1,
      protocolVersion: 4,
      rejectUnauthorized: !1,
      will: void 0,
    },
  };
  function Gg() {
    var e,
      t,
      r = "function" == typeof Symbol ? Symbol : {},
      n = r.iterator || "@@iterator",
      i = r.toStringTag || "@@toStringTag";
    function o(r, n, i, o) {
      var l = n && n.prototype instanceof a ? n : a,
        c = Object.create(l.prototype);
      return (
        Xg(
          c,
          "_invoke",
          (function (r, n, i) {
            var o,
              a,
              l,
              c = 0,
              u = i || [],
              h = !1,
              d = {
                p: 0,
                n: 0,
                v: e,
                a: p,
                f: p.bind(e, 4),
                d: function (t, r) {
                  return (o = t), (a = 0), (l = e), (d.n = r), s;
                },
              };
            function p(r, n) {
              for (a = r, l = n, t = 0; !h && c && !i && t < u.length; t++) {
                var i,
                  o = u[t],
                  p = d.p,
                  f = o[2];
                r > 3
                  ? (i = f === n) &&
                    ((l = o[(a = o[4]) ? 5 : ((a = 3), 3)]), (o[4] = o[5] = e))
                  : o[0] <= p &&
                    ((i = r < 2 && p < o[1])
                      ? ((a = 0), (d.v = n), (d.n = o[1]))
                      : p < f &&
                        (i = r < 3 || o[0] > n || n > f) &&
                        ((o[4] = r), (o[5] = n), (d.n = f), (a = 0)));
              }
              if (i || r > 1) return s;
              throw ((h = !0), n);
            }
            return function (i, u, f) {
              if (c > 1) throw TypeError("Generator is already running");
              for (
                h && 1 === u && p(u, f), a = u, l = f;
                (t = a < 2 ? e : l) || !h;

              ) {
                o ||
                  (a
                    ? a < 3
                      ? (a > 1 && (d.n = -1), p(a, l))
                      : (d.n = l)
                    : (d.v = l));
                try {
                  if (((c = 2), o)) {
                    if ((a || (i = "next"), (t = o[i]))) {
                      if (!(t = t.call(o, l)))
                        throw TypeError("iterator result is not an object");
                      if (!t.done) return t;
                      (l = t.value), a < 2 && (a = 0);
                    } else
                      1 === a && (t = o.return) && t.call(o),
                        a < 2 &&
                          ((l = TypeError(
                            "The iterator does not provide a '" + i + "' method"
                          )),
                          (a = 1));
                    o = e;
                  } else if ((t = (h = d.n < 0) ? l : r.call(n, d)) !== s)
                    break;
                } catch (t) {
                  (o = e), (a = 1), (l = t);
                } finally {
                  c = 1;
                }
              }
              return { value: t, done: h };
            };
          })(r, i, o),
          !0
        ),
        c
      );
    }
    var s = {};
    function a() {}
    function l() {}
    function c() {}
    t = Object.getPrototypeOf;
    var u = [][n]
        ? t(t([][n]()))
        : (Xg((t = {}), n, function () {
            return this;
          }),
          t),
      h = (c.prototype = a.prototype = Object.create(u));
    function d(e) {
      return (
        Object.setPrototypeOf
          ? Object.setPrototypeOf(e, c)
          : ((e.__proto__ = c), Xg(e, i, "GeneratorFunction")),
        (e.prototype = Object.create(h)),
        e
      );
    }
    return (
      (l.prototype = c),
      Xg(h, "constructor", c),
      Xg(c, "constructor", l),
      (l.displayName = "GeneratorFunction"),
      Xg(c, i, "GeneratorFunction"),
      Xg(h),
      Xg(h, i, "Generator"),
      Xg(h, n, function () {
        return this;
      }),
      Xg(h, "toString", function () {
        return "[object Generator]";
      }),
      (Gg = function () {
        return { w: o, m: d };
      })()
    );
  }
  function Xg(e, t, r, n) {
    var i = Object.defineProperty;
    try {
      i({}, "", {});
    } catch (e) {
      i = 0;
    }
    (Xg = function (e, t, r, n) {
      function o(t, r) {
        Xg(e, t, function (e) {
          return this._invoke(t, r, e);
        });
      }
      t
        ? i
          ? i(e, t, {
              value: r,
              enumerable: !n,
              configurable: !n,
              writable: !n,
            })
          : (e[t] = r)
        : (o("next", 0), o("throw", 1), o("return", 2));
    }),
      Xg(e, t, r, n);
  }
  function qg(e, t, r, n, i, o, s) {
    try {
      var a = e[o](s),
        l = a.value;
    } catch (e) {
      return void r(e);
    }
    a.done ? t(l) : Promise.resolve(l).then(n, i);
  }
  function Yg(e) {
    return function () {
      var t = this,
        r = arguments;
      return new Promise(function (n, i) {
        var o = e.apply(t, r);
        function s(e) {
          qg(o, n, i, s, a, "next", e);
        }
        function a(e) {
          qg(o, n, i, s, a, "throw", e);
        }
        s(void 0);
      });
    };
  }
  var Kg = null;
  function $g() {
    var e;
    (e = console).error.apply(e, arguments);
  }
  var Qg = null,
    Jg = null,
    Zg = new Map(),
    e_ = {
      isMouseDown: !1,
      mouseX: 0,
      mouseY: 0,
      targetRotationX: 0,
      targetRotationY: 0,
      currentRotationX: 0,
      currentRotationY: 0,
      keys: {},
      moveSpeed: 0.5,
      rotationSpeed: 0.05,
      distance: 20,
      minDistance: 5,
      maxDistance: 100,
      zoomSpeed: 2,
    },
    t_ = !1,
    r_ = null;
  function n_() {
    return i_.apply(this, arguments);
  }
  function i_() {
    return (i_ = Yg(
      Gg().m(function e() {
        var t, r, n;
        return Gg().w(
          function (e) {
            for (;;)
              switch ((e.p = e.n)) {
                case 0:
                  if (navigator.xr) {
                    e.n = 1;
                    break;
                  }
                  return (
                    console.log("WebXR  -  3D  "),
                    e.a(2, !1)
                  );
                case 1:
                  return (
                    (e.p = 1),
                    (e.n = 2),
                    navigator.xr.isSessionSupported("immersive-vr")
                  );
                case 2:
                  return (
                    (t = e.v),
                    (e.n = 3),
                    navigator.xr.isSessionSupported("immersive-ar")
                  );
                case 3:
                  if (((r = e.v), !t)) {
                    e.n = 4;
                    break;
                  }
                  return (
                    console.log("WebXR VR  "), (r_ = "vr"), e.a(2, !0)
                  );
                case 4:
                  if (!r) {
                    e.n = 5;
                    break;
                  }
                  return (
                    console.log("WebXR AR  "), (r_ = "ar"), e.a(2, !0)
                  );
                case 5:
                  return (
                    console.log(
                      "WebXR   VR/AR   -  3D  "
                    ),
                    e.a(2, !1)
                  );
                case 6:
                  e.n = 8;
                  break;
                case 7:
                  return (
                    (e.p = 7),
                    (n = e.v),
                    console.log("WebXR    :", n),
                    console.log(" 3D  "),
                    e.a(2, !1)
                  );
                case 8:
                  return e.a(2);
              }
          },
          e,
          null,
          [[1, 7]]
        );
      })
    )).apply(this, arguments);
  }
  n_().then(function (e) {
    t_ = e;
  });
  var o_ = new (class extends hr {
    constructor() {
      super(),
        (this.isScene = !0),
        (this.type = "Scene"),
        (this.background = null),
        (this.environment = null),
        (this.fog = null),
        (this.backgroundBlurriness = 0),
        (this.backgroundIntensity = 1),
        (this.overrideMaterial = null),
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("observe", { detail: this })
          );
    }
    copy(e, t) {
      return (
        super.copy(e, t),
        null !== e.background && (this.background = e.background.clone()),
        null !== e.environment && (this.environment = e.environment.clone()),
        null !== e.fog && (this.fog = e.fog.clone()),
        (this.backgroundBlurriness = e.backgroundBlurriness),
        (this.backgroundIntensity = e.backgroundIntensity),
        null !== e.overrideMaterial &&
          (this.overrideMaterial = e.overrideMaterial.clone()),
        (this.matrixAutoUpdate = e.matrixAutoUpdate),
        this
      );
    }
    toJSON(e) {
      const t = super.toJSON(e);
      return (
        null !== this.fog && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 &&
          (t.object.backgroundBlurriness = this.backgroundBlurriness),
        1 !== this.backgroundIntensity &&
          (t.object.backgroundIntensity = this.backgroundIntensity),
        t
      );
    }
  })();
  o_.background = new Rr(2236962);
  var s_ = new bn(75, window.innerWidth / window.innerHeight, 0.1, 1e3);
  s_.position.set(0, 5, 8), s_.lookAt(0, 2, 0);
  var a_ = new ps({ antialias: !0, xrCompatible: !0 });
  function l_() {
    return (l_ = Yg(
      Gg().m(function e() {
        var t, r;
        return Gg().w(function (e) {
          for (;;)
            switch (e.n) {
              case 0:
                return (e.n = 1), n_();
              case 1:
                if (e.v)
                  try {
                    (t = {
                      optionalFeatures: [
                        "dom-overlay",
                        "dom-overlay-for-handheld-ar",
                      ],
                      domOverlay: { root: document.body },
                    }),
                      "ar" === r_ && t.optionalFeatures.push("hit-test"),
                      (r = il.createButton(a_, t)),
                      document.body.appendChild(r),
                      console.log("XR  ");
                  } catch (e) {
                    console.error("XR   :", e), c_();
                  }
                else c_();
              case 2:
                return e.a(2);
            }
        }, e);
      })
    )).apply(this, arguments);
  }
  function c_() {
    var e = document.createElement("div");
    (e.style.cssText =
      "\n    position: fixed;\n    top: 10px;\n    right: 10px;\n    background: rgba(0,0,0,0.8);\n    color: white;\n    padding: 10px;\n    border-radius: 5px;\n    font-family: Arial, sans-serif;\n    font-size: 12px;\n    z-index: 1000;\n  "),
      (e.textContent = "WebXR VR/AR  -  3D "),
      document.body.appendChild(e);
  }
  a_.setSize(window.innerWidth, window.innerHeight),
    a_.setPixelRatio(window.devicePixelRatio),
    (a_.shadowMap.enabled = !0),
    (a_.xr.enabled = !0),
    document.body.appendChild(a_.domElement),
    document.body.appendChild(a_.domElement),
    (function () {
      l_.apply(this, arguments);
    })(),
    (function () {
      try {
        ((Kg = new Worker("/elevation-processor.worker.js")).onmessage =
          function (e) {
            var t = e.data,
              r = t.type,
              n = t.success,
              i = t.data,
              o = t.error;
            "PROCESSING_COMPLETE" === r && n
              ? (function (e) {
                  var t = performance.now(),
                    r = e.positions,
                    n = e.colors,
                    i = e.width,
                    o = e.height,
                    s = e.processingTime,
                    a = e.isRecreate;
                  if (Jg && Jg.geometry)
                    try {
                      if (a) {
                        for (
                          var l = new Xr(),
                            c = new Float32Array(r),
                            u = new Float32Array(n),
                            h = new Uint32Array((i - 1) * (o - 1) * 6),
                            d = 0,
                            p = 0;
                          p < o - 1;
                          p++
                        )
                          for (var f = 0; f < i - 1; f++) {
                            var m = p * i + f,
                              g = p * i + (f + 1),
                              _ = (p + 1) * i + f,
                              v = (p + 1) * i + (f + 1);
                            (h[d++] = m),
                              (h[d++] = _),
                              (h[d++] = g),
                              (h[d++] = g),
                              (h[d++] = _),
                              (h[d++] = v);
                          }
                        l.setAttribute("position", new Ur(c, 3)),
                          l.setAttribute("color", new Ur(u, 3)),
                          l.setIndex(new Ur(h, 1)),
                          l.computeVertexNormals(),
                          Jg.geometry.dispose(),
                          (Jg.geometry = l),
                          console.log(
                            " Geometry   (Worker: ".concat(
                              s.toFixed(2),
                              "ms)"
                            )
                          );
                      } else {
                        var y = Jg.geometry.getAttribute("position"),
                          b = Jg.geometry.getAttribute("color");
                        if (y && b) {
                          var x = new Float32Array(r),
                            w = new Float32Array(n);
                          y.array.set(x),
                            b.array.set(w),
                            (y.needsUpdate = !0),
                            (b.needsUpdate = !0),
                            Jg.geometry.computeVertexNormals(),
                            console.log(
                              " Geometry   (Worker: ".concat(
                                s.toFixed(2),
                                "ms)"
                              )
                            );
                        }
                      }
                      var S = performance.now() - t;
                      console.log(
                        "   : Worker "
                          .concat(s.toFixed(2), "ms + Main ")
                          .concat(S.toFixed(2), "ms")
                      );
                    } catch (e) {
                      $g(" Elevation   :", e.message);
                    }
                  else $g("    ");
                })(i)
              : "PROCESSING_ERROR" === r && $g(" Worker  :", o);
          }),
          (Kg.onerror = function (e) {
            $g(" Worker :", e.message);
          }),
          console.log(" Elevation Worker  ");
      } catch (e) {
        $g(" Worker  :", e.message), (Kg = null);
      }
    })();
  var u_ = new Ya(16777215, 0.8);
  u_.position.set(10, 15, 10),
    (u_.castShadow = !0),
    (u_.shadow.mapSize.width = 2048),
    (u_.shadow.mapSize.height = 2048),
    (u_.shadow.camera.near = 0.5),
    (u_.shadow.camera.far = 50),
    (u_.shadow.camera.left = -15),
    (u_.shadow.camera.right = 15),
    (u_.shadow.camera.top = 15),
    (u_.shadow.camera.bottom = -15),
    o_.add(u_);
  var h_ = new (class extends Ua {
    constructor(e, t) {
      super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
    }
  })(16777215, 0.4);
  o_.add(h_);
  var d_,
    p_,
    f_,
    m_,
    g_,
    __ = x_({
      width: 10,
      height: 8,
      data: [
        0.73, 0.65, 0.44, 0.12, 0.98, 0.31, 0.57, 0.82, 0.19, 0.94, 0.05, 0.28,
        0.77, 0.51, 0.09, 0.62, 0.35, 0.88, 0.17, 0.49, 0.91, 0.22, 0.55, 0.78,
        0.14, 0.39, 0.68, 0.03, 0.85, 0.41, 0.69, 0.11, 0.96, 0.33, 0.58, 0.76,
        0.08, 0.45, 0.16, 0.92, 0.29, 0.53, 0.81, 0.47, 0.71, 0.18, 0.95, 0.34,
        0.61, 0.84, 0.04, 0.27, 0.52, 0.79, 0.13, 0.37, 0.64, 0.01, 0.86, 0.42,
        0.74, 0.15, 0.99, 0.38, 0.63, 0.83, 0.1, 0.48, 0.2, 0.93, 0.06, 0.3,
        0.54, 0.75, 0.11, 0.32, 0.59, 0.8, 0.17, 0.4,
      ],
    }),
    v_ = new (class extends Ir {
      constructor(e) {
        super(),
          (this.isMeshPhongMaterial = !0),
          (this.type = "MeshPhongMaterial"),
          (this.color = new Rr(16777215)),
          (this.specular = new Rr(1118481)),
          (this.shininess = 30),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.emissive = new Rr(0)),
          (this.emissiveIntensity = 1),
          (this.emissiveMap = null),
          (this.bumpMap = null),
          (this.bumpScale = 1),
          (this.normalMap = null),
          (this.normalMapType = 0),
          (this.normalScale = new De(1, 1)),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = 0),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.flatShading = !1),
          (this.fog = !0),
          this.setValues(e);
      }
      copy(e) {
        return (
          super.copy(e),
          this.color.copy(e.color),
          this.specular.copy(e.specular),
          (this.shininess = e.shininess),
          (this.map = e.map),
          (this.lightMap = e.lightMap),
          (this.lightMapIntensity = e.lightMapIntensity),
          (this.aoMap = e.aoMap),
          (this.aoMapIntensity = e.aoMapIntensity),
          this.emissive.copy(e.emissive),
          (this.emissiveMap = e.emissiveMap),
          (this.emissiveIntensity = e.emissiveIntensity),
          (this.bumpMap = e.bumpMap),
          (this.bumpScale = e.bumpScale),
          (this.normalMap = e.normalMap),
          (this.normalMapType = e.normalMapType),
          this.normalScale.copy(e.normalScale),
          (this.displacementMap = e.displacementMap),
          (this.displacementScale = e.displacementScale),
          (this.displacementBias = e.displacementBias),
          (this.specularMap = e.specularMap),
          (this.alphaMap = e.alphaMap),
          (this.envMap = e.envMap),
          (this.combine = e.combine),
          (this.reflectivity = e.reflectivity),
          (this.refractionRatio = e.refractionRatio),
          (this.wireframe = e.wireframe),
          (this.wireframeLinewidth = e.wireframeLinewidth),
          (this.wireframeLinecap = e.wireframeLinecap),
          (this.wireframeLinejoin = e.wireframeLinejoin),
          (this.flatShading = e.flatShading),
          (this.fog = e.fog),
          this
        );
      }
    })({ vertexColors: !0, wireframe: !1, flatShading: !1, shininess: 10 });
  function y_() {
    return (y_ = Yg(
      Gg().m(function e() {
        return Gg().w(function (e) {
          for (;;)
            switch (e.n) {
              case 0:
                return (e.n = 1), n_();
              case 1:
                if (e.v)
                  try {
                    (d_ = new sc()),
                      (p_ = a_.xr.getController(0)),
                      (f_ = a_.xr.getController(1)),
                      o_.add(p_),
                      o_.add(f_),
                      (m_ = a_.xr.getControllerGrip(0)),
                      (g_ = a_.xr.getControllerGrip(1)),
                      m_.add(d_.createControllerModel(m_)),
                      g_.add(d_.createControllerModel(g_)),
                      o_.add(m_),
                      o_.add(g_),
                      console.log("XR  ");
                  } catch (e) {
                    console.error("XR   :", e);
                  }
              case 2:
                return e.a(2);
            }
        }, e);
      })
    )).apply(this, arguments);
  }
  function b_(e) {
    if (!Zg.has(e)) {
      var t = new Rr();
      t.setHSL(e / 360, 1, 0.5), Zg.set(e, { r: t.r, g: t.g, b: t.b });
    }
    return Zg.get(e);
  }
  function x_(e) {
    for (
      var t = e.width,
        r = e.height,
        n = e.data,
        i = new Xr(),
        o = new Float32Array(t * r * 3),
        s = new Float32Array(t * r * 3),
        a = new Uint32Array((t - 1) * (r - 1) * 6),
        l = 0,
        c = 0;
      c < r;
      c++
    )
      for (var u = 0; u < t; u++) {
        var h = c * t + u,
          d = 3 * h,
          p = n[h],
          f = 3 * p;
        (o[d] = u - t / 2), (o[d + 1] = f), (o[d + 2] = c - r / 2);
        var m = b_(240 * (1 - p));
        (s[d] = m.r), (s[d + 1] = m.g), (s[d + 2] = m.b);
      }
    for (var g = 0; g < r - 1; g++)
      for (var _ = 0; _ < t - 1; _++) {
        var v = g * t + _,
          y = g * t + _ + 1,
          b = (g + 1) * t + _,
          x = (g + 1) * t + _ + 1;
        (a[l++] = v),
          (a[l++] = b),
          (a[l++] = y),
          (a[l++] = y),
          (a[l++] = b),
          (a[l++] = x);
      }
    return (
      i.setAttribute("position", new Ur(o, 3)),
      i.setAttribute("color", new Ur(s, 3)),
      i.setIndex(new Ur(a, 1)),
      i.computeVertexNormals(),
      i
    );
  }
  function w_(e) {
    var t = null,
      r = 0;
    e.on("message", function (e, n) {
      var i = Date.now();
      if ((r++, null !== t)) {
        var o = i - t;
        console.log(
          "  #"
            .concat(r, "  (: ")
            .concat(o, "ms, : ")
            .concat(e, ")")
        );
      } else console.log("  #".concat(r, "   (: ").concat(e, ")"));
      if (((t = i), e === Wg.topic))
        try {
          var s;
          s =
            "string" == typeof n
              ? n
              : n instanceof Uint8Array || ArrayBuffer.isView(n)
              ? new TextDecoder().decode(n)
              : n.toString();
          var a = JSON.parse(s);
          (function (e) {
            if (!(e && e.width && e.height && Array.isArray(e.data))) return !1;
            var t = e.width * e.height;
            if (e.data.length !== t) return !1;
            for (var r = 1 / 0, n = -1 / 0, i = 0; i < e.data.length; i++) {
              var o = e.data[i];
              if ("number" != typeof o) return !1;
              o < r && (r = o), o > n && (n = o);
            }
            if (r < 0 || n > 1) {
              var s = n - r;
              if (s > 0)
                for (var a = 0; a < e.data.length; a++)
                  e.data[a] = (e.data[a] - r) / s;
              else for (var l = 0; l < e.data.length; l++) e.data[l] = 0.5;
            }
            return !0;
          })(a) &&
            (console.log(
              " MQTT  : "
                .concat(a.width, "x")
                .concat(a.height, " (")
                .concat(a.data.length, " )")
            ),
            (function (e) {
              var t = e.width,
                r = e.height,
                n = e.data;
              if (Jg && Jg.geometry) {
                if (Kg) {
                  var i = Jg.geometry.getAttribute("position"),
                    o = t * r,
                    s = !i || i.array.length / 3 !== o;
                  return (
                    console.log(
                      " Worker  : "
                        .concat(t, "x")
                        .concat(r, " (: ")
                        .concat(s, ")")
                    ),
                    void Kg.postMessage(
                      {
                        type: "PROCESS_ELEVATION",
                        data: {
                          width: t,
                          height: r,
                          elevationData: n,
                          isRecreate: s,
                        },
                      },
                      [n.buffer]
                    )
                  );
                }
                !(function (e) {
                  var t = performance.now();
                  if (Jg && Jg.geometry) {
                    var r = e.width,
                      n = e.height,
                      i = e.data,
                      o = Jg.geometry.getAttribute("position"),
                      s = Jg.geometry.getAttribute("color");
                    if (o && s) {
                      var a = o.array,
                        l = s.array,
                        c = r * n;
                      if (a.length / 3 === c) {
                        for (var u = 0; u < n; u++)
                          for (var h = 0; h < r; h++) {
                            var d = u * r + h,
                              p = 3 * d;
                            if (p + 2 >= a.length || d >= i.length)
                              console.warn(
                                "   : posIdx="
                                  .concat(p, ", idx=")
                                  .concat(d)
                              );
                            else {
                              var f = 3 * i[d];
                              (a[p] = h - r / 2),
                                (a[p + 1] = f),
                                (a[p + 2] = u - n / 2);
                              var m = b_(240 * (1 - i[d]));
                              (l[p] = m.r), (l[p + 1] = m.g), (l[p + 2] = m.b);
                            }
                          }
                        (o.needsUpdate = !0),
                          (s.needsUpdate = !0),
                          Jg.geometry.computeVertexNormals();
                        var g = performance.now();
                        console.log(
                          "   ( - ) - "
                            .concat((g - t).toFixed(2), "ms | ")
                            .concat(r, "x")
                            .concat(n)
                        );
                      } else {
                        console.log(
                          "   : "
                            .concat(a.length / 3, "  ")
                            .concat(c, " ")
                        ),
                          console.log("    geometry  ");
                        var _ = x_(e);
                        Jg.geometry.dispose(), (Jg.geometry = _);
                        var v = performance.now();
                        console.log(
                          "   ( - ) - ".concat(
                            (v - t).toFixed(2),
                            "ms"
                          )
                        );
                      }
                    } else $g(" /  ");
                  } else $g("    ");
                })(e);
              } else $g("    ");
            })(a),
            console.log("      "));
        } catch (e) {
          $g(" MQTT   :", e.message);
        }
    }),
      e.on("error", function (e) {
        $g(" MQTT :", e.message);
      }),
      e.on("offline", function () {}),
      e.on("reconnect", function () {}),
      e.on("close", function () {});
  }
  function S_() {
    console.log(" MQTT   ..."),
      "https:" === window.location.protocol
        ? (console.log(" HTTPS  - WSS  "),
          window.location.hostname.includes("ngrok") &&
            (console.log(" ngrok  -   :"),
            console.log(
              "   localStorage.setItem('ngrok_mqtt_host', 'YOUR_HOST');"
            ),
            console.log(
              "   localStorage.setItem('ngrok_mqtt_port', 'YOUR_PORT');"
            ),
            console.log("   location.reload();")))
        : console.log(" HTTP  () - WS  "),
      console.log("  :", Wg.broker),
      w_((Qg = jg.connect(Wg.broker, Wg.options))),
      Qg.on("connect", function () {
        console.log(" MQTT "),
          Qg.subscribe(Wg.topic, { qos: 0 }, function (e, t) {
            e
              ? $g("  :", e.message)
              : (console.log("  : ".concat(Wg.topic)),
                setInterval(function () {
                  Qg.subscribe(Wg.topic, { qos: 0 });
                }, 500),
                console.log(" 0.5   "));
          });
      });
  }
  ((Jg = new hn(__, v_)).receiveShadow = !0),
    (Jg.castShadow = !0),
    o_.add(Jg),
    console.log("     (mockData )"),
    (function () {
      y_.apply(this, arguments);
    })(),
    setInterval(function () {
      !(function () {
        if (!Qg)
          return (
            console.log(" MQTT   -  "), void S_()
          );
        Qg.connected
          ? console.log(" MQTT  ")
          : (console.log(" MQTT   -  "),
            Qg.reconnecting || Qg.reconnect());
      })();
    }, 6e4),
    window.addEventListener("load", function () {
      S_();
    }),
    window.addEventListener("beforeunload", function () {
      Qg &&
        (console.log(" MQTT    ..."),
        Qg.end(!0, function () {
          console.log(" MQTT   ");
        }));
    }),
    window.addEventListener("resize", function () {
      var e = window.innerWidth,
        t = window.innerHeight;
      (s_.aspect = e / t), s_.updateProjectionMatrix(), a_.setSize(e, t);
    });
  var E_ = !1;
  function M_() {
    return (M_ = Yg(
      Gg().m(function e() {
        return Gg().w(function (e) {
          for (;;)
            switch (e.n) {
              case 0:
                return (e.n = 1), n_();
              case 1:
                e.v &&
                  (a_.xr.addEventListener("sessionstart", function () {
                    (E_ = !0), console.log("XR  ");
                  }),
                  a_.xr.addEventListener("sessionend", function () {
                    (E_ = !1), console.log("XR  ");
                  }));
              case 2:
                return e.a(2);
            }
        }, e);
      })
    )).apply(this, arguments);
  }
  function T_() {
    !(function () {
      (e_.currentRotationX += 0.1 * (e_.targetRotationX - e_.currentRotationX)),
        (e_.currentRotationY +=
          0.1 * (e_.targetRotationY - e_.currentRotationY));
      var e = new ut(0, 5, 0),
        t = e_.currentRotationX,
        r = e_.currentRotationY;
      (s_.position.x = e.x + e_.distance * Math.sin(r) * Math.cos(t)),
        (s_.position.y = e.y + e_.distance * Math.sin(t)),
        (s_.position.z = e.z + e_.distance * Math.cos(r) * Math.cos(t)),
        s_.lookAt(e);
      var n = new ut();
      if (
        ((e_.keys.w || e_.keys.ArrowUp) && (n.z -= e_.moveSpeed),
        (e_.keys.s || e_.keys.ArrowDown) && (n.z += e_.moveSpeed),
        (e_.keys.a || e_.keys.ArrowLeft) && (n.x -= e_.moveSpeed),
        (e_.keys.d || e_.keys.ArrowRight) && (n.x += e_.moveSpeed),
        e_.keys.q && (n.y -= e_.moveSpeed),
        e_.keys.e && (n.y += e_.moveSpeed),
        n.length() > 0)
      ) {
        var i = new ut();
        s_.getWorldDirection(i);
        var o = new ut();
        o.crossVectors(s_.up, i).normalize();
        var s = s_.up;
        n.copy(
          new ut()
            .addScaledVector(o, n.x)
            .addScaledVector(i, n.z)
            .addScaledVector(s, n.y)
        ),
          s_.position.add(n);
      }
    })(),
      a_.render(o_, s_);
  }
  function A_() {
    return (A_ = Yg(
      Gg().m(function e() {
        return Gg().w(function (e) {
          for (;;)
            switch (e.n) {
              case 0:
                return (e.n = 1), n_();
              case 1:
                e.v &&
                  (a_.xr.setAnimationLoop(T_),
                  console.log("XR   "));
              case 2:
                return e.a(2);
            }
        }, e);
      })
    )).apply(this, arguments);
  }
  !(function () {
    M_.apply(this, arguments);
  })(),
    (function () {
      A_.apply(this, arguments);
    })(),
    (window.testMQTT = {
      publishTestMessage: function () {
        var e = {
          width: 5,
          height: 5,
          data: [
            0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 0.1, 0.2, 0.3, 0.4,
            0.5, 0.6, 0.7, 0.8, 0.9, 1, 0.1, 0.2, 0.3, 0.4, 0.5,
          ],
        };
        console.log("   :", e),
          Qg.publish(Wg.topic, JSON.stringify(e), { qos: 1 }, function (e) {
            e
              ? console.error("  :", e)
              : console.log("    ");
          });
      },
      testMessageHandler: function () {
        console.log("     ");
        var e = new TextEncoder().encode(
            JSON.stringify({
              width: 3,
              height: 3,
              data: [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9],
            })
          ),
          t = Qg.listeners("message");
        console.log(" message :", t.length),
          t.length > 0
            ? (console.log("     ..."),
              t[0](Wg.topic, e),
              console.log("     "))
            : console.error("   !");
      },
      checkConnection: function () {
        console.log("   :"),
          console.log("  - connected:", Qg.connected),
          console.log("  - connecting:", Qg.connecting),
          console.log("  - reconnecting:", Qg.reconnecting),
          console.log("  - activeSubscriptions:", activeSubscriptions),
          console.log("  - message  :", Qg.listeners("message").length);
      },
      resubscribe: function () {
        console.log("  ..."),
          Qg.subscribe(Wg.topic, { qos: 1 }, function (e, t) {
            e
              ? console.error("  :", e)
              : ((activeSubscriptions[Wg.topic] = 1),
                console.log("  :", t));
          });
      },
      setCameraControl: function (e) {
        console.log("   :", e),
          "fast" === e
            ? ((e_.moveSpeed = 1),
              (e_.zoomSpeed = 5),
              console.log("   "))
            : "slow" === e
            ? ((e_.moveSpeed = 0.1),
              (e_.zoomSpeed = 0.5),
              console.log("   "))
            : "normal" === e &&
              ((e_.moveSpeed = 0.5),
              (e_.zoomSpeed = 2),
              console.log("    "));
      },
      resetCamera: function () {
        console.log("  "),
          (e_.currentRotationX = 0),
          (e_.currentRotationY = 0),
          (e_.targetRotationX = 0),
          (e_.targetRotationY = 0),
          (e_.distance = 20),
          console.log("   ");
      },
    }),
    (window.xrControl = {
      getXRStatus: function () {
        console.log(" WebXR :"),
          console.log("  - WebXR :", t_),
          console.log("  - XR  :", E_),
          console.log("  - XR  :", r_),
          console.log("  -  XR :", a_.xr.enabled);
      },
      getSessionInfo: function () {
        var e;
        console.log(" XR  :"),
          console.log("  -  :", a_.xr.getSession()),
          console.log(
            "  - :",
            (null === (e = navigator.xr) ||
            void 0 === e ||
            null === (e = e.session) ||
            void 0 === e
              ? void 0
              : e.inputSources) || ""
          );
      },
    }),
    console.log("   window.testMQTT ."),
    console.log(" : window.testMQTT.publishTestMessage()"),
    console.log(" : window.testMQTT.testMessageHandler()"),
    console.log(" : window.testMQTT.checkConnection()"),
    console.log(" : window.testMQTT.resubscribe()"),
    console.log(" : window.testMQTT.setCameraControl('fast')"),
    console.log(" : window.testMQTT.resetCamera()"),
    console.log(""),
    console.log(" WebXR :"),
    console.log(" : window.xrControl.getXRStatus()"),
    console.log(" : window.xrControl.getSessionInfo()"),
    document.addEventListener("mousedown", function (e) {
      0 === e.button &&
        ((e_.isMouseDown = !0),
        (e_.mouseX = e.clientX),
        (e_.mouseY = e.clientY));
    }),
    document.addEventListener("mousemove", function (e) {
      if (e_.isMouseDown) {
        var t = e.clientX - e_.mouseX,
          r = e.clientY - e_.mouseY;
        (e_.targetRotationY += t * e_.rotationSpeed),
          (e_.targetRotationX += r * e_.rotationSpeed),
          (e_.targetRotationX = Math.max(
            -Math.PI / 2 + 0.1,
            Math.min(Math.PI / 2 - 0.1, e_.targetRotationX)
          )),
          (e_.mouseX = e.clientX),
          (e_.mouseY = e.clientY);
      }
    }),
    document.addEventListener("mouseup", function () {
      e_.isMouseDown = !1;
    }),
    document.addEventListener(
      "wheel",
      function (e) {
        e.preventDefault(),
          (e_.distance += e.deltaY > 0 ? e_.zoomSpeed : -e_.zoomSpeed),
          (e_.distance = Math.max(
            e_.minDistance,
            Math.min(e_.maxDistance, e_.distance)
          ));
      },
      { passive: !1 }
    ),
    document.addEventListener("keydown", function (e) {
      (e_.keys[e.key.toLowerCase()] = !0), (e_.keys[e.code] = !0);
    }),
    document.addEventListener("keyup", function (e) {
      (e_.keys[e.key.toLowerCase()] = !1), (e_.keys[e.code] = !1);
    }),
    (function e() {
      (t_ && E_) || T_(), requestAnimationFrame(e);
    })();
})();
//# sourceMappingURL=bundle.js.map
